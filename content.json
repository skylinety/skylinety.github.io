{"meta":{"title":"鹧鸪天","subtitle":"大江东去，长安西去，为功名走遍天涯路。 厌舟车，喜琴书，早星星鬓影瓜田暮。 心待足时名便足：高，高处苦；低，低处苦 — 薛昂夫","description":"乍起新寒风又嚎，厦间不见杜家茅。落棋柯烂朝兴替，弹指风挥花盛飘。梦缥缈，路遥迢，随流逐浪几多豪？待心足了即名了，斜雨泥丫印土桥。","author":"skyline","url":"http://www.skyline.show"},"pages":[{"title":"","date":"2023-02-14T15:32:25.202Z","updated":"2022-04-22T10:00:30.000Z","comments":true,"path":"404.html","permalink":"http://www.skyline.show/404.html","excerpt":"","text":""},{"title":"宾果","date":"2016-04-20T20:48:33.000Z","updated":"2023-03-09T05:29:40.288Z","comments":false,"path":"about/index.html","permalink":"http://www.skyline.show/about/index.html","excerpt":"","text":"宾果，人家就是敲代码嗒~90后，UESTC纯工科毕业，承认老啦，但求别加入脱发大军就行~ 去过杭城，在西湖边晒过太阳，去雷峰塔下找过大白蛇老乡，也在湘湖边看过小桥流水~目前在蓉城，是一颗在前端道路上不（kai）断(shi)进(tuo)化(fa)的老白菜。 喜欢的东西有好多。摄影，历史，小说，诗词，爬爬山，玩玩水，当然还有coding~说到摄影，买来的相机好久都没开机啦，看了好几本摄影书都不会玩，基本处理懵Q状态，大神求带啊~说到历史，最稀罕大宋啦。不仅仅因为有稀罕的宋词、稀罕的东坡、稀罕的繁荣经济，也因为有国难下捐躯的英雄、烽火下无辜的百姓、北国大雪纷飞下受难的帝姬~说到小说，当然不只是看啊。但想起自己几次尝试都只写了一个开头，好气啊~说到诗词，更偏爱词，东坡、二晏、纳兰，简直溜到爆炸~说到游山玩水，哪个不喜欢啊，但是钱包时常不允许啊啊啊~说到敲代码，额，对了，不说啦，该敲代码啦~ 博客中大多数技术文章都是日常积累的笔记，一个人的笔记，错误当然有好多，若发现错误请联系更正~最后来首自己填的《鹧鸪天》来收(zhuang)个(ge)尾(X)： 乍起新寒风又嚎，厦间不见杜家茅。落棋柯烂朝兴替，弹指风挥花盛飘。梦缥缈，路遥迢，随流逐浪几多豪？待心足了即名了，斜雨泥丫印土桥。 愿所有人都早日心足，到自己喜欢的地方，干自己喜欢的事情。 邮箱: skylinety@icloud.comQQ: 626660911微信: skylinelty"},{"title":"categories","date":"2023-02-14T15:32:25.349Z","updated":"2022-04-22T10:00:30.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.skyline.show/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2023-02-14T15:32:25.351Z","updated":"2022-04-22T10:00:30.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.skyline.show/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES事件轮询","slug":"ES事件轮询","date":"2023-03-03T03:53:29.000Z","updated":"2023-03-03T03:56:34.000Z","comments":true,"path":"ES事件轮询.html","link":"","permalink":"http://www.skyline.show/ES事件轮询.html","excerpt":"执行机制单线程JS 设计为单线程脚本语言，主线程只能同时处理一个任务。为了防止主线程阻塞，事件轮询机制应运而生（event loop）先看如下一个常见示例 console.log(1)setTimeout(() =&gt; &#123; console.log(5)&#125;, 0)setTimeout(() =&gt; &#123; console.log(6)&#125;, 10)Promise.resolve() .then(() =&gt; &#123; console.log(3) &#125;) .then(() =&gt; &#123; console.log(4) &#125;)console.log(2)// 1 2 3 4 5 6 同异步","text":"执行机制单线程JS 设计为单线程脚本语言，主线程只能同时处理一个任务。为了防止主线程阻塞，事件轮询机制应运而生（event loop）先看如下一个常见示例 console.log(1)setTimeout(() =&gt; &#123; console.log(5)&#125;, 0)setTimeout(() =&gt; &#123; console.log(6)&#125;, 10)Promise.resolve() .then(() =&gt; &#123; console.log(3) &#125;) .then(() =&gt; &#123; console.log(4) &#125;)console.log(2)// 1 2 3 4 5 6 同异步 todo 执行栈函数的执行时会被放入栈中，多个函数嵌套时，遵循栈的原则，即先进后出。 宏微任务JS 主程序（整体代码）就是一个宏任务，主程序开始执行时，将其内部执行函数不断入栈出栈。微任务在代码执行过程中产生并进入微任务队列。宏任务执行过程中若遇到调用 WebAPI（UI 事件注册，定时器注册）等代码，会交于对应触发线程，主程序往后执行。当前宏任务执行完成后，将微任务依次放入执行栈执行，直到当前微任务队列被会清空。宏任务队列中下一个宏任务放入执行栈执行。新的宏任务进入队列时机取决于触发线程什么时候返回结果，拿到结果时，宏任务回调进入宏任务队列中等待执行。任务的执行遵循队列的原则，即先进先出。 常见的任务宏任务： script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件微任务： Promise、async/await、MutaionObserver、process.nextTick(Node.js) 事件轮询JS 执行机制为：主程序作为一个宏任务，首先执行。执行一个宏任务，执行完毕后，清空执行该宏任务产生的微任务。执行下一个宏任务，继续清执行空其产生的微任务，由此循环往复。通过不断地轮询，不断地在上述过程循环，就像是在宏任务与微任务之前转圈圈。 进一步简化图示，可以看成一个队列中的代码依次进入执行栈执行。 轮询与页面渲染主入口程序为宏任务，将每次轮询的宏任务和其产生的微任务看做一对，宏任务先执行，微任务后执行（很多文章观点为微任务先执行，这是抛开主程序为宏任务的观点），每次轮询中队列内执行会先于DOM渲染，只有微任务队列最后一个任务被执行，DOM才会被渲染。 由于alert会阻塞DOM渲染，故示例代码中间定时器的时间延长，方便观察DOM渲染的时机。 alert('首次轮询宏任务（主入口程序）')function createEL(tag = 'h3', content) &#123; const e = document.createElement(tag) e.innerHTML = content return e&#125;document.body.appendChild(createEL('h3', 'number 1'))setTimeout(() =&gt; &#123; alert('第二轮轮询只有宏任务') document.body.appendChild(createEL('h3', 'number 5'))&#125;, 3000)setTimeout(() =&gt; &#123; document.body.appendChild(createEL('h3', 'number 6')) alert('第三轮轮询宏任务') Promise.resolve() .then(() =&gt; &#123; document.body.appendChild(createEL('h3', 'number 7')) alert('第三轮轮询微任务') &#125;)&#125;, 10000)Promise.resolve() .then(() =&gt; &#123; document.body.appendChild(createEL('h3', 'number 3')) alert('首次轮询微任务') &#125;) .then(() =&gt; &#123; document.body.appendChild(createEL('h3', 'number 4')) &#125;)document.body.appendChild(createEL('h3', 'number 2')) 可以观察到，只有每一轮的轮询最后的微任务执行完成，与该次轮询关联的DOM渲染才会执行。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES事件轮询$.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"原理","slug":"原理","permalink":"http://www.skyline.show/tags/原理/"}]},{"title":"ES防抖和节流","slug":"ES防抖和节流","date":"2023-03-02T06:16:35.000Z","updated":"2023-03-03T03:56:34.000Z","comments":true,"path":"ES防抖和节流.html","link":"","permalink":"http://www.skyline.show/ES防抖和节流.html","excerpt":"防抖 防抖的理解 防抖基础版本 立即执行首次 this绑定与event 节流 节流的理解 节流基础版本 this绑定与event 头尾执行定制 BMW WARNING 防抖防抖的理解防抖debounce ，即防止抖动。当事件不停地触发时，浏览器为了应对同一时间段的大量任务，交互区域表现出来就像是在抖动。防抖将事件触发规定在单位时间内，单位时间内新事件触发会丢弃上次事件并重新计算下个时间段，以此往复，直到最新的单位时间段内无新事件触发，对应函数执行完成。 防抖一般只执行最后一次函数，或根据需求，立即执行首次函数，然后只执行后续连续触发的最后一次。 其主要实现原理： setTimeout 闭包 防抖基础版本","text":"防抖 防抖的理解 防抖基础版本 立即执行首次 this绑定与event 节流 节流的理解 节流基础版本 this绑定与event 头尾执行定制 BMW WARNING 防抖防抖的理解防抖debounce ，即防止抖动。当事件不停地触发时，浏览器为了应对同一时间段的大量任务，交互区域表现出来就像是在抖动。防抖将事件触发规定在单位时间内，单位时间内新事件触发会丢弃上次事件并重新计算下个时间段，以此往复，直到最新的单位时间段内无新事件触发，对应函数执行完成。 防抖一般只执行最后一次函数，或根据需求，立即执行首次函数，然后只执行后续连续触发的最后一次。 其主要实现原理： setTimeout 闭包 防抖基础版本 function debounce(fn, time) &#123; let t = null return () =&gt; &#123; if(t)&#123; clearTimeout(t) &#125; t = setTimeout(fn, time) &#125;&#125; 立即执行首次只在第一次触发时执行，后续重新执行时的第一次不再执行 function debounce(fn, time) &#123; let t = null let count = 0 return () =&gt; &#123; if(t)&#123; clearTimeout(t) &#125; if(count)&#123; t = setTimeout(fn, time) &#125;else&#123; fn() &#125; count++ &#125;&#125; 第一次触发时执行，后续重新执行时的第一次都会执行 function debounce(fn, time) &#123; let t = null let count = 0 return () =&gt; &#123; if (t) &#123; clearTimeout(t) &#125; if (count) &#123; t = setTimeout(() =&gt; &#123; count = 0; fn() &#125;, time) &#125; else &#123; fn() &#125; count++ &#125;&#125; 由于使用了setTimeout对实际回调进行包裹，fn的this指向改变，同时，这里event对象回调参数丢失，可通过apply绑定this并获取arguments进行传参。 this绑定与eventfunction debounce(fn, time) &#123; let t = null let count = 0 return function() &#123; const me = this const args = arguments if (t) &#123; clearTimeout(t) &#125; if (count) &#123; t = setTimeout(() =&gt; &#123; count = 0; fn.apply(this, args) &#125;, time) &#125; else &#123; fn.apply(this, args) &#125; count++ &#125;&#125; 这里需要注意，由于箭头函数this在定义时已定不再是执行时，故而需要改为普通函数。 节流节流的理解节流 throttle ，顾名思义，就是控制流量。例如，当持续触发事件，单元时间内，只执行一次事件。节流会执行多次函数，只是减少了函数执行的次数。节流的实现在闭包的基础上，可以通过时间戳求差或者setTimeout来实现。 其主要实现原理： 闭包 时间戳差/setTimeout 节流基础版本function throttle(fn, time) &#123; let t = null return () =&gt; &#123; if (!t) &#123; t = setTimeout(() =&gt; &#123; t = null; fn() &#125;, time) &#125; &#125;&#125; this绑定与eventfunction throttle(fn, time) &#123; let t = null return function () &#123; const args = arguments if (!t) &#123; t = setTimeout(() =&gt; &#123; t = null; fn.apply(this, args) &#125;, time) &#125; &#125;&#125; 头尾执行定制节流的需求不同，往往有事件触发时（头）立即执行，事件停止触发（尾）后不再执行的需求。可能需要执行有头有尾，有头无尾，无头有尾。这一部分内容实现需要引入时间戳来实现，具体参照underscore等三方库的完整轮子。文章对应示例文件可在浏览器直接执行。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES防抖和节流.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"计算机机器码","slug":"计算机机器码","date":"2023-02-22T02:04:40.000Z","updated":"2023-03-04T03:08:20.000Z","comments":true,"path":"计算机机器码.html","link":"","permalink":"http://www.skyline.show/计算机机器码.html","excerpt":"常见机器码 原码 反码 补码 移码 数值的机器码值 机器码的设计 计算机天选机器码 模与同余定理 BMW WARNING 常见机器码原码十进制转换成二进制之后的数值，加上0正1负的符号位 反码","text":"常见机器码 原码 反码 补码 移码 数值的机器码值 机器码的设计 计算机天选机器码 模与同余定理 BMW WARNING 常见机器码原码十进制转换成二进制之后的数值，加上0正1负的符号位 反码 正数的反码是原码本身，负数的反码是数值位按位非 补码正数的补码是原码本身，负数的补码是反码+1 移码将符号位取反的补码（不区分正负） 数值的机器码值机器码的设计（此处不讨论移码）假定现有一个单次最高可处理4位二进制的系统，若只处理正数，那其能处理的数值范围0-15。现有负数需求，将最高位设定为符号位，设定符号位后，能够存储的正数数值范围要砍对半。故而需要在十进制转换的二进制数基础之上，进一步设计完善，来保障储存正数与负数。按照习惯，现在约定俗成原有前半部分的正数数值保持不变，后半部分的数值来存储负数部分，这也是为什么机器码中是0表示正数，1表示负数的原因。负数的存储有多种方案可采用，也就是原码、反码、补码。 各数值对应机器码值如下： 由图可知，正数的原码，反码，补码都全部相同，都是数值对应的实际的二进制。 计算机天选机器码先说结论：补码是最优的储存方式，计算机中所有数都是以补码形式存储的。 当计算机进行数值计算时，首先要将十进制转换为机器码。回到上图的轮盘，假定当前位置在原点0处为起点，要跑到11的位置，可以前进11步，也可以后退5步。即+11 == -5 满足条件的只有补码。上面的一个轮盘就是一个模为16的计量系统，不同位数的二进制系统的模为$2^n$。按照补码的设计，计算机在实际计算负数时就非常方便，如上要获取-5的补码，直接求11的补码，即直接获取11的二进制。又比如，在8位二进制计量系统中，求-5的补码，即求$256 - 5 = 251$的二进制，即为11111011。对应到实际计量系统，直接用计量系统的模减去负数的绝对值即可。 计算机使用补码，可以统一将符号位和数值位处理而不用特殊对待最高位的符号位；在进行加减运算时统一看做加法处理。在现实生活中，时钟就是一个以12位模的计量系统。 模与同余定理两个整数a、b，若它们除以整数m所得的余数相等，则称a与b对于模m同余或a同余于b模m。记作：$a≡b (mod\\space m)$，读作：a同余于b模m，或读作a与b对模m同余，例如26≡2(mod 12)。 大白话就是a和b在分成m份的圈里处于同一位置。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/计算机机器码.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Software","slug":"Software","permalink":"http://www.skyline.show/tags/Software/"}]},{"title":"String相关基础操作","slug":"String相关基础操作","date":"2023-02-09T01:12:14.000Z","updated":"2023-02-09T01:12:14.000Z","comments":true,"path":"String相关基础操作.html","link":"","permalink":"http://www.skyline.show/String相关基础操作.html","excerpt":"字符串存为数组 重复字符串 变量命名 中划线转驼峰 驼峰转中划线 交换单词位置 BMW WARNING 字符串存为数组var a = 'skyline'var b = Array.prototype.slice.call(a, 0)// ['s', 'k', 'y', 'l', 'i', 'n', 'e']var c = a.split('')// ['s', 'k', 'y', 'l', 'i', 'n', 'e'] 重复字符串主要为使用字符串的 repeat 方法或数组来实现 Array(7).fill('1').join('')// '1111111'new Array(8).join(1)// '1111111''1'.repeat(7)// '1111111'String.prototype.repeat.call(1, 7)// '1111111' 变量命名","text":"字符串存为数组 重复字符串 变量命名 中划线转驼峰 驼峰转中划线 交换单词位置 BMW WARNING 字符串存为数组var a = 'skyline'var b = Array.prototype.slice.call(a, 0)// ['s', 'k', 'y', 'l', 'i', 'n', 'e']var c = a.split('')// ['s', 'k', 'y', 'l', 'i', 'n', 'e'] 重复字符串主要为使用字符串的 repeat 方法或数组来实现 Array(7).fill('1').join('')// '1111111'new Array(8).join(1)// '1111111''1'.repeat(7)// '1111111'String.prototype.repeat.call(1, 7)// '1111111' 变量命名 中划线转驼峰'my-name-is-skyline'.replace(/-(\\w)/g, (...args) =&gt; args[1].toUpperCase())// 'myNameIsSkyline' 这里涉及字符串 replace 的用法。 str.replace(regexp|substr, newSubstr|function) 如果第一个参数是正则表达式， 并且其为全局匹配模式，同时指定一个函数作为第二个参数。当匹配执行后，第二参数对应的函数就会执行，该函数的返回值作为替换字符串。第二参数对应的函数，其参数如下： function(match,p1,p2, ... ,offset, string, groups)&#123;return newStr&#125; 参数解析如下： key value match 匹配的子串 p1,p2, … 假如 replace()方法的第一个参数是一个 RegExp 对象，则代表第 n 个括号匹配的字符串 offset 匹配到的子字符串在原字符串中的偏移量） string 被匹配的原字符串 groups 具名组构成的一个对象 查看上例过程输出： 'my-name-is-skyline'.replace(/-(\\w)/g, (...args) =&gt; &#123; console.log(...args) return args[1].toUpperCase()&#125;)// -n n 2 my-name-is-skyline// -i i 7 my-name-is-skyline// -s s 10 my-name-is-skyline 驼峰转中划线'myNameIsSkyline'.replace(/([A-Z])/g, '-$1').toLowerCase()// 'my-name-is-skyline' 若 replace 的第二个参数不是函数而是替换字符 newSubstr，可以在第二个参数中插入特殊变量来表示源字符相关字符。$n 表示插入第 n 个捕获括号匹配的字符串。 交换单词位置'Skyline Liu'.replace(/(\\w+)\\s(\\w+)/g, '$2, $1')// 'Liu, Skyline' BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/String 相关基础操作.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"ES常用正则","slug":"ES常用正则","date":"2023-02-04T08:20:11.000Z","updated":"2023-02-15T08:48:57.000Z","comments":true,"path":"ES常用正则.html","link":"","permalink":"http://www.skyline.show/ES常用正则.html","excerpt":"正则对象 正则创建 双重转义 RegExp.prototype.exec() 正则标志 基本规则 正则使用 基础使用汇总 匹配定长字符 BMW WARNING 正则对象正则创建正则创建有两种方式，对象字面量与构造函数。使用构造函数 RegExp 创建时接受两个参数。第一个是要匹配的字符串模式，第二个是可选的标识字符串。当创建的字符中包含元字符(正则中有特殊含义或功能的字符)时，要表示原有字符的含义，两种方式创建时都要需要在元字符前使用\\进行转义，使其表示为普通含义。常见的特殊字符有： [ \\ ^ $ . | ? * + ( ) 双重转义","text":"正则对象 正则创建 双重转义 RegExp.prototype.exec() 正则标志 基本规则 正则使用 基础使用汇总 匹配定长字符 BMW WARNING 正则对象正则创建正则创建有两种方式，对象字面量与构造函数。使用构造函数 RegExp 创建时接受两个参数。第一个是要匹配的字符串模式，第二个是可选的标识字符串。当创建的字符中包含元字符(正则中有特殊含义或功能的字符)时，要表示原有字符的含义，两种方式创建时都要需要在元字符前使用\\进行转义，使其表示为普通含义。常见的特殊字符有： [ \\ ^ $ . | ? * + ( ) 双重转义 \\除了在正则中表示转义字符，在字符串中也是转义字符。常见的就是表示换行和 Unicode 字符，其他还有制表符，回退等。 \\n 即换行 \\u 即表示 Unicode 字符。\\u{61} 表示字符’a’ \\接无效字符时，转义会被自动移除。 var skyline = 's.s'console.log(skyline) // \"s.s\"var test = '.at skyline'console.log(test) // \".at skyline\" 当使用构造函数创建正则时，第一参数为字符串，需要匹配的字符包含元字符时，由于字符串要消耗\\转义，此时的元字符需要进行双重转义。 例如，当需要匹配字符串’.at skyline’时： 字面量定义： /\\.at\\sskyline/gi构造函数定义： new RegExp(&#39;\\\\.at\\\\sskyline&#39;, &#39;gi&#39;) var reg = /\\.at\\sskyline/givar reg1 = new RegExp('\\\\.at\\\\sskyline', 'gi')console.log(reg.test('.at skyline'))// trueconsole.log(reg1.test('.at skyline'))// true RegExp.prototype.exec()exec 用于搜索指定字符串的匹配，当匹配成功时，返回数组，失败返回 null。 RegExpObject.exec(string) 返回的数组跟正则是否有子串（正则的圆括号内，圆括号被称为捕获括号），是否全局，开始匹配的位置（lastIndex 指定）有关。 非全局有子串 var str = 'Skyline should be hardworking(Skyline up up up)'var reg = /Sky(line)/console.log(reg.exec(str))// [\"Skyline\", \"line\", index: 0, input: \"Skyline should be hardworking(Skyline up up up)\"]console.log(reg.exec(str))// [\"Skyline\", \"line\", index: 0, input: \"Skyline should be hardworking(Skyline up up up)\"]console.log(str.match(reg))// [\"Skyline\", \"line\", index: 0, input: \"Skyline should be hardworking(Skyline up up up)\"] 未开启全局，多次执行返回结果一致，此时函数的用法与 String.prototype.match 类似，只能够在字符串中匹配一次，用于获取匹配的字符串；如果没有找到匹配的字符串，那么返回 null。 string.match(RegExpObject) 全局有子串 var str1 = 'Skyline should be hardworking(Skyline up up up Skyline)'var reg1 = /Skylin(e)/greg1.lastIndex = 8console.log(reg1.exec(str1))console.log(reg1.lastIndex)// VM1002:4 (2) [\"Skyline\", \"e\", index: 30, input: \"Skyline should be hardworking(Skyline up up up Skyline)\"]// 37console.log(reg1.exec(str1))// VM1016:1 (2) [\"Skyline\", \"e\", index: 47, input: \"Skyline should be hardworking(Skyline up up up Skyline)\"]console.log(reg1.exec(str1))// VM1021:1 nullconsole.log(reg1.exec(str1))// VM3222:1 (2) [\"Skyline\", \"e\", index: 0, input: \"Skyline should be hardworking(Skyline up up up Skyline)\"]console.log(str1.match(reg1))// ['Skyline', 'Skyline', 'Skyline'] exec 常用于迭代匹配字符串中的某个字符。 开启全局，此 exec 返回值同样是一个数组，并且每次迭代在字符串中匹配一次。不过此时，exec 一般会和 该正则的 lastIndex 属性匹配使用，检索位置由 lastIndex 属性指定的字符处开始，未检索到返回为 null ，同时将 lastIndex 重置为 0。注意开启全局迭代使用时与 match 表现完全不一致。 exec 作为一个原始的方法，很多延伸方法内部都在调用 exec，包括 String 对象的部分方法。 RegExp.prototype.test()用于判定是否匹配 String.prototype.match()获取匹配信息（不包括捕获组） String.prototype.search()字符串搜索 String.prototype.replace()字符串替换 正则标志 g全局标志，是否全局匹配，通常配合 exec 和 replace 使用。通过 RegExp.prototype.global 来获取是否设定。 y粘滞标志，仅从正则表达式的 lastIndex 属性表示的索引处搜索。通过 RegExp.prototype.sticky 来获取是否设定。 i忽略大小写标志。通过 RegExp.prototype.ignore 来获取是否设定。 全局标志通常配合 exec 和 replace 使用，前文已述。粘滞标志通常和 test 配合使用，当粘滞设定，test 会从 lastIndex 处检索，每次检索更新 lastIndex 位置。 基本规则正则使用基础使用汇总 简述 正则 描述 定长字符 /^.{1,200}$/ 匹配 m 到 n 长度的字符 匹配定长字符/^.{2, 5}$/匹配指定长度的字符 /^.&#123;2,5&#125;$/.test('aaaaaaa') // false/^.&#123;2,5&#125;$/.test('aa') // true/^.&#123;2,5&#125;$/.test('aaaaa') // true BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES 常用正则.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"数据结构之树","slug":"数据结构之树","date":"2023-02-02T07:19:17.000Z","updated":"2023-03-02T10:12:54.000Z","comments":true,"path":"数据结构之树.html","link":"","permalink":"http://www.skyline.show/数据结构之树.html","excerpt":"二叉树 二叉树遍历 完全二叉树 满二叉树 BMW WARNING 二叉树二叉树遍历 深度优先遍历（DFS），根据父节点被访问的次序，分为： 先序遍历（Preorder） 父节点先于左右子树被遍历。上述二叉树对应结果为 ABDHIEJKCFLG 中序遍历（Inorder） 父节点遍历次序位于左右子树中间。 HDIBJEKALFCG 后序遍历（Postorder） 父节点后于左右子树被遍历 HIDJKEBLFGCA 无论父节点被访问的次序，子树总是先左后右被遍历。 二叉树的深度优先遍历用 Python3 实现如下（对应 leetcode 题目） # Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: # 先序遍历 def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: ret = [] def traversal(root): if not root: return ret.append(root.val) if root.left: traversal(root.left) if root.right: traversal(root.right) traversal(root) return ret # 中序遍历 def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: ret = [] def traversal(root): if not root: return if root.left: traversal(root.left) ret.append(root.val) if root.right: traversal(root.right) traversal(root) return ret # 后序遍历 def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: ret = [] def traversal(root): if not root: return if root.left: traversal(root.left) if root.right: traversal(root.right) ret.append(root.val) traversal(root) return ret 另外还可使用广度优先遍历（BFS），即层次（层序）遍历。从左到右一层一层访问所有节点 ABCDEFGHIJKL 层次遍历用 Python 实现如下（对应 leetcode 题目） # @lc code=start# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: # 递归版本 def levelOrderRecursion(self, root: Optional[TreeNode]) -&gt; List[List[int]]: if not root: return [] ret = [] def traversal(preLevel): level = [] cells = [] for node in preLevel: cells.append(node.val) if node.left: level.append(node.left) if node.right: level.append(node.right) ret.append(cells) if len(level): traversal(level) traversal([root]) return ret # 双层循环版本 def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]: if not root: return [] ret = [] level = [root] while len(level): cells = [] preLevel = level level = [] for node in preLevel: cells.append(node.val) if node.left: level.append(node.left) if node.right: level.append(node.right) ret.append(cells) return ret # 双层循环版本使用队列优化空间 def levelOrderQueue(self, root: Optional[TreeNode]) -&gt; List[List[int]]: if not root: return [] ret = [] level = [root] while len(level): cells = [] for _ in range(len(level)): node = level.pop(0) cells.append(node.val) if node.left: level.append(node.left) if node.right: level.append(node.right) ret.append(cells) return ret 可以看到，对于变长数组的循环，可以采用while方式进行。 完全二叉树","text":"二叉树 二叉树遍历 完全二叉树 满二叉树 BMW WARNING 二叉树二叉树遍历 深度优先遍历（DFS），根据父节点被访问的次序，分为： 先序遍历（Preorder） 父节点先于左右子树被遍历。上述二叉树对应结果为 ABDHIEJKCFLG 中序遍历（Inorder） 父节点遍历次序位于左右子树中间。 HDIBJEKALFCG 后序遍历（Postorder） 父节点后于左右子树被遍历 HIDJKEBLFGCA 无论父节点被访问的次序，子树总是先左后右被遍历。 二叉树的深度优先遍历用 Python3 实现如下（对应 leetcode 题目） # Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: # 先序遍历 def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: ret = [] def traversal(root): if not root: return ret.append(root.val) if root.left: traversal(root.left) if root.right: traversal(root.right) traversal(root) return ret # 中序遍历 def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: ret = [] def traversal(root): if not root: return if root.left: traversal(root.left) ret.append(root.val) if root.right: traversal(root.right) traversal(root) return ret # 后序遍历 def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: ret = [] def traversal(root): if not root: return if root.left: traversal(root.left) if root.right: traversal(root.right) ret.append(root.val) traversal(root) return ret 另外还可使用广度优先遍历（BFS），即层次（层序）遍历。从左到右一层一层访问所有节点 ABCDEFGHIJKL 层次遍历用 Python 实现如下（对应 leetcode 题目） # @lc code=start# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: # 递归版本 def levelOrderRecursion(self, root: Optional[TreeNode]) -&gt; List[List[int]]: if not root: return [] ret = [] def traversal(preLevel): level = [] cells = [] for node in preLevel: cells.append(node.val) if node.left: level.append(node.left) if node.right: level.append(node.right) ret.append(cells) if len(level): traversal(level) traversal([root]) return ret # 双层循环版本 def levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]: if not root: return [] ret = [] level = [root] while len(level): cells = [] preLevel = level level = [] for node in preLevel: cells.append(node.val) if node.left: level.append(node.left) if node.right: level.append(node.right) ret.append(cells) return ret # 双层循环版本使用队列优化空间 def levelOrderQueue(self, root: Optional[TreeNode]) -&gt; List[List[int]]: if not root: return [] ret = [] level = [root] while len(level): cells = [] for _ in range(len(level)): node = level.pop(0) cells.append(node.val) if node.left: level.append(node.left) if node.right: level.append(node.right) ret.append(cells) return ret 可以看到，对于变长数组的循环，可以采用while方式进行。 完全二叉树 二叉树是指最多只存在两个子节点的树形数据结构。完全二叉树是指除了最后一层的叶子节点，每一层节点都存在两个子结点，且最后一层的叶子节点由左起依次排列，排列连续中间不能留空的二叉树。完全二叉树最后一层节点数量不必达到最大数。 数组可以表示一个典型的完全二叉树。i（索引） 为 0 的节点为根节点。所有左子节点的索引为 2i+1，右子节点的索引为 2i+2。同时，可以通过(i-1)/2 获取其父节点的值 满二叉树每一层节点达到最大数，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 满二叉树是一个特殊的完全二叉树。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://leetcode.cn/problems/binary-tree-preorder-traversal/ &gt; https://leetcode.cn/problems/binary-tree-level-order-traversal/ Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/数据结构之树.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.skyline.show/tags/数据结构/"}]},{"title":"ES闭包","slug":"ES闭包","date":"2023-01-25T08:28:26.000Z","updated":"2023-02-09T01:12:14.000Z","comments":true,"path":"ES闭包.html","link":"","permalink":"http://www.skyline.show/ES闭包.html","excerpt":"闭包定义 闭包应用 函数柯里化 偏函数 BMW WARNING 闭包定义 MDN 闭包是指那些能够访问自由变量的函数。 JavaScript 权威指南 从技术的角度讲，所有的 JavaScript 函数都是闭包。在开发实践角度讲，即使创建该函数的上下文已经销毁（父函数执行完毕），该函数仍然存在（比如，内部函数从父函数中返回），该函数中引用了自由变量 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。可以简单理解为函数外部的变量。 如《JavaScript 权威指南》所说，所有的函数都是闭包。因为即便是最外层定义的函数，它们也可以访问全局上下文中的自由变量。 源 定义 《JavaScript 高级程序设计》 闭包是指有权访问另一个’函数’作用域中的变量的函数 《JavaScript 权威指南》 从技术的角度讲，所有的 JavaScript 函数都是闭包 MDN 闭包是指那些能够访问自由变量的函数 闭包可以理解为包含如下要素 函数 自由变量 闭包应用函数柯里化","text":"闭包定义 闭包应用 函数柯里化 偏函数 BMW WARNING 闭包定义 MDN 闭包是指那些能够访问自由变量的函数。 JavaScript 权威指南 从技术的角度讲，所有的 JavaScript 函数都是闭包。在开发实践角度讲，即使创建该函数的上下文已经销毁（父函数执行完毕），该函数仍然存在（比如，内部函数从父函数中返回），该函数中引用了自由变量 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。可以简单理解为函数外部的变量。 如《JavaScript 权威指南》所说，所有的函数都是闭包。因为即便是最外层定义的函数，它们也可以访问全局上下文中的自由变量。 源 定义 《JavaScript 高级程序设计》 闭包是指有权访问另一个’函数’作用域中的变量的函数 《JavaScript 权威指南》 从技术的角度讲，所有的 JavaScript 函数都是闭包 MDN 闭包是指那些能够访问自由变量的函数 闭包可以理解为包含如下要素 函数 自由变量 闭包应用函数柯里化 函数柯里化是将一个多元（多个参数）函数拆分成多个一元函数，通过依次传入参数来执行该函数。 function line(a, b, c, d) &#123; return a + b + c + d&#125; line 函数柯里化后 lineCurry，函数可像如下调用 lineCurry('1', '2', '3', '4')lineCurry('1', '2')('3')('4')lineCurry('1')('2')('3')('4')... curry 封装如下 基础版本 function curry(fn) &#123; let params = [] return function step(...args) &#123; params = params.concat(args) if (params.length &lt; fn.length) &#123; return step &#125; else &#123; const ret = fn(...params) // 重置闭包数据 params = [] return ret &#125; &#125;&#125;var lineCurry = curry(line) 占位符优化版本 function curry(fn) &#123; let params = [] return function step(...args) &#123; params = params .map((v) =&gt; (v == '_' ? args.shift() || '_' : v)) .concat(args) if (params.includes('_') || params.length &lt; fn.length) &#123; return step &#125; else &#123; const ret = fn(...params) // 重置闭包数据 params = [] return ret &#125; &#125;&#125;var lineCurry = curry(line)lineCurry('1', '2', '3', '4')lineCurry('_', '2', '3', '4')('1')lineCurry('1', '_', '3', '4')('2')lineCurry('1', '_', '3')('_', '4')('2')lineCurry('1', '_', '_', '4')('_', '3')('2')lineCurry('_', '2')('_', '_', '4')('1')('3') 上述 lineCurry 都返回’1234’ 考虑到’_‘在代码中出现频率较高，多数资料使用如下方式创建一个占位符对象来防止冲突。本文简化便于理解 var _ = &#123;&#125; 优雅写法版本（引自 segmentfault@大笑平 ） const curry = (fn) =&gt; (judge = (...args) =&gt; args.length === fn.length ? fn(...args) : (arg) =&gt; judge(...args, arg)) 偏函数偏函数指固定函数的部分参数，产生更小元（函数参数更少）的函数，以减少实际函数调用时传参数。 偏函数和柯里化的区别在于：偏函数将多元函数固定部分参数值，减少部分元。柯里化是将多元函数拆分成多个一元函数。 偏函数可以有以下几种方式简单实现 function add(a, b) &#123; return a + b&#125;function add5(y) &#123; return add(5, y)&#125;function add6(y) &#123; return add(6, y)&#125; function add(a) &#123; return function (b) &#123; return a + b &#125;&#125;let add5 = add(5)let add6 = add(6) function add(a, b) &#123; return a + b&#125;let add5 = add.bind(null, 5)let add6 = add.bind(null, 6) 上述方式作临时使用，存在 this 指向变更，传参顺序固定等问题，当需要多次使用偏函数时，可封装成一个函数函数，根据偏函数的功能，实现如下基础版本。 初始版本 function partial(fn, ...args) &#123; return (...params) =&gt; fn(...args, ...params)&#125; 保留 this 指向（注意不要使用箭头函数） function partialWithThis(fn, ...args) &#123; return function (...params) &#123; return fn.call(this, ...args, ...params) &#125;&#125; this 指向验证 var c = 2function add(a, b) &#123; return a + b + this.c&#125;const skyline = &#123; c: 1, add1: partial(add, 1), addOne: partialWithThis(add, 1),&#125;skyline.add1(1) // 4skyline.addOne(1) // 3 添加占位符优化 function partialWithHolder(fn, ...args) &#123; return function (...params) &#123; const _args = args.map((v) =&gt; (v == '_' ? params.shift() : v)) return fn.call(this, ..._args, ...params) &#125;&#125; 占位符验证 // a为被除数。b为除数var dividedBy = function (a, b) &#123; return a / b&#125;dividedBy5 = partialWithHolder(dividedBy, '_', 5)dividedBy5(20) BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 JavaScript 专题之函数柯里化 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES 闭包.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"原理","slug":"原理","permalink":"http://www.skyline.show/tags/原理/"}]},{"title":"工具网站收集","slug":"工具网站收集","date":"2023-01-24T09:57:11.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"工具网站收集.html","link":"","permalink":"http://www.skyline.show/工具网站收集.html","excerpt":"硬件 硬件 描述 地址 CPU CPU 对比 https://gadgetversus.com/processor/intel-celeron-j4125-vs-intel-celeron-g5905/ CPU CPU 天梯图 https://www.cpubenchmark.net/ GPU GPU 对比 https://technical.city/zh/video/Radeon-RX-6600-XT-vs-Radeon-RX-6600 软件网络","text":"硬件 硬件 描述 地址 CPU CPU 对比 https://gadgetversus.com/processor/intel-celeron-j4125-vs-intel-celeron-g5905/ CPU CPU 天梯图 https://www.cpubenchmark.net/ GPU GPU 对比 https://technical.city/zh/video/Radeon-RX-6600-XT-vs-Radeon-RX-6600 软件网络 工具 描述 地址 Brook 开源网络工具，类似于 SS 小飞机 github 搜索 brook Watt Toolkit（steam++） 开源 steam 访问工具，提供 github，v2ex 加速访问 https://steampp.net/ 开发工具 工具 描述 地址 Apifox 接口模拟工具 https://www.bilibili.com/video/BV1BZ4y1B7tD/ Tabby 终端工具，兼容 Mac/Win 多端 https://tabby.sh/ recompressor 图片压缩工具 https://zh.recompressor.com/ 图压 图片压缩工具 https://tuya.xinxiao.tech/ 休闲 工具 描述 地址 千秋书庄 电子书查找网站 https://www.qqszz.com/ 知轩藏书 电子书查找网站 http://zxcs.me/","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://www.skyline.show/tags/Others/"}]},{"title":"Chrome使用小技巧","slug":"Chrome使用小技巧","date":"2023-01-24T09:57:10.000Z","updated":"2023-01-24T09:57:10.000Z","comments":true,"path":"Chrome使用小技巧.html","link":"","permalink":"http://www.skyline.show/Chrome使用小技巧.html","excerpt":"","text":"打开功能选项 设置中开启字幕 Chrome 开启实时字幕打开功能选项chrome 地址栏输入chrome://flags/并搜索 live caption将选项置为 Enabled，重启电脑。 设置中开启字幕在高级设置中开启 live caption。 当用浏览器播放视频时，会自动出现字幕","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"APPs","slug":"APPs","permalink":"http://www.skyline.show/tags/APPs/"},{"name":"Chrome","slug":"Chrome","permalink":"http://www.skyline.show/tags/Chrome/"}]},{"title":"Echarts常见使用","slug":"Echarts常见使用","date":"2023-01-24T09:57:08.000Z","updated":"2023-01-24T09:57:08.000Z","comments":true,"path":"Echarts常见使用.html","link":"","permalink":"http://www.skyline.show/Echarts常见使用.html","excerpt":"Echarts 图表背景图给图表设定背景图，一般有两种方式，第一种设定 option 中的 graphic const option = &#123; graphic: [ &#123; type: 'image', // 图形元素类型 id: 'logo', // 更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 right: 'center', // 根据父元素进行定位 （居中） bottom: '0%', // 根据父元素进行定位 （0%）, 如果bottom的值是 0，也可以删除该bottom属性值。 z: 0, // 层叠 bounding: 'all', // 决定此图形元素在定位时，对自身的包围盒计算方式 style: &#123; // image: \"https://www.boxuegu.com/assets/user/background1.png\", width: 945, height: 800, &#125;, &#125;, ],&#125; 另一种方式为直接给图表容器设定背景图。 Legend 使用Legend 超出滚动","text":"Echarts 图表背景图给图表设定背景图，一般有两种方式，第一种设定 option 中的 graphic const option = &#123; graphic: [ &#123; type: 'image', // 图形元素类型 id: 'logo', // 更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 right: 'center', // 根据父元素进行定位 （居中） bottom: '0%', // 根据父元素进行定位 （0%）, 如果bottom的值是 0，也可以删除该bottom属性值。 z: 0, // 层叠 bounding: 'all', // 决定此图形元素在定位时，对自身的包围盒计算方式 style: &#123; // image: \"https://www.boxuegu.com/assets/user/background1.png\", width: 945, height: 800, &#125;, &#125;, ],&#125; 另一种方式为直接给图表容器设定背景图。 Legend 使用Legend 超出滚动 legend&#123; type: scoll&#125;","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"Packages","slug":"Packages","permalink":"http://www.skyline.show/tags/Packages/"},{"name":"Echarts","slug":"Echarts","permalink":"http://www.skyline.show/tags/Echarts/"}]},{"title":"TS基础知识汇总","slug":"TS基础知识汇总","date":"2023-01-24T09:57:08.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"TS基础知识汇总.html","link":"","permalink":"http://www.skyline.show/TS基础知识汇总.html","excerpt":"TS 简介 简述 优势 劣势 TS 常见类型 class 实例属性可见性 TS 简介简述TS 被看做是 JavaScript 的超集浏览器不能直接编译解析 TS，开发完成的 TS 代码需要先转义成 JS 优势","text":"TS 简介 简述 优势 劣势 TS 常见类型 class 实例属性可见性 TS 简介简述TS 被看做是 JavaScript 的超集浏览器不能直接编译解析 TS，开发完成的 TS 代码需要先转义成 JS 优势 TS 具有如下优势 减少错误 TS 的类型系统能够提前发现部分类型关联的隐藏问题 代码干净整洁，可读性高 TS 代码提高了代码可读性，减少代码注释工作量 双端支持 支持客户端与服务端。 劣势TS 具有如下劣势 需要编译 JS 代码可以直接运行，而 TS 需要编译后方可发布生产运行，这通常被视为一个弊端。但是，在现代 JS 中，工程通常需要 Webpack、Gulp、Vite、Babel 等工具先行编译，不管怎么说，编译工作已必不可少。 TS 常见类型 Boolean type Number type String type Object type Array type Tuple Type Enum Type Any Type Union Type Literal Type Function Type Unknown Type Never Type Custom Type class 实例属性可见性class 实例通过 public、protected、private 来控制属性与方法的可用范围，类本生不可直接访问.若要设置类自身属性，采用 static。public 为默认值，任何位置，类和子类、类的实例都可访问。protected 在类和子类中可用，实例化后不可用。private 在类中可用，实例化和子类不可用。 class Greeter &#123; public greet() &#123; console.log(\"Hello, \" + this.getName() + this.getAge()); &#125; protected getName() &#123; return \"skyline\"; &#125; private getAge() &#123; return \"18\"; &#125;&#125;class GreeterCN extends Greeter &#123; public nihao() &#123; console.log(\"你好, \" + this.getName()); &#125;&#125;const g = new GreeterCN();g.greet(); //\"Hello, skyline18\"g.nihao() // \"你好, skyline\"","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"TS","slug":"TS","permalink":"http://www.skyline.show/tags/TS/"}]},{"title":"前端工程启动常见包错误","slug":"前端工程启动常见包错误","date":"2023-01-24T09:57:08.000Z","updated":"2023-01-25T08:56:46.000Z","comments":true,"path":"前端工程启动常见包错误.html","link":"","permalink":"http://www.skyline.show/前端工程启动常见包错误.html","excerpt":"","text":"node-sass 错误 node-sass 错误项目启动过程报错，this.getOptions is not a functionstyles is not a function等错误。造成错误的原因为node node-sass sass-loader 三者版本不对应。可尝试如下方案进行解决。删除关联包 npm uninstall --save sass-loader node-sass 或直接删除 lock 文件与 node_modules重新安装包。 npm install sass-loader node-sass --save-dev 若使用较老版本 node，可能问题不会解决。检查包对应关系 NodeJS Supported node-sass version Node Module Node 17 7.0+ 102 Node 16 6.0+ 93 Node 15 5.0+, &lt;7.0 88 Node 14 4.14+ 83 Node 13 4.13+, &lt;5.0 79 Node 12 4.12+, &lt;8.0 72 Node 11 4.10+, &lt;5.0 67 Node 10 4.9+, &lt;6.0 64 Node 8 4.5.3+, &lt;5.0 57 Node &lt;8 &lt;5.0 &lt;57 详细对应关系见node-sasssass-loader 与 node-sass 部分对应 sass-loader node-sass 4.1.1 4.3.0 7.0.3 4.7.2 7.3.1 4.14.1 10.0.1 6.0.1 将包对应重新安装。过程中可能出现 npm rebuild node-sass 等错误提示，按照提示操作。上述过程操作后仍旧没解决问题，使用 yarn config set sass-binary-site http://npm.taobao.org/mirrors/node-sass 重新操作上述流程。","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"Packages","slug":"Packages","permalink":"http://www.skyline.show/tags/Packages/"}]},{"title":"递归","slug":"递归","date":"2023-01-24T09:57:06.000Z","updated":"2023-02-02T07:41:07.000Z","comments":true,"path":"递归.html","link":"","permalink":"http://www.skyline.show/递归.html","excerpt":"递归调用 递归弊端 尾调用 尾递归 蹦床优化（Trampoline） BMW WARNING 递归调用递归是一种不使用 for 或者 while 等编程语言预置 API 而实现循环调用的一种编程技巧。通常实现为函数调用自身。 递归问题的特点为后续问题为原始问题的简单子问题，可以统一为一个方程求解。问题需要一个出口。 即其实现的关键是找到 递归方程 递归结束条件 一个简单的正整数求和函数用递归实现如下 const sum = (n) =&gt; &#123; if (n &lt;= 1) return n return sum(n - 1) + n&#125; 斐波那契数列递归实现如下 const fibonacci = (n) =&gt; &#123; if (n &lt;= 2) return 1 return fibonacci(n - 1) + fibonacci(n - 2)&#125; 递归弊端如 JS 等大多数语言，递归嵌套调用时，会保持跟踪函数执行上下文栈，最外层函数最后执行完成后才会销毁。在调用sum(10)通过 Chrome 控制台可以看到执行到 n=5 时调用栈如下这些最底层调用栈最后释放。当递归过深时通常会导致栈溢出。 Uncaught RangeError: Maximum call stack size exceeded 解决方式通常为尾调用优化和蹦床函数。 尾调用","text":"递归调用 递归弊端 尾调用 尾递归 蹦床优化（Trampoline） BMW WARNING 递归调用递归是一种不使用 for 或者 while 等编程语言预置 API 而实现循环调用的一种编程技巧。通常实现为函数调用自身。 递归问题的特点为后续问题为原始问题的简单子问题，可以统一为一个方程求解。问题需要一个出口。 即其实现的关键是找到 递归方程 递归结束条件 一个简单的正整数求和函数用递归实现如下 const sum = (n) =&gt; &#123; if (n &lt;= 1) return n return sum(n - 1) + n&#125; 斐波那契数列递归实现如下 const fibonacci = (n) =&gt; &#123; if (n &lt;= 2) return 1 return fibonacci(n - 1) + fibonacci(n - 2)&#125; 递归弊端如 JS 等大多数语言，递归嵌套调用时，会保持跟踪函数执行上下文栈，最外层函数最后执行完成后才会销毁。在调用sum(10)通过 Chrome 控制台可以看到执行到 n=5 时调用栈如下这些最底层调用栈最后释放。当递归过深时通常会导致栈溢出。 Uncaught RangeError: Maximum call stack size exceeded 解决方式通常为尾调用优化和蹦床函数。 尾调用 尾调用是指函数执行结束那一步调用的是下一个函数。最后一步涉及计算或其他操作都不是尾调用。 function a() &#123; function b() &#123;&#125; return b()&#125; 尾调用所做的优化在于用尾调用函数的执行上下文栈接替父函数执行上下文栈释放空间，这样函数栈不会累积。尾调用需要在 ES6 下的严格模式开启。目前只有 Safari 默认支持尾调用优化，其他浏览器默认不开启或不支持。尾调用会导致调用栈不连续难以跟踪问题出现位置。 尾调用优化的条件就是确定外部栈帧没有必要存在，当外部执行上下文中包含尾调用函数执行所需要的变量时（即形成闭包），尾调用优化无法实现。如下是《JavaScript 高级程序第四版》无法使用尾调用优化示例 function outer() &#123; let a = 1 function inner() &#123; return a &#125; return inner()&#125; 尾递归尾递归是尾调用的一种特例。尾递归是指函数执行结束那一步调用自身，即尾调用函数自身。 正整数求和函数的尾递归实现 const sum = (n, ret = 1) =&gt; &#123; if (n &lt;= 1) return ret return sum(n - 1, ret + n)&#125; 斐波那契数列的尾递归实现 function fibonacci(n, pre = 1, ret = 1) &#123; if (n &lt;= 2) &#123; return ret &#125; return fibonacci(n - 1, ret, ret + pre)&#125; 将递归转化为尾递归的技巧是把累积的值通过参数保存并传递。 尾递归增加了函数参数，通常增加的参数初始值固定。可以通过 ES6 默认参数赋值解决。另外可以使用偏函数和函数柯里化来解决。 偏函数简单实现版本 function fib(pre, ret, n) &#123; if (n &lt;= 2) &#123; return ret &#125; return fib(ret, ret + pre, n - 1)&#125;const fibonacci = fib.bind(null, 1, 1) 使用封装的 partial 偏函数 function partial(fn, ...args) &#123; return (...params) =&gt; fn(...args, ...params)&#125;const fibonacci = partial(fib, 1, 1) 这里的偏函数需要改变原先实现 fibonacci 函数的顺序，可使用”_“版本来保留原先顺序。 蹦床优化（Trampoline）递归蹦床优化的思路是将每次递归的函数放在循环中依次执行。由于循环中需要执行函数，蹦床优化在尾递归(除开该递归边界)上改造。sum 函数的蹦床优化 const sum = (n) =&gt; &#123; const sumStep = (n, ret = 1) =&gt; &#123; if (n &lt;= 1) return ret return () =&gt; sumStep(n - 1, n + ret) &#125; let ret = sumStep(n) while (typeof ret === 'function') &#123; ret = ret() &#125; return ret&#125; 封装蹦床函数 function trampoline(fn) &#123; while (typeof fn === 'function') &#123; fn = fn() &#125; return fn&#125; 封装完成后需要把原递归函数尾调用改为返回不立即执行的匿名函数 const sum = (n, ret = 1) =&gt; &#123; if (n &lt;= 1) return ret return () =&gt; sum(n - 1, n + ret)&#125;function fibonacci(n, pre = 1, ret = 1) &#123; if (n &lt;= 2) &#123; return ret &#125; return () =&gt; fibonacci(n - 1, ret, ret + pre)&#125;trampoline(sum(100))trampoline(fibonacci(10)) BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/递归.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"},{"name":"算法","slug":"算法","permalink":"http://www.skyline.show/tags/算法/"}]},{"title":"Git常见问题","slug":"Git常见问题","date":"2022-11-30T06:00:31.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"Git常见问题.html","link":"","permalink":"http://www.skyline.show/Git常见问题.html","excerpt":"Git status 中文展示在使用git status命令时，若文件名包含中文，可能会出现如下情况上图框中实际为中文。输入如下命令解决 git config --global core.quotepath false 或直接在 $HOME/.gitconfig文件中附加 [core] quotepath = false 文件名过长错误文件名过长，报错如下： Filename too long warning: Clone succeeded, but checkout failed. 输入如下命令解决 git config --system core.longpaths true 多个 git 进程","text":"Git status 中文展示在使用git status命令时，若文件名包含中文，可能会出现如下情况上图框中实际为中文。输入如下命令解决 git config --global core.quotepath false 或直接在 $HOME/.gitconfig文件中附加 [core] quotepath = false 文件名过长错误文件名过长，报错如下： Filename too long warning: Clone succeeded, but checkout failed. 输入如下命令解决 git config --system core.longpaths true 多个 git 进程 出现多个 git 进程提示，git 提交代码等操作不可用 Another git process seems to be running in this repository 输入如下命令解决 rm -f .git/index.lock .gitignore 无效已有仓库添加.gitignore 无效，或在.gitignore 中添加新的忽略无效，这是由于 git 缓存机制导致，需要移除的文件已经添加到工作区。需要先移除后重新添加文件。 git rm -r --cached .git add .git commit -m \".gitignore is now working\" BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Git常见问题.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"Git","slug":"Git","permalink":"http://www.skyline.show/tags/Git/"}]},{"title":"Git常见符号","slug":"Git常见符号","date":"2022-11-30T06:00:31.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"Git常见符号.html","link":"","permalink":"http://www.skyline.show/Git常见符号.html","excerpt":".. 表示对比 表示连续 ^ BMW WARNING ..表示对比git log test..mastertest 是由 master 建立的分支，在 test 进行开发多次提交完成对应功能后，切回 master 分支；在合并 test 分支的时候，如果 master 分支在建立 test 分支之后有新的提交，则尝尝需要 rebase 进行变基让提交历史更加美观，通过如上命令来查看 master 独有的提交（相较于 test）如果没有直接显示’(END)’若果有则有提交相关信息。如下图所示： 表示连续","text":".. 表示对比 表示连续 ^ BMW WARNING ..表示对比git log test..mastertest 是由 master 建立的分支，在 test 进行开发多次提交完成对应功能后，切回 master 分支；在合并 test 分支的时候，如果 master 分支在建立 test 分支之后有新的提交，则尝尝需要 rebase 进行变基让提交历史更加美观，通过如上命令来查看 master 独有的提交（相较于 test）如果没有直接显示’(END)’若果有则有提交相关信息。如下图所示： 表示连续 git cherry-pick A..B表示摘取提交 A 到 B 的一系列提交（不包括 A）要包括 A，使用如下命令git cherry-pick ^A..B ^表示包含开头。 git cherry-pick A..B表示摘取提交 A 到 B 的一系列提交（不包括 A）要包括 A，使用如下命令git cherry-pick ^A..B BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Git常见符号.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"Git","slug":"Git","permalink":"http://www.skyline.show/tags/Git/"}]},{"title":"Vue2项目引入TS","slug":"Vue2项目引入TS","date":"2022-11-29T09:57:11.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Vue2项目引入TS.html","link":"","permalink":"http://www.skyline.show/Vue2项目引入TS.html","excerpt":"vue-cli3 项目 依赖引入 安装相关依赖 tsconfig babel.config vue.config vue2tsx BMW WARNING vue-cli3 项目在使用 vue-cli3 及以上创建的项目根目录下，可执行命令 vue add typescript 依赖引入安装相关依赖","text":"vue-cli3 项目 依赖引入 安装相关依赖 tsconfig babel.config vue.config vue2tsx BMW WARNING vue-cli3 项目在使用 vue-cli3 及以上创建的项目根目录下，可执行命令 vue add typescript 依赖引入安装相关依赖 若直接 vue-cli3 添加支持不可行或 cli 低于该版本，可尝试自行添加相关依赖包来解决。 yarn add -D @vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props @babel/plugin-transform-typescript 注意部分包之前可能存在不兼容问题部分兼容相关包版本如下 \"@babel/plugin-transform-typescript\": \"^7.19.3\",\"@vue/babel-helper-vue-jsx-merge-props\": \"^1.4.0\",\"@vue/babel-preset-jsx\": \"^1.4.0\", 若要引入 eslint 和 prettier 校验和格式化代码，引入或者修改包版本如下可解决兼容问题 \"@vue/cli-plugin-babel\": \"4.4.6\",\"@vue/cli-plugin-eslint\": \"4.4.6\",\"@vue/eslint-config-prettier\": \"7.0.0\",\"eslint\": \"7.15.0\",\"eslint-config-prettier\": \"^8.5.0\",\"eslint-plugin-prettier\": \"3.4.1\",\"eslint-plugin-vue\": \"7.2.0\",\"prettier\": \"2.5.1\", tsconfig新建 tsconfig.json，内容如下 &#123; \"compilerOptions\": &#123; \"target\": \"ES2017\", \"module\": \"UMD\", \"allowJs\": true, \"jsx\": \"preserve\", \"moduleResolution\": \"Node\", \"allowSyntheticDefaultImports\": true, \"importHelpers\": true, \"baseUrl\": \"./\", \"paths\": &#123; \"@/*\": [ \"src/*\" ] &#125; &#125;&#125; 也可自行配置。若引入 prettier 和 eslint则新建.prettierrc.json &#123; \"arrowParens\": \"always\", \"bracketSpacing\": true, \"endOfLine\": \"lf\", \"htmlWhitespaceSensitivity\": \"css\", \"insertPragma\": false, \"singleAttributePerLine\": false, \"bracketSameLine\": false, \"jsxBracketSameLine\": false, \"jsxSingleQuote\": true, \"printWidth\": 80, \"proseWrap\": \"preserve\", \"quoteProps\": \"as-needed\", \"requirePragma\": false, \"semi\": false, \"singleQuote\": true, \"tabWidth\": 2, \"trailingComma\": \"es5\", \"useTabs\": false, \"vueIndentScriptAndStyle\": false&#125; .eslint.js module.exports = &#123; root: false, env: &#123; node: true, // 'vue/setup-compiler-macros': true &#125;, extends: [ 'plugin:vue/recommended', '@vue/standard', 'plugin:prettier/recommended', ], rules: &#123; 'no-debugger': 'off', indent: ['off', 2], 'no-multi-assign': 'error', 'arrow-spacing': [ 2, &#123; before: true, after: true, &#125;, ], 'vue/max-attributes-per-line': [ 'off', &#123; singleline: 3, multiline: 1, &#125;, ], 'vue/multiline-html-element-content-newline': [ 'warn', &#123; ignoreWhenEmpty: true, ignores: [], allowEmptyLines: true, &#125;, ], camelcase: 'off', 'vue/multi-word-component-names': 'off', 'vue/mustache-interpolation-spacing': 'off', &#125;, parserOptions: &#123; parser: 'babel-eslint', &#125;,&#125; babel.config调整或新加 babel 选项babel.config.js module.exports = &#123; presets: [ '@vue/cli-plugin-babel/preset', ['@vue/babel-preset-jsx', &#123; compositionAPI: true &#125;], // 开启 jsx ], plugins: [ ['@babel/plugin-transform-typescript', &#123; isTSX: true &#125;], // 开启 typescript ],&#125; vue.config调整或新加 vue 选项vue.config.js configureWebpack: &#123; resolve: &#123; alias: &#123; '@': path.resolve(__dirname, './src'), &#125;, extensions: ['.ts', '.tsx'], &#125;, module: &#123; rules: [ &#123; test: /\\.(js|tsx|ts|jsx)$/, exclude: /node_modules|vue-router\\/|vue-loader\\//, use: 'babel-loader', &#125;, ], &#125;, externals: &#123;&#125;,&#125;, vue2tsx.vue &lt;template&gt; &lt;router-view id=\"app\" /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style lang=\"scss\"&gt;&lt;/style&gt; .tsx import &#123; defineComponent, onMounted &#125; from 'vue'export default defineComponent(&#123; setup() &#123; onMounted(() =&gt; &#123;&#125;) &#125;, render() &#123; return &lt;router-view id='app' /&gt; &#125;,&#125;) BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Vue2.x 开启 Composition API、tsx Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Vue2 项目引入 TS.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/tags/Vue/"}]},{"title":"ESLint与Prettier使用","slug":"ESLint与Prettier使用","date":"2022-11-06T09:21:04.000Z","updated":"2023-01-24T09:57:08.000Z","comments":true,"path":"ESLint与Prettier使用.html","link":"","permalink":"http://www.skyline.show/ESLint与Prettier使用.html","excerpt":"Linter 与 Prettier ESLint 与 Prettier 共用 共用冲突 常见问题 eslint 校验禁用 格式化禁用 常见报错 换行报错 插件版本兼容报错 BMW WARNING Linter 与 Prettier常用的 Linter 有 ESLint/TSLint/stylelint 等。 Linter 大致分为两类校验规则： 代码格式 代码语法 代码格式规定了缩进、空格、换行等代码语法重点关注未使用变量(no-unused-vars)、隐式全局变量(no-implicit-globals)等问题 Prettier 无关代码语法，她可补充 Linter 规定代码格式。 总之，一个常见的方案为，使用 Linter 来捕获语法问题和 Bug，Prettier 来格式化代码。 ESLint 与 Prettier 共用ESLint、Prettier 都分别有 NPM 包和 VSCode 插件。ESLint 的 VSCode 插件可以在让我们在写代码过程中实时发现波浪标红的错误，提升工作效率。当然，插件其实不是必须的，我们可以通过 eslint --fix npx prettier --write 修复部分相关问题。但是部分无法自动修复的问题需要我们提交代码时一一排查。ESLint、Prettier 在 VSCode 中对应的插件用以提高我们编码效率，在插件商店搜索安装即可。在项目中将具体的配置分别放在项目根目录下.eslintrc.js 与 prettierrc.json 中。一个简单的 ESLint 配置如下 module.exports = &#123; root: false, env: &#123; node: true, // 'vue/setup-compiler-macros': true &#125;, extends: ['plugin:vue/recommended', '@vue/standard'], rules: &#123; 'no-debugger': 'off', indent: ['off', 2], &#125;, parserOptions: &#123; parser: 'babel-eslint', &#125;,&#125; rules 的规则如下 “off” 或 0 - 关闭规则 “warn” 或 1 - 开启规则，错误警告而不退出 “error” 或 2 - 开启规则，错误退出 一个简单的 prettier 配置如下 &#123; \"printWidth\": 100, // 超过最大值换行 \"tabWidth\": 4, // 缩进字节数 \"useTabs\": false, // 缩进不使用tab，使用空格 \"semi\": true, // 句尾添加分号 \"singleQuote\": true, // 使用单引号代替双引号 \"proseWrap\": \"preserve\", // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 \"arrowParens\": \"avoid\", // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"bracketSpacing\": true, // 在对象，数组括号与文字之间加空格 \"&#123; foo: bar &#125;\" \"disableLanguages\": [\"vue\"], // 不格式化vue文件，vue文件的格式化单独设置 \"endOfLine\": \"auto\", // 结尾是 \\n \\r \\n\\r auto \"eslintIntegration\": false, //不让prettier使用eslint的代码格式进行校验 \"htmlWhitespaceSensitivity\": \"ignore\", \"ignorePath\": \".prettierignore\", // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 \"jsxBracketSameLine\": false, // 在jsx中把'&gt;' 是否单独放一行 \"jsxSingleQuote\": false, // 在jsx中使用单引号代替双引号 \"parser\": \"babylon\", // 格式化的解析器，默认是babylon \"requireConfig\": false, // Require a 'prettierconfig' to format prettier \"stylelintIntegration\": false, //不让prettier使用stylelint的代码格式进行校验 \"trailingComma\": \"es5\", // 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号） \"tslintIntegration\": false // 不让prettier使用tslint的代码格式进行校验&#125; prettier 具体配置项常见官网 让插件格式化的生效策略同样是就近原则，寻找被格式化文件系统目录层级中最近的配置文件，越近优先级越高。要在保存代码时自动触发 ESLint 修复与 Prettier 格式化，需要在 VSCode 配置文件 setting.json 中添加如下代码ESLint \"editor.codeActionsOnSave\": &#123; \"source.fixAll.eslint\": true &#125;,\"eslint.validate\": [\"javascript\", \"javascriptreact\", \"typescript\", \"html\", \"vue\"], Prettier \"editor.formatOnSave\": true,\"[typescriptreact]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;,\"[typescript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;,\"[less]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;, \"[javascript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;, 同时也可在项目根目录下创建.vscode 文件夹创建 setting.json 文件并提交仓库，将对应配置共享给项目开发成员。 共用冲突","text":"Linter 与 Prettier ESLint 与 Prettier 共用 共用冲突 常见问题 eslint 校验禁用 格式化禁用 常见报错 换行报错 插件版本兼容报错 BMW WARNING Linter 与 Prettier常用的 Linter 有 ESLint/TSLint/stylelint 等。 Linter 大致分为两类校验规则： 代码格式 代码语法 代码格式规定了缩进、空格、换行等代码语法重点关注未使用变量(no-unused-vars)、隐式全局变量(no-implicit-globals)等问题 Prettier 无关代码语法，她可补充 Linter 规定代码格式。 总之，一个常见的方案为，使用 Linter 来捕获语法问题和 Bug，Prettier 来格式化代码。 ESLint 与 Prettier 共用ESLint、Prettier 都分别有 NPM 包和 VSCode 插件。ESLint 的 VSCode 插件可以在让我们在写代码过程中实时发现波浪标红的错误，提升工作效率。当然，插件其实不是必须的，我们可以通过 eslint --fix npx prettier --write 修复部分相关问题。但是部分无法自动修复的问题需要我们提交代码时一一排查。ESLint、Prettier 在 VSCode 中对应的插件用以提高我们编码效率，在插件商店搜索安装即可。在项目中将具体的配置分别放在项目根目录下.eslintrc.js 与 prettierrc.json 中。一个简单的 ESLint 配置如下 module.exports = &#123; root: false, env: &#123; node: true, // 'vue/setup-compiler-macros': true &#125;, extends: ['plugin:vue/recommended', '@vue/standard'], rules: &#123; 'no-debugger': 'off', indent: ['off', 2], &#125;, parserOptions: &#123; parser: 'babel-eslint', &#125;,&#125; rules 的规则如下 “off” 或 0 - 关闭规则 “warn” 或 1 - 开启规则，错误警告而不退出 “error” 或 2 - 开启规则，错误退出 一个简单的 prettier 配置如下 &#123; \"printWidth\": 100, // 超过最大值换行 \"tabWidth\": 4, // 缩进字节数 \"useTabs\": false, // 缩进不使用tab，使用空格 \"semi\": true, // 句尾添加分号 \"singleQuote\": true, // 使用单引号代替双引号 \"proseWrap\": \"preserve\", // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 \"arrowParens\": \"avoid\", // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"bracketSpacing\": true, // 在对象，数组括号与文字之间加空格 \"&#123; foo: bar &#125;\" \"disableLanguages\": [\"vue\"], // 不格式化vue文件，vue文件的格式化单独设置 \"endOfLine\": \"auto\", // 结尾是 \\n \\r \\n\\r auto \"eslintIntegration\": false, //不让prettier使用eslint的代码格式进行校验 \"htmlWhitespaceSensitivity\": \"ignore\", \"ignorePath\": \".prettierignore\", // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 \"jsxBracketSameLine\": false, // 在jsx中把'&gt;' 是否单独放一行 \"jsxSingleQuote\": false, // 在jsx中使用单引号代替双引号 \"parser\": \"babylon\", // 格式化的解析器，默认是babylon \"requireConfig\": false, // Require a 'prettierconfig' to format prettier \"stylelintIntegration\": false, //不让prettier使用stylelint的代码格式进行校验 \"trailingComma\": \"es5\", // 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号） \"tslintIntegration\": false // 不让prettier使用tslint的代码格式进行校验&#125; prettier 具体配置项常见官网 让插件格式化的生效策略同样是就近原则，寻找被格式化文件系统目录层级中最近的配置文件，越近优先级越高。要在保存代码时自动触发 ESLint 修复与 Prettier 格式化，需要在 VSCode 配置文件 setting.json 中添加如下代码ESLint \"editor.codeActionsOnSave\": &#123; \"source.fixAll.eslint\": true &#125;,\"eslint.validate\": [\"javascript\", \"javascriptreact\", \"typescript\", \"html\", \"vue\"], Prettier \"editor.formatOnSave\": true,\"[typescriptreact]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;,\"[typescript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;,\"[less]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;, \"[javascript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"&#125;, 同时也可在项目根目录下创建.vscode 文件夹创建 setting.json 文件并提交仓库，将对应配置共享给项目开发成员。 共用冲突 当使用两者在项目中时，一个比较常见的情况是，格式化代码使用 Prettier 规则，在提交或保存代码时触发eslint --fix将代码格式成另一种风格。解决方案有两种，一是将配置文件靠齐，即修改 eslintrc 或 prettierrc 对应配置是的二者一致。当配置差异较大时，修改工作量较大。另一种方案为使用已有插件：eslint-config-prettier 与 eslint-plugin-prettier其本质原理也是统一两者规则。eslint-config-prettier 用于禁用和 prettier 有冲突的 ESLint 规则eslint-plugin-prettier 用于将 prettier 的规则让 ESLint 识别并在 ESLint 插件中输出（如实时错误警告等）。加入上述插件后，修改配置文件，在 extends 后添加’plugin:prettier/recommended’ extends: [ 'plugin:vue/recommended', '@vue/standard', 'plugin:prettier/recommended',], 配合上述两个插件使用使得的eslint --fix格式化代码时采用 prettier 的规则，从而解决上述格式化冲突问题。 常见问题eslint 校验禁用在项目根目录创建.eslintignore 文件，写入忽略的文件文件夹等。其文件内容格式遵循.gitignore 对应规则通过！可恢复被忽略的文件例如 src/* // 排除src目录下面所有的!src/views/ // src/views下面所有的目录重新被包含回来 格式化禁用当在移动端开发时，通常需要将 px 转换成 rem，部分场景需要使用大写 PX 来防止被转换，但是 prettier 会自动格式化为小写，这时候需要 /* prettier-ignore */border: 1PX; 来禁用格式化新建 .prettierignore 文件来忽略（即不重新格式化）某些文件和文件夹。使用 “prettier-ignore “注释来忽略文件的一部分。具体参见官方忽略说明 常见报错换行报错Delete `␍`eslint(prettier/prettier) 换行报错的产生是由于操作系统换行符不一致导致。Windows| Linux/Mac| Early Mac–|–|–CRLF| LF| CR‘\\n\\r’| ‘\\n’| ‘\\r’ 尝试在 prettier 配置文件添加 \"endOfLine\": \"auto\" 或在 ESLint 配置文件中添加 rules: &#123; 'prettier/prettier': [ 'error', &#123; endOfLine: 'auto', &#125;, ],&#125; 然后，将 git 自动转换换行符关闭 git config --global core.autocrlf false 插件版本兼容报错由于关联的插件较多，容易遇到插件版本不兼容引起的错误如下 'prettier/prettier': context.getPhysicalFilename is not a function 可能为 eslint 版本问题，升级其版本 yarn upgrade -R eslint 若仍旧不行，尝试更换如下插件为兼容版本 先清除原有版本 npm rm @vue/cli-plugin-babel @vue/cli-plugin-eslint @vue/eslint-config-prettier eslint eslint-plugin-prettier eslint-plugin-vue prettier 如下示例版本可兼容 npm i -D @vue/cli-plugin-babel@4.4.6 @vue/cli-plugin-eslint@4.4.6 @vue/eslint-config-prettier@7.0.0 eslint@7.15.0 eslint-plugin-prettier@3.4.1 eslint-plugin-vue@7.2.0 prettier@2.5.1 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ESLint 与 Prettier 使用.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"Packages","slug":"Packages","permalink":"http://www.skyline.show/tags/Packages/"}]},{"title":"Latex语法","slug":"Latex语法","date":"2022-10-14T08:47:06.000Z","updated":"2023-02-09T01:12:13.000Z","comments":true,"path":"Latex语法.html","link":"","permalink":"http://www.skyline.show/Latex语法.html","excerpt":"Latex 简介 基础 符号 关系符 表达式 其他符号 无符号标记 BMW WARNING Latex 简介Latex 用于编辑数学公式，目前较为友好支持 Latex 语法的笔记相关软件有 quiver(Mac) 幕布 基础Latex 语法可在 markdown 文件中进行书写，其标记为$在行内展示对应公式，标记为 $ $ 例如 $ \\frac&#123;a+1&#125;&#123;b+1&#125; \\quad $ 展示为$ \\frac{a+1}{b+1} \\quad $ 换行展示对应公式，标记为 $$ $$ 例如 $$ \\frac&#123;a+1&#125;&#123;b+1&#125; \\quad $$ 展示为 $$ \\frac{a+1}{b+1} \\quad $$ 符号","text":"Latex 简介 基础 符号 关系符 表达式 其他符号 无符号标记 BMW WARNING Latex 简介Latex 用于编辑数学公式，目前较为友好支持 Latex 语法的笔记相关软件有 quiver(Mac) 幕布 基础Latex 语法可在 markdown 文件中进行书写，其标记为$在行内展示对应公式，标记为 $ $ 例如 $ \\frac&#123;a+1&#125;&#123;b+1&#125; \\quad $ 展示为$ \\frac{a+1}{b+1} \\quad $ 换行展示对应公式，标记为 $$ $$ 例如 $$ \\frac&#123;a+1&#125;&#123;b+1&#125; \\quad $$ 展示为 $$ \\frac{a+1}{b+1} \\quad $$ 符号 关系符 符号 写法 示例 $\\pm$ \\pm $\\mp$ \\mp $\\times$ \\times $\\div$ \\div $\\leq$ \\leq $\\neq$ \\neq $\\geq$ \\geq $\\approx$ \\approx $\\sum$ \\sum $\\sum\\limits_{i=1}$ $\\cdot$ \\cdot ${a}\\cdot{b}$ $\\lvert \\rvert$ \\lvert \\rvert $\\lvert a + b \\rvert ^2$ $\\in$ \\in $\\notin$ \\notin $\\vee$ \\vee $\\land$ \\land 表达式 符号 写法 示例 $x^{n}$ x^{n} $x_{n}$ x_{n} $\\sqrt[m]{n}$ \\sqrt{n} $\\sqrt[5]{x^2+(y + 1)^2}$ $\\frac{a}{b}$ \\frac $\\=a$ \\= $\\overline a$ \\= $.a$ \\. $\\dot a$ \\dot $\\”a$ \\&quot; 其他符号 符号 写法 示例 $\\triangle$ \\triangle $\\square$ \\square $\\rightarrow$ \\rightarrow $\\leftarrow$ \\leftarrow $\\Rightarrow$ \\Rightarrow $\\Leftarrow$ \\Leftarrow $\\leftrightarrow$ \\leftrightarrow $\\Leftrightarrow$ \\Leftrightarrow 无符号标记 含义 写法 示例 说明 下标位置迁移标记 \\limits $\\sum\\limits_{i=1}\\limits^{i=1}$ \\limits 控制右侧下标到上下两侧 底部位置标记 \\underset $\\underset{i=1}\\sum$ 顶部位置标记 \\overset $\\overset{i=1}\\sum$ BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Latex语法.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://www.skyline.show/tags/Others/"}]},{"title":"力扣题解494-目标和","slug":"力扣题解494-目标和","date":"2022-09-15T07:49:38.000Z","updated":"2023-01-24T09:57:06.000Z","comments":true,"path":"力扣题解494-目标和.html","link":"","permalink":"http://www.skyline.show/力扣题解494-目标和.html","excerpt":"题目 普通 DP 基础分析 其他说明 解法 背包问题 BMW WARNING 题目494.目标和本题可采用 DFS 和 DP 动态规划解法。此分析 DP 普通 DP基础分析","text":"题目 普通 DP 基础分析 其他说明 解法 背包问题 BMW WARNING 题目494.目标和本题可采用 DFS 和 DP 动态规划解法。此分析 DP 普通 DP基础分析 dp 含义 dp[i][t]表示数组索引 i 及之前的数用完得到某个目标值 t 的个数 状态转移方程 dp[i][t] = dp[i - 1][t - nums[i]] + dp[i - 1][t + nums[i]] 边界条件 nums 第一个数为 0 dp[0][0] = 2 nums 第一个数非零 x dp[0][x] = dp[0][-x] = 1 其他说明 数组代替哈希 可以用哈希来存储上轮循环中得到每个 taget 对应的数量，也可用数组代替。用数组代替时，sumRet 为源数组 nums 的数值总和，索引 0 处对应的 target 值为-sumRet 的数量，索引 sumRet 处对应的 target 值为 0 的数量。即存在一个偏移量为 sumRet 滚动数组 由状态转移方程可知，数组数值计算可能得到的值位于-sumRet 与 sumRet 之间，故初始化的滚动数组长度为 sumRet * 2 + 1 不可到达状态 一个容易想到的状态是：当 abs(target) &gt; sumRet 时，结论为 0另外可以排除的状态：设当 nums 中的值取得 target 时，所有取负值的数绝对值之和为 m则 所有取正值得数之和为 sumRet - m有 sumRet - m - m = target即得 m = (sumRet - target) / 2 由于 m 为整数，故 sumRet - target 为偶数先行排除不可达状态可优化性能。 解法class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&gt; int: sumRet = sum(nums) if abs(target) &gt; sumRet or (sumRet - target) % 2 != 0: return 0 # 由状态转移方程可知，数组数值计算可能得到的值位于-sumRet与sumRet之间 notes = [0] * (sumRet * 2 + 1) # 初始化非零，注意基础偏移量为sumRet notes[sumRet + nums[0]] = notes[sumRet - nums[0]] = 1 # 初始化零 if nums[0] == 0: # 注意sumRet位置偏移 notes[sumRet] = 2 for i in range(1, len(nums)): preNotes = notes notes = [0] * (sumRet * 2 + 1) num = nums[i] # 注意遍历结束位置不包含，需要多-1 for t in range(sumRet, -sumRet-1, -1): # 位置偏移 pos = t + sumRet # 超出左边界 if pos - num &lt; 0: notes[pos] = preNotes[pos + num] continue # 超出右边界 if pos + num &gt; sumRet * 2: notes[pos] = preNotes[pos - num] continue # 普通情况 notes[pos] = preNotes[pos - num] + preNotes[pos + num] return notes[target + sumRet] 背包问题本地有一个更好的动态规划思路，就是转化为背包问题。上节提到，负数的绝对值和为 sumNegative = (sumRet - target) / 2 同理有取正数之和为 sumPositive = (sumRet + target) / 2 则问题转换为在数组 nums 中，将正数的获取，负数不取，取得值总数为 sumPositive 的解法数。这是一个标准的背包问题。 dp 含义 dp[i][s]表示取数组索引 i 及之前的某些数得到某个目标值 s 的方案数 状态转移方程 当进行到索引 i 时，此轮得到目标值 s 的方案数取决于 nums[i]取舍。若不取，dp[i][s] = dp[i - 1][s]若取，dp[i][s] = dp[i - 1]s - nums[i]]即有状态转移方程 dp[i][s] = dp[i - 1][s - nums[i]] + dp[i - 1][s] 上述状态转移方程可以看出，外层循环遍历数组时，dp[i]只与 dp[i - 1]有关，故可使用滚动数组记录来代替二维数组节省空间。同时，在内层循环中，新一轮的值只与滚动数组索引 s 之前的值有关，若采用正向遍历，会覆盖需要读取的值，故采取反向遍历。 边界条件 将外层循环第一轮作为边界条件单独处理。dp[0][0]取值情况为：nums 第一个数为 0，取得 0 的方案为取或不取皆可 dp[0][0] = 2 nums 第一个数非零 x dp[0][0] = 1 dp[0][x]取值情况为：x &lt; sumPositive 时 dp[0][x] = 1 x &gt; sumPositive 时 dp[0][x] = 0 故解法为 class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&gt; int: sumRet = sum(nums) lenNums = len(nums) sumPositive = (sumRet + target) // 2 if abs(target) &gt; sumRet or (sumRet + target) % 2 != 0: return 0 notes = [0] * (sumPositive + 1) if nums[0] &lt;= sumPositive: notes[nums[0]] = 1 notes[0] = 2 if nums[0] == 0 else 1 for i in range(1, lenNums): for s in range(sumPositive, nums[i]-1, -1): notes[s] = notes[s] + notes[s - nums[i]] return notes[-1] BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 63.不同路径-ii Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/力扣题解 63-不同路径-ii.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"},{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://www.skyline.show/tags/Leetcode题解/"}]},{"title":"力扣题解63-不同路径-ii","slug":"力扣题解63-不同路径-ii","date":"2022-07-07T10:24:30.000Z","updated":"2023-01-24T09:57:06.000Z","comments":true,"path":"力扣题解63-不同路径-ii.html","link":"","permalink":"http://www.skyline.show/力扣题解63-不同路径-ii.html","excerpt":"题目63.不同路径-ii本题采用动态规划解法。 分析此题在未进行空间优化使用二维数组的方案时，可以很好地解决边界问题。若需要优化空间，处理边界问题为要务。此处把输入的数组的行用 r(row)表示，列用 c(column)表示dp[r][c]表示到达对应位置拥有的方法数，此时在网格位置用 pos 标记则有如下情况： pos 处有障碍物 dp[r][c] = 0 pos 处在上边界（r == 0） # dp[r][c] 在上边界第一个障碍物处分界，障碍物左边为 1，右边为 0，单独进行边界处理dp[r][c] = 0 || 1 pos 处在左边界（c == 0） dp[r][c] = dp[r - 1][c] 其他普通情况 1: pos只左边有障碍物 dp[r][c] = dp[r][c - 1]2: pos只上边有障碍物 dp[r][c] = dp[r - 1][c]3: pos左边上边都有障碍物 dp[r][c] = 04: pos都无障碍物 dp[r][c] = dp[r][c - 1] + dp[r - 1][c] 上述分析可以得到一个初步的代码版本 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: columnLen = len(obstacleGrid[0]) rowLen = len(obstacleGrid) note = [0] * columnLen # 处理初始上边界并用记事本note保存 for i,v in enumerate(obstacleGrid[0]): if v == 1: break note[i] = 1 if rowLen == 1: return note[-1] ret = 0 for r in range(1, rowLen): for c in range(columnLen): # 当前位置为障碍物 if obstacleGrid[r][c] == 1: ret = 0 note[c] = 0 continue # 当前位置位于左边界 if c == 0: ret = note[c] continue # 普通情况 if obstacleGrid[r - 1][c] == 1: if obstacleGrid[r][c - 1] == 1: ret = 0 note[c] = 0 else: note[c] = ret else: if obstacleGrid[r][c - 1] == 1: ret = note[c] else: ret = ret + note[c] note[c] = ret return ret 普通情况可进行合并 普通情况合并1: pos只左边有障碍物 dp[r - 1][c] = 0， dp[r][c] = dp[r][c - 1] + dp[r - 1][c]2: pos只上边有障碍物 dp[r][c - 1] = 0， dp[r][c] = dp[r][c - 1] + dp[r - 1][c]3: pos左边上边都有障碍物 dp[r - 1][c] = 0， dp[r][c - 1] = 0， dp[r][c] = dp[r][c - 1] + dp[r - 1][c]4: pos都无障碍物 dp[r][c] = dp[r][c - 1] + dp[r - 1][c] 即普通情况下 dp[r][c] = dp[r][c - 1] + dp[r - 1][c] 则解法如下 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: columnLen = len(obstacleGrid[0]) rowLen = len(obstacleGrid) note = [0] * columnLen ret = 0 # 处理初始上边界并用记事本note保存(滚动数组) for i,v in enumerate(obstacleGrid[0]): if v == 1: break note[i] = 1 if rowLen == 1: return note[-1] for r in range(1, rowLen): for c in range(columnLen): # 当前位置为障碍物 if obstacleGrid[r][c] == 1: ret = 0 note[c] = 0 continue # 当前位置位于左边界 if c == 0: ret = note[c] continue # 普通情况 ret = ret + note[c] note[c] = ret return ret BMW WARNING","text":"题目63.不同路径-ii本题采用动态规划解法。 分析此题在未进行空间优化使用二维数组的方案时，可以很好地解决边界问题。若需要优化空间，处理边界问题为要务。此处把输入的数组的行用 r(row)表示，列用 c(column)表示dp[r][c]表示到达对应位置拥有的方法数，此时在网格位置用 pos 标记则有如下情况： pos 处有障碍物 dp[r][c] = 0 pos 处在上边界（r == 0） # dp[r][c] 在上边界第一个障碍物处分界，障碍物左边为 1，右边为 0，单独进行边界处理dp[r][c] = 0 || 1 pos 处在左边界（c == 0） dp[r][c] = dp[r - 1][c] 其他普通情况 1: pos只左边有障碍物 dp[r][c] = dp[r][c - 1]2: pos只上边有障碍物 dp[r][c] = dp[r - 1][c]3: pos左边上边都有障碍物 dp[r][c] = 04: pos都无障碍物 dp[r][c] = dp[r][c - 1] + dp[r - 1][c] 上述分析可以得到一个初步的代码版本 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: columnLen = len(obstacleGrid[0]) rowLen = len(obstacleGrid) note = [0] * columnLen # 处理初始上边界并用记事本note保存 for i,v in enumerate(obstacleGrid[0]): if v == 1: break note[i] = 1 if rowLen == 1: return note[-1] ret = 0 for r in range(1, rowLen): for c in range(columnLen): # 当前位置为障碍物 if obstacleGrid[r][c] == 1: ret = 0 note[c] = 0 continue # 当前位置位于左边界 if c == 0: ret = note[c] continue # 普通情况 if obstacleGrid[r - 1][c] == 1: if obstacleGrid[r][c - 1] == 1: ret = 0 note[c] = 0 else: note[c] = ret else: if obstacleGrid[r][c - 1] == 1: ret = note[c] else: ret = ret + note[c] note[c] = ret return ret 普通情况可进行合并 普通情况合并1: pos只左边有障碍物 dp[r - 1][c] = 0， dp[r][c] = dp[r][c - 1] + dp[r - 1][c]2: pos只上边有障碍物 dp[r][c - 1] = 0， dp[r][c] = dp[r][c - 1] + dp[r - 1][c]3: pos左边上边都有障碍物 dp[r - 1][c] = 0， dp[r][c - 1] = 0， dp[r][c] = dp[r][c - 1] + dp[r - 1][c]4: pos都无障碍物 dp[r][c] = dp[r][c - 1] + dp[r - 1][c] 即普通情况下 dp[r][c] = dp[r][c - 1] + dp[r - 1][c] 则解法如下 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: columnLen = len(obstacleGrid[0]) rowLen = len(obstacleGrid) note = [0] * columnLen ret = 0 # 处理初始上边界并用记事本note保存(滚动数组) for i,v in enumerate(obstacleGrid[0]): if v == 1: break note[i] = 1 if rowLen == 1: return note[-1] for r in range(1, rowLen): for c in range(columnLen): # 当前位置为障碍物 if obstacleGrid[r][c] == 1: ret = 0 note[c] = 0 continue # 当前位置位于左边界 if c == 0: ret = note[c] continue # 普通情况 ret = ret + note[c] note[c] = ret return ret BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 63.不同路径-ii Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/力扣题解 63-不同路径-ii.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"},{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://www.skyline.show/tags/Leetcode题解/"}]},{"title":"Python中list使用","slug":"Python中list使用","date":"2022-07-07T10:18:05.000Z","updated":"2023-02-15T07:26:30.000Z","comments":true,"path":"Python中list使用.html","link":"","permalink":"http://www.skyline.show/Python中list使用.html","excerpt":"list 常见方法 list 常见使用 用法表 用法解析 BMW WARNING list 常见方法 Name Desc Eg append 列表新增元素 list.append(obj) count 统计某个元素在列表中出现的次数 list.count(obj) index 从列表中找出某个值第一个匹配项的索引位置 remove 移除列表中某个值的第一个匹配项 list.remove(obj) pop 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.pop([index=-1]) insert 将对象插入列表 list.insert(index, obj) reverse 反向列表中元素 list.reverse() sort 对原列表进行排序 list.sort(cmp=None, key=None, reverse=False) extend 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.extend(seq) list 常见使用用法表","text":"list 常见方法 list 常见使用 用法表 用法解析 BMW WARNING list 常见方法 Name Desc Eg append 列表新增元素 list.append(obj) count 统计某个元素在列表中出现的次数 list.count(obj) index 从列表中找出某个值第一个匹配项的索引位置 remove 移除列表中某个值的第一个匹配项 list.remove(obj) pop 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.pop([index=-1]) insert 将对象插入列表 list.insert(index, obj) reverse 反向列表中元素 list.reverse() sort 对原列表进行排序 list.sort(cmp=None, key=None, reverse=False) extend 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.extend(seq) list 常见使用用法表 Name Eg Out map list(map(lambda str: str + ‘skyline’, [‘a’, ‘b’, ‘c’])) [‘askyline’, ‘bskyline’, ‘cskyline’] 重复 list [5] * 5 [5, 5, 5, 5, 5] 二维 list [[0] * 5 for _ in range(5)] [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] list 截取 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;][1:2] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;][1:] [&#39;b&#39;] [&#39;b&#39;, &#39;c&#39;] list 长度 len([1, 2, 3]) 3 list 组合 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 存在判定 3 in [1, 2, 3] True 取最大值 max([1,2,3]) 3 取最小值 min([1,2,3]) 1 删除元素 del list[2] 遍历并获取 index/value for index, value in enumerate(nums): for index in range(len(nums)): 用法解析 map lambda 指匿名函数 list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))#[1, 4, 9, 16, 25] 二维 list 不能以[[0] * 5] * 5 来创建二维数组，里面的每一个子数组是指向同一地址 遍历获取 index/value skyline = [1,2]for i, v in enumerate(skyline): print (i, \",\",v)# 0 , 1# 1 , 2for i in range(len(skyline)): print (i, \",\",skyline[i])# 0 , 1# 1 , 2 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Python中list使用.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Python","slug":"Python","permalink":"http://www.skyline.show/tags/Python/"}]},{"title":"Shell中chmod的使用","slug":"Shell中chmod的使用","date":"2022-06-28T02:03:33.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell中chmod的使用.html","link":"","permalink":"http://www.skyline.show/Shell中chmod的使用.html","excerpt":"文件权限 权限查看 权属调整 使用字符赋权 字符含义 添加权限 删除权限 赋予权限 使用数字赋权 特殊权限 权限进阶 SUID SGID Sticky bit BMW WARNING 文件权限权限查看通过ls -lh命令可以查看文件权限 已拿到某个文件夹的权限drwxr-xr-x+ 7 macmini staff 238B Jun 15 16:39 Docs为例，其含义如下 文件格式 所有者权限(u) 群组权限(g) 其他人权限(o) ACL 权限 引用计数 所有者 所在组 大小 最后修改日期 文件名 d rwx r-x r-x + 5 macmini staff 238B Jun 15 16:39 Docs 第一位为文件格式，其字符含义对照如下 字符 含义 - 文件 d 文件夹（directory） l 连接（link） c 字符设备（char） b 块设备（block） s 套接字（sockets） p 管道（pipe） 其余 2-10 位位权限位，以 3 个为 1 组，且均为『rwx』 的 3 个参数的组合。 要注意的是，这三个权限的位置不会改变，如果没有权限，该位置以[ - ]占位。 权属调整","text":"文件权限 权限查看 权属调整 使用字符赋权 字符含义 添加权限 删除权限 赋予权限 使用数字赋权 特殊权限 权限进阶 SUID SGID Sticky bit BMW WARNING 文件权限权限查看通过ls -lh命令可以查看文件权限 已拿到某个文件夹的权限drwxr-xr-x+ 7 macmini staff 238B Jun 15 16:39 Docs为例，其含义如下 文件格式 所有者权限(u) 群组权限(g) 其他人权限(o) ACL 权限 引用计数 所有者 所在组 大小 最后修改日期 文件名 d rwx r-x r-x + 5 macmini staff 238B Jun 15 16:39 Docs 第一位为文件格式，其字符含义对照如下 字符 含义 - 文件 d 文件夹（directory） l 连接（link） c 字符设备（char） b 块设备（block） s 套接字（sockets） p 管道（pipe） 其余 2-10 位位权限位，以 3 个为 1 组，且均为『rwx』 的 3 个参数的组合。 要注意的是，这三个权限的位置不会改变，如果没有权限，该位置以[ - ]占位。 权属调整 文件所属权限调整，使用 chown 命令。 调整文件拥有者 chown user file 调整文件所属组，可使用 chown 命令，也可使用 chgrp 命令 chown :group filechgrp group file 调整文件拥有者与所属组 chown user:group file chown 调整文件权属，各用户更细分权限调整，通过 chmod 命令实现。后续章节围绕 chmod 展开。 使用字符赋权字符含义通过 u g o a来指定被操作的用户。 [ u ]代表文件拥有者(user) [ g ]代表文件所属组(group) [ o ]代表既非所有者也不在所属组的其他用户(other) [ a ]代表所有用户(all) 需要注意的是，文件拥有者不一定在文件所属组中，当文件拥有者在文件所属组中时，检查的是所有者权限，而不是其所属组权限。Linux 在检查用户权限时，按照用户、组、其他的优先级依次检查，若命中则不会再次向后检查。例如，当一个文件的权限位----r-xr-x+ 7 macmini staff时，即便 macmini 用户属于 staff 权限，其也不能读取该文件。 通过 + - =字符来指定权限操作。 [ + ]代表添加权限 [ - ]代表缩减权限 [ = ]代表赋予（更改）权限 通过 r w x字符来指定具体权限。 对于文件 [ r ]代表可读(read) [ w ]代表可写(write) [ x ]代表可执行(execute) 对于文件夹 [ r ]代表列举文件夹内容(ls)，可拷贝文件夹内容(cp) [ w ]代表可新增和删除文件内容，需要拥有可执行权限，否则进不去文件夹拥有写权限也无效 [ x ]代表可进入文件夹 添加权限当前用户添加全部权限 chmod u+rwx file 所有用户添加读写权限 chmod a+rx file 当前组写权限，其他组读权限，分别赋权用,隔开 chmod g+r,o+w file 当多个赋权一致时，也可以合并书写。当前用户与主赋予执行权限 chmod u+x,g+x file# 或合并写为chmod ug+x file chmod g+r,o+w file 对所有用户在当前目录下所有文件（夹）递归赋全部权 chmod -R a+rwx directory 删除权限移除当前用户所在组执行权限 chmod g-x file 赋予权限给予当前用户全部权限，其他人员赋予读取与执行权限 chmod u=rwx,g=rx,o=rx file 使用数字赋权使用数字赋权时，通过如下数字代表不同的权限 权限 数字 read 4 write 2 execute 1 则常见的权限通过数字相加组合，例如： 赋权 取值 计算 r– 4 4 + 0 + 0 r-x 5 4 + 0 + 1 rw- 6 4 + 2 + 0 rwx 7 4 + 2 + 1 chmod 通过指定三位数字来给一个文件向不同的用户赋权例如，要想一个文件的权限为 rwxr-xr-x，每三位一组，即为 755使用 chmod 755 file# 或chmod u=rwx,g=r-x,o=r-x file 特殊权限权限进阶对于各用户赋权，除了常见的r w x权限，还有另外的三种附加权限。分别是 SUID(Set-user Identification) SGID(Set-group Identification) Sticky bit 上述权限在基本权限的基础上，进一步拓展了文件权限限制与开放的层级。在 linux 中，文件权限实际用 12 位二进制来存储。 位置 11 10 9 8 7 6 5 4 3 2 1 0 权限 S G T r w x r w x r w x 在这 12 位上，拥有该权限则对应 1，无权限对应为 0 权限 权限二进制 数值 rw-r-sr– 0 1 0 1 1 0 1 0 0 1 0 0 2654 rwsr-xr-x 1 0 0 1 1 1 1 0 1 1 0 1 4755 rwsr-sr-x 1 1 0 1 1 1 1 0 1 1 0 1 6755 rwsr-sr-t 1 1 1 1 1 1 1 0 1 1 0 1 7755 rwxr-xr-x 0 0 0 1 1 1 1 0 1 1 0 1 755 每三位一组，在附加权限位（9-11 位）上，转换为 10 进制 SUID 对应值为 4，SGID 对应 2，Sticky bit 对应 1。同理，在前 9 位上的读写位上，每 3 位一组，读对应值为 4，写对应值为 2，执行对应值为 1。这些值在使用数字赋权时供计算使用。例如，将所有权限存储二进制位置为 1。 chmod 7777 file# -rwsrwsrwt 1 root root 0 Jul 4 16:41 file SUIDSUID 设定任何执行该文件的用户其身份为文件拥有者，并以文件拥有者权限执行文件。拥有该权限的标识为’S’。其设定的标识位于所有者权限标识三位中的最后一位（即可执行位）上，以初始文件权限rw-r-xr-x为例。当其设定了 SUID 权限时，其标识为rwSr-xr-x。由于占据了可执行位，若此时文件用户所有者具有可执行(x)权限，区分的方案为采用大小写，同时具备 SUID 和 x 权限时，使用小写’s’对应的权限为rwsr-xr-x该权限仅对所有者设定有效，对所属组(g)、其他用户(o)、全部用户(a)设定无效。其权限增减方式为 # 添加chmod u+s file# 删除chmod u-s file 使用数字方式增减权限的方式为 # 添加 chmod 4xxx filechmod 4777 file# 删除 chmod 0xxx file 或chmod xxx filechmod 0777 file SUID 多用于可执行文件上。一个常见的情形为用户更改自己的密码。在 linux 中，普通用户更改密码都涉及修改/etc/passwd 文件，而该文件的权限如下，普通用户无权操作。 ll /etc/passwd# -rw-r--r-- 1 root root 1192 Nov 12 2021 /etc/passwd 普通用户可使用 passwd 命令修改自己的密码，这是由于passwd对应的文件/usr/bin/passwd拥有 SUID 权限 ls -lh /usr/bin/passwd# -rwsr-xr-x 1 root root 28K Apr 1 2020 /usr/bin/passwd SGIDSGID 类似于 SUID，其权限调整由 SUID 的调整拥有者权限变更到调整所属组权限。当 SGID 用于可执行文件时，任何执行该文件的用户拥有文件对应所属组权限。拥有 SGID 权限的标识为’S’。其设定的标识位于所属组权限标识三位中的最后一位（即可执行位）上，以初始文件权限rw-r--r-x为例。当其设定了 SGID 权限时，其标识为rw-r-Sr-x。由于占据了可执行位，若此时文件用户所属组具有可执行(x)权限，区分的方案为采用大小写，同时具备 SGID 和 x 权限时，使用小写’s’对应的权限为rwxr-sr-x该权限仅对所属组设定有效，对文件拥有者(u)、其他用户(o)、全部用户(a)设定无效。即其操作方式为 # 添加chmod g+s file# 删除chmod g-s file 使用数字方式操作权限的方式为 # 添加 chmod 2xxx filechmod 2777 file# 删除 chmod 0xxx file 或chmod xxx filechmod 0777 filechmod 777 file Linux 执行程序的进程中，通过 euid 和 egid 来判定进程对资源的访问权限。假定用户 skyline 的 uid=66，所在组 sky 的 gid=666假定用户 guest 的 uid=88，所在组 test 的 gid=888skyline 来执行 guest 用户如下 private.sh 文件 -rwxr-xr-x+ 7 guest test 238B Jun 15 16:39 private.sh private.sh 未设定 SUID 和 SGID，则执行进程时 euid=66，egid=666，即取执行该进程用户 skyline 的 uid 和 gid。此时，该进程无法获取到执行文件所有者的资源权限。 当 skyline 来执行 guest 如下 share.sh 文件 -rwsr-sr-x+ 7 guest test 238B Jun 15 16:39 share.sh share.sh 设定 SUID 和 SGID，则执行进程时 euid=88，egid=888，即取执行文件的拥有者与所属组对应 的 uid 和 gid。此时，该进程相当于所有者自己运行，可以获取所有者相当的资源权限。 当 SGID 用于文件夹时，效果作用于文件夹内部文件。当父文件夹未设定 SGID 时，其内部新增的文件所属组为创建该文件用户在系统中的基本组。当父文件夹设定 SGID 时，其内部新增的文件所属组为父文件夹所属组。SGID 常用于共享文件夹等场景。 Sticky bitSticky bit 限定只有文件所有者和超级用户可删除文件。拥有该权限的标识为’T’。其设定的标识位于其他用户权限标识三位中的最后一位（即可执行位）上，以初始文件权限rw-r--r--为例。当其设定了 Sticky bit 权限时，其标识为rw-r--r-T。由于占据了可执行位，若此时文件用户所属组具有可执行(x)权限，区分的方案为采用大小写，同时具备 Sticky bit 和 x 权限时，使用小写’t’对应的权限为rwxr--r-t该权限仅对其他用户设定有效，对文件拥有者(u)、所属组(o)设定无效。由于不存在 SUID 与 SGID 都使用 s 标识的冲突，操作时，可以不添加使用者来指定权限，其操作方式为 # 添加chmod +t file# 删除chmod -t file 实际上a+t,o+t在部分系统也生效，但不推荐这种写法。使用数字方式操作权限的方式为 # 添加 chmod 1xxx filechmod 1777 file# 删除 chmod 0xxx file 或 chmod xxx filechmod 0777 filechmod 777 file Sticky bit 常用于共享文件夹中限制其他人的删除权限。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Shell 中 chmod 的使用.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"ES文件下载实现","slug":"ES文件下载实现","date":"2022-06-22T07:16:25.000Z","updated":"2023-02-14T08:05:52.000Z","comments":true,"path":"ES文件下载实现.html","link":"","permalink":"http://www.skyline.show/ES文件下载实现.html","excerpt":"文件处理 代码实现 常见问题 下载文件后打开提示文件已损坏。 BMW WARNING 文件处理文件下载一般有两种，一种为后端接口返回连接浏览器打开即可。本文主要为另一种，接口返回文档字节流，前端使用浏览器内置对象 Blob，用隐藏的 link 来触发下载操作。响应内容如下： 代码实现export function transFile(res, name = '导出.xlsx') &#123; let fileName = res.headers['content-disposition'] ? res.headers['content-disposition'] .split(';')[1] .split('filename=')[1] .replace(/^\\\"|\\\"$/g, '') : name fileName = decodeURI(fileName) const fileNameUnicode = res.headers &amp;&amp; res.headers.hasOwnProperty('content-disposition') &amp;&amp; res.headers['content-disposition'].split(';')[1].split('filename=')[1] if (fileNameUnicode) &#123; //解决中文乱码问题 fileName = decodeURIComponent(fileNameUnicode) &#125; let blob = new Blob([res.data], &#123; // type: 'application/zip;charset=UTF-8', // type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel', // type: res.headers['content-type'], &#125;) if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, fileName) &#125; else &#123; let link = document.createElement('a') let evt = document.createEvent('HTMLEvents') evt.initEvent('click', false, false) link.href = URL.createObjectURL(blob) link.download = fileName link.style.display = 'none' document.body.appendChild(link) link.click() window.URL.revokeObjectURL(link.href) document.body.removeChild(link) &#125;&#125; 常见问题","text":"文件处理 代码实现 常见问题 下载文件后打开提示文件已损坏。 BMW WARNING 文件处理文件下载一般有两种，一种为后端接口返回连接浏览器打开即可。本文主要为另一种，接口返回文档字节流，前端使用浏览器内置对象 Blob，用隐藏的 link 来触发下载操作。响应内容如下： 代码实现export function transFile(res, name = '导出.xlsx') &#123; let fileName = res.headers['content-disposition'] ? res.headers['content-disposition'] .split(';')[1] .split('filename=')[1] .replace(/^\\\"|\\\"$/g, '') : name fileName = decodeURI(fileName) const fileNameUnicode = res.headers &amp;&amp; res.headers.hasOwnProperty('content-disposition') &amp;&amp; res.headers['content-disposition'].split(';')[1].split('filename=')[1] if (fileNameUnicode) &#123; //解决中文乱码问题 fileName = decodeURIComponent(fileNameUnicode) &#125; let blob = new Blob([res.data], &#123; // type: 'application/zip;charset=UTF-8', // type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel', // type: res.headers['content-type'], &#125;) if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, fileName) &#125; else &#123; let link = document.createElement('a') let evt = document.createEvent('HTMLEvents') evt.initEvent('click', false, false) link.href = URL.createObjectURL(blob) link.download = fileName link.style.display = 'none' document.body.appendChild(link) link.click() window.URL.revokeObjectURL(link.href) document.body.removeChild(link) &#125;&#125; 常见问题 下载文件后打开提示文件已损坏。如果是 axios，需要在请求的 options（非请求头）加上 responseType: “blob” ，表明返回服务器返回的数据类型。 responseType 表示服务器响应的数据类型，默认取 ‘json’，可以是 ‘arraybuffer’ , ‘blob’ , ‘document’ , ‘json’, ‘text’, ‘stream’。其他库同理，需要请求时指定响应类型，浏览器方可正常转流。若还是损坏，考虑转换为 Blob 时，指定的文件 type 类型，可以尝试下载某类文件并指定对应格式。常见格式有： Surfix MIME Type .doc application/msword .docx application/vnd.openxmlformats-officedocument.wordprocessingml.document .xls application/vnd.ms-excel .xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet .xlsx .xls application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel .ppt application/vnd.ms-powerpoint .pptx application/vnd.openxmlformats-officedocument.presentationml.presentation .zip application/zip common application/octet-stream BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES文件下载实现.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"Git常见命令","slug":"Git常见命令","date":"2022-06-21T10:02:05.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"Git常见命令.html","link":"","permalink":"http://www.skyline.show/Git常见命令.html","excerpt":"reflog pull git pull -r VS git pull diff –name-only submodule submodule 概述 添加子仓库 更新子仓库 BMW WARNING refloggit reflog 用于记录本地 git 历史操作记录，包括 commit、reset、checkout 等通过 git reflog show &lt;branch&gt;# git reflog &lt;branch&gt; 查看对应分支的历史操作记录，不接 branch 时，默认为当前分支 通过 grep 搭配使用可进行很多有用操作例如，查看当前分支基于哪个分支创建 git reflog | grep checkout git reflog 可以查看到被删除的提交记录，对于误合并或回滚时，常可以用以查找需要找回的代码。 pullgit pull -r VS git pull","text":"reflog pull git pull -r VS git pull diff –name-only submodule submodule 概述 添加子仓库 更新子仓库 BMW WARNING refloggit reflog 用于记录本地 git 历史操作记录，包括 commit、reset、checkout 等通过 git reflog show &lt;branch&gt;# git reflog &lt;branch&gt; 查看对应分支的历史操作记录，不接 branch 时，默认为当前分支 通过 grep 搭配使用可进行很多有用操作例如，查看当前分支基于哪个分支创建 git reflog | grep checkout git reflog 可以查看到被删除的提交记录，对于误合并或回滚时，常可以用以查找需要找回的代码。 pullgit pull -r VS git pull 语法糖？ git pull = git fetch + git mergegit pull --rebase/-r = git fetch + git rebase 现有 git 仓库如下 git pull git pull -rgit pull -r 会将当前提交的记录（E）删除并重新生成一个新的记录（R），其 HASH 值会发生变化。看起来就像是在最近远端提交记录 D 上拉的代码，使得提交记录为一条直线。 diff–name-only–name-only 用于获取变更的文件名git diff 仅会展示更改和删除变更的文件，不会展示新增的文件。通过 git diff --name-only 查看当前工作区中本次变更的文件信息。其后可接版本 HASH。 submodulesubmodule 概述submodule 用于 git 仓库中嵌套其他仓库作为其子模块，嵌入的子模块仓库可以在其内正常进行 git 相关的操作。 添加子仓库git submodule add https://github.com/skylinety/Blog.git 更新子仓库git submodule syncgit submodule update --init 或直接到子仓库目录下执行拉取等操作 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://www.cnblogs.com/kevingrace/p/5896706.html Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"Git","slug":"Git","permalink":"http://www.skyline.show/tags/Git/"}]},{"title":"PicGo","slug":"PicGo","date":"2022-06-21T10:02:05.000Z","updated":"2022-06-21T10:02:05.000Z","comments":true,"path":"PicGo.html","link":"","permalink":"http://www.skyline.show/PicGo.html","excerpt":"程序员的笔记VSCode 编辑器的 Web 版 上线极大的方便了在 GitHub 上做笔记，在 Github 仓库主页，按一下小数点（.）这个键，或将地址栏的 com 换成 dev 即可。在市面的大多数笔记软件中，Quiver Markdown 优化不错，但是同步基本没有，并且官方近两年没更新。Notion 用户界面比较舒适，但是基本不支持 Markdown 语法。Notion 笔记示例 如下 如 Quiver 一样，大多数笔记软件导出 Markdown 会将图片集中一个单独的文件，如果想要把导出的 Markdown 用在其他地方，不等不同时拷贝对应的图片的本地文件夹，将笔记中的图片放在图床中，是一个很好的处理方式。PicGo 作为一个图床上传工具，在 VSCode 提供了对应的插件 相关配置Github","text":"程序员的笔记VSCode 编辑器的 Web 版 上线极大的方便了在 GitHub 上做笔记，在 Github 仓库主页，按一下小数点（.）这个键，或将地址栏的 com 换成 dev 即可。在市面的大多数笔记软件中，Quiver Markdown 优化不错，但是同步基本没有，并且官方近两年没更新。Notion 用户界面比较舒适，但是基本不支持 Markdown 语法。Notion 笔记示例 如下 如 Quiver 一样，大多数笔记软件导出 Markdown 会将图片集中一个单独的文件，如果想要把导出的 Markdown 用在其他地方，不等不同时拷贝对应的图片的本地文件夹，将笔记中的图片放在图床中，是一个很好的处理方式。PicGo 作为一个图床上传工具，在 VSCode 提供了对应的插件 相关配置Github 在 Github 上新建笔记仓库，拷贝用户名/仓库名 如 skylinety/blog-pics在 Settings / Developer settings / Personal access tokens / Generate new token 初始一个 Token PicGO下载 PicGo 插件打开 VSCode 配置，搜索 PicGo 并进行如下配置 系统 上传剪切板图片 文件系统选择图片 输入文件地址 Windows/Unix Ctrl + Alt + U Ctrl + Alt + E Ctrl + Alt + O MacOS ⌘ + Opt + U ⌘ + Opt + E ⌘ + Opt + E BMW WARNING Bulletin I am a bucolic migrant worker but I never walk backwards. Material 最适合程序员的笔记软件 &gt; PicGo Github 图床 Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"VSCode","slug":"VSCode","permalink":"http://www.skyline.show/tags/VSCode/"},{"name":"Extensions","slug":"Extensions","permalink":"http://www.skyline.show/tags/Extensions/"}]},{"title":"PS局部元素透明","slug":"PS局部元素透明","date":"2022-06-21T10:02:04.000Z","updated":"2022-06-22T07:43:00.000Z","comments":true,"path":"PS局部元素透明.html","link":"","permalink":"http://www.skyline.show/PS局部元素透明.html","excerpt":"实现效果 复制图层 修补工具 调整透明度 BMW WARNING 实现效果 复制图层素材地址选中需要透明化元素的图层，CV 复制图层。 修补工具","text":"实现效果 复制图层 修补工具 调整透明度 BMW WARNING 实现效果 复制图层素材地址选中需要透明化元素的图层，CV 复制图层。 修补工具 将原图层需要透明处理的元素用修复工具抹掉。 处理后的背景如下 调整透明度调整复制图层的不透明度即可 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://huaban.com/pins/1375822870/ Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"APPs","slug":"APPs","permalink":"http://www.skyline.show/tags/APPs/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://www.skyline.show/tags/Photoshop/"}]},{"title":"Charles抓取Https包","slug":"Charles抓取Https包","date":"2022-06-21T10:02:04.000Z","updated":"2023-01-24T09:57:10.000Z","comments":true,"path":"Charles抓取Https包.html","link":"","permalink":"http://www.skyline.show/Charles抓取Https包.html","excerpt":"抓取手机基础包 Mac 配置 手机端配置 Https 抓包 SSL 代理配置 Mac 安装证书 手机安装证书 BMW WARNING 抓取手机基础包Mac 配置查看或配置 Mac 代理端口Proxy &gt; Proxy Settings &gt; Port 手机端配置","text":"抓取手机基础包 Mac 配置 手机端配置 Https 抓包 SSL 代理配置 Mac 安装证书 手机安装证书 BMW WARNING 抓取手机基础包Mac 配置查看或配置 Mac 代理端口Proxy &gt; Proxy Settings &gt; Port 手机端配置 连接 Mac 统一网络，点击网络后的 i 图标，在 配置代理时选择手动，查看 Mac 地址，并将 Mac 端的配置填入 Https 抓包SSL 代理配置在上述配置后，可以抓取基本的 Http 包，但是 Https 包抓下来为 unknow需要进一步配置。在 Proxy &gt; SSL Proxiyng Settings 进行如下配置，也可以指定固定的 IPHttps 协议的端口是 443 这里是把所有的网站的 Https 请求都设置进去配置完成后如下 Mac 安装证书先在 Charles 中安装根证书在 Charles 菜单中单击 Help &gt; SSL Proxying &gt; Install Charles Root Certificate 安装证书到电脑。如果安装后证书未被信任，图标如下，则需要双击证书在信任栏进行信任。 然后在 Proxy &gt; Proxy Settings &gt; Proxies 勾选 Enable transparent HTTP proxying 手机安装证书在 help &gt; SSLProxying &gt; Install Charles Root Ceriticate on a Mobile Device or Remote Browser 根据弹窗描述用手机打开对应网址下载证书文件一般地址为 chls.pro/ssl 安装完成后在手机（IOS）上打开 设置 &gt; 通用&gt; 关于本机 &gt; 证书信任设置 &gt; 信任证书 将安装的证书信任，之后就可以进行 Https 抓包。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"APPs","slug":"APPs","permalink":"http://www.skyline.show/tags/APPs/"},{"name":"Charles","slug":"Charles","permalink":"http://www.skyline.show/tags/Charles/"}]},{"title":"ElementUI相关使用","slug":"ElementUI相关使用","date":"2022-06-21T10:02:03.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"ElementUI相关使用.html","link":"","permalink":"http://www.skyline.show/ElementUI相关使用.html","excerpt":"Form 使用Form 校验validate 函数回调不执行 this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; console.log(' submit!!') &#125; else &#123; console.log('error submit!!') return false &#125;&#125;) 执行打印后，无相关打印信息。出现这种问题的原因多为自定义校验规则的函数没有执行 callback 回调。 var validatePassword = (rule, value, callback) =&gt; &#123; if (value === '') &#123; callback(new Error('请输入密码')) // 检查 &#125; else &#123; if (this.ruleForm.checkPass !== '') &#123; this.$refs.ruleForm.validateField('checkPass') &#125; callback() // 检查 &#125;&#125; 上述检查无问题，检查是否为 JSX 写法，JSX 写法下 model 传值不能如下 &lt;el-form class='info-form reset-el-form' label-position='top' label-width='80px' ref='ruleForm' model=&#123;this.params&#125; v-model=&#123;this.params&#125; rules=&#123;this.rules&#125;&gt; 通过如上方式，无法将 model 值传入将传值方式更改为 props 传值 &lt;el-form class='info-form reset-el-form' label-position='top' label-width='80px' ref='ruleForm' props=&#123;&#123; model: this.params, rules: this.rules, &#125;&#125;&gt; 原因多在于 Vue 对于 JSX 语法支持的问题。另一个类似而常见的问题在于 ElementUI 占用了 props 传值导致的问题例如一个 ElTree 的例子。其 data 为 data() &#123; return &#123; departments:[ &#123; id: 1, children: [], deptName: '教育部' &#125; ] defaultProps: &#123; children: 'children', label: 'deptName', &#125;, &#125;&#125;, 各属性使用如下方式传值 &lt;el-tree class='filter-tree' data=&#123;this.departments&#125; props=&#123;this.defaultProps&#125; ref='tree'&gt;&lt;/el-tree&gt; 上述代码并不能将 label 正确地展示出来应调整为如下写法 &lt;el-tree class='filter-tree' data=&#123;this.departments&#125; props=&#123;&#123; props: this.defaultProps, &#125;&#125; ref='tree'&gt;&lt;/el-tree&gt; Form 表单数字","text":"Form 使用Form 校验validate 函数回调不执行 this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; console.log(' submit!!') &#125; else &#123; console.log('error submit!!') return false &#125;&#125;) 执行打印后，无相关打印信息。出现这种问题的原因多为自定义校验规则的函数没有执行 callback 回调。 var validatePassword = (rule, value, callback) =&gt; &#123; if (value === '') &#123; callback(new Error('请输入密码')) // 检查 &#125; else &#123; if (this.ruleForm.checkPass !== '') &#123; this.$refs.ruleForm.validateField('checkPass') &#125; callback() // 检查 &#125;&#125; 上述检查无问题，检查是否为 JSX 写法，JSX 写法下 model 传值不能如下 &lt;el-form class='info-form reset-el-form' label-position='top' label-width='80px' ref='ruleForm' model=&#123;this.params&#125; v-model=&#123;this.params&#125; rules=&#123;this.rules&#125;&gt; 通过如上方式，无法将 model 值传入将传值方式更改为 props 传值 &lt;el-form class='info-form reset-el-form' label-position='top' label-width='80px' ref='ruleForm' props=&#123;&#123; model: this.params, rules: this.rules, &#125;&#125;&gt; 原因多在于 Vue 对于 JSX 语法支持的问题。另一个类似而常见的问题在于 ElementUI 占用了 props 传值导致的问题例如一个 ElTree 的例子。其 data 为 data() &#123; return &#123; departments:[ &#123; id: 1, children: [], deptName: '教育部' &#125; ] defaultProps: &#123; children: 'children', label: 'deptName', &#125;, &#125;&#125;, 各属性使用如下方式传值 &lt;el-tree class='filter-tree' data=&#123;this.departments&#125; props=&#123;this.defaultProps&#125; ref='tree'&gt;&lt;/el-tree&gt; 上述代码并不能将 label 正确地展示出来应调整为如下写法 &lt;el-tree class='filter-tree' data=&#123;this.departments&#125; props=&#123;&#123; props: this.defaultProps, &#125;&#125; ref='tree'&gt;&lt;/el-tree&gt; Form 表单数字 可以通过以下方式来校验数字字段 rules: &#123; age: [ &#123; type: 'number', message: '请输入数字' transform: (value) =&gt; Number(value), &#125; ]&#125;, 若要校验数字长度，使用以下方式 rules: &#123; age: [ &#123; pattern: /\\b\\d&#123;1,5&#125;\\b/, message: '请输入5位以下数字' &#125; ]&#125;, Dialog 使用弹窗 X 点击不关闭对于使用 JSX 语法的弹窗，由于不能直接使用.sync 修饰符，导致弹窗不能接收到传递属性变更的事件（update:visible）在点击右上角关闭按钮时，弹窗无反应。需要传递事件绑定属性 调整后如下 &lt;el-dialog class='reset-el-dialog reset-el-dialog__body ' title='申请' on=&#123;&#123; 'update:visible': this.closeAll &#125;&#125; visible=&#123;this.dialogVisible&#125; // &#123;...&#123; on: &#123; 'update:visible': console.log &#125; &#125;&#125; // &#123;...&#123; ['on-update:visible']: this.closeAll &#125;&#125; width='30%'&gt; &#123;this.renderContent()&#125;&lt;/el-dialog&gt;","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/tags/Vue/"}]},{"title":"Flutter基础使用汇总","slug":"Flutter基础使用汇总","date":"2022-06-21T10:02:03.000Z","updated":"2022-06-21T10:02:03.000Z","comments":true,"path":"Flutter基础使用汇总.html","link":"","permalink":"http://www.skyline.show/Flutter基础使用汇总.html","excerpt":"Flutter 监听返回按键 Flutter 防止屏幕翻转 BMW WARNING NOTICE Material Warrant Flutter 监听返回按键通过 WillPopScope 组件来注册监听回调 Widget build(BuildContext context) &#123; return WillPopScope( onWillPop: _requestPop, child: Scaffold( appBar: AppBar( title: Text('测试代码'), leading: IconButton( icon: Icon(Icons.arrow_back), onPressed: () &#123; print(\"退出$&#123;Navigator.canPop(context)&#125;\"); if (Navigator.canPop(context)) &#123; Navigator.pop(context); &#125; else &#123; SystemNavigator.pop(); &#125; &#125;, ), ), ), ); &#125;Future&lt;bool&gt; _requestPop() &#123; print(\"POP\"); if (Navigator.canPop(context)) &#123; Navigator.pop(context); &#125; else &#123; SystemNavigator.pop(); &#125; return Future.value(false); &#125; Flutter 防止屏幕翻转在 main.dart 入口中加入如下代码 void main() &#123; HttpOverrides.global = new MyHttpOverrides(); // runApp(MyApp()); WidgetsFlutterBinding.ensureInitialized(); SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]) .then((_) &#123; runApp(new MyApp()); &#125;);&#125; BMW WARNING","text":"Flutter 监听返回按键 Flutter 防止屏幕翻转 BMW WARNING NOTICE Material Warrant Flutter 监听返回按键通过 WillPopScope 组件来注册监听回调 Widget build(BuildContext context) &#123; return WillPopScope( onWillPop: _requestPop, child: Scaffold( appBar: AppBar( title: Text('测试代码'), leading: IconButton( icon: Icon(Icons.arrow_back), onPressed: () &#123; print(\"退出$&#123;Navigator.canPop(context)&#125;\"); if (Navigator.canPop(context)) &#123; Navigator.pop(context); &#125; else &#123; SystemNavigator.pop(); &#125; &#125;, ), ), ), ); &#125;Future&lt;bool&gt; _requestPop() &#123; print(\"POP\"); if (Navigator.canPop(context)) &#123; Navigator.pop(context); &#125; else &#123; SystemNavigator.pop(); &#125; return Future.value(false); &#125; Flutter 防止屏幕翻转在 main.dart 入口中加入如下代码 void main() &#123; HttpOverrides.global = new MyHttpOverrides(); // runApp(MyApp()); WidgetsFlutterBinding.ensureInitialized(); SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]) .then((_) &#123; runApp(new MyApp()); &#125;);&#125; BMW WARNING Bulletin I am a bucolic migrant worker but I never walk backwards. Material Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Mobile","slug":"Mobile","permalink":"http://www.skyline.show/tags/Mobile/"},{"name":"Flutter","slug":"Flutter","permalink":"http://www.skyline.show/tags/Flutter/"}]},{"title":"Flutter基础控件使用","slug":"Flutter基础控件使用","date":"2022-06-21T10:02:03.000Z","updated":"2022-06-22T07:42:59.000Z","comments":true,"path":"Flutter基础控件使用.html","link":"","permalink":"http://www.skyline.show/Flutter基础控件使用.html","excerpt":"GestureDetector 基础事件 FloatingActionButton 简述 效果 persistentFooterButtons 简述 代码 效果 ListTile padding 调整 BMW WARNING GestureDetector基础事件 onTap onTapDown onTapUp onLongPress onLongPressUp onLongPressDown onDoubleTap FloatingActionButton","text":"GestureDetector 基础事件 FloatingActionButton 简述 效果 persistentFooterButtons 简述 代码 效果 ListTile padding 调整 BMW WARNING GestureDetector基础事件 onTap onTapDown onTapUp onLongPress onLongPressUp onLongPressDown onDoubleTap FloatingActionButton 简述FloatingActionButton 简称 FAB ,可以实现浮动按钮，也可以实现类似闲鱼 app 的底部凸起导航 floatingActionButton: FloatingActionButton( onPressed: () &#123; setState(() &#123; _controller.value.isPlaying ? _controller.pause() : _controller.play(); &#125;); &#125;, child:Icon( _controller.value.isPlaying ? Icons.pause : Icons.play_arrow, ), ), 效果 persistentFooterButtons简述固定显示在下放的组件 代码persistentFooterButtons: &lt;Widget&gt;[ IconButton(icon: Icon( _controller.value.isPlaying ? Icons.pause : Icons.play_arrow, ), onPressed: () &#123; setState(() &#123; _controller.value.isPlaying ? _controller.pause() : _controller.play(); &#125;); &#125;), IconButton(icon: Icon(Icons.cancel), onPressed: () &#123; Navigator.of(context).maybePop(); &#125;), ], 效果 ListTilepadding 调整BMW WARNING Bulletin I am a bucolic migrant worker but I never walk backwards. Material Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Mobile","slug":"Mobile","permalink":"http://www.skyline.show/tags/Mobile/"},{"name":"Flutter","slug":"Flutter","permalink":"http://www.skyline.show/tags/Flutter/"}]},{"title":"JS垃圾回收机制","slug":"JS垃圾回收机制","date":"2022-06-21T10:02:03.000Z","updated":"2023-01-24T09:57:09.000Z","comments":true,"path":"JS垃圾回收机制.html","link":"","permalink":"http://www.skyline.show/JS垃圾回收机制.html","excerpt":"垃圾回收(GC:Garbage Collecation) 内存标记策略 引用计数（Reference Counting） 标记清除（Mark &amp; Sweep） BMW WARNING 垃圾回收(GC:Garbage Collecation)在各编程语言中，内存的生命周期大概经历如下三个阶段： 内存分配（allocate） 内存使用（read | write） 内存释放（free） 不管是在高级还是低级语言中，第二阶段的读写都很明确，而内存的分配与释放阶段，JS 等高级语言会自动分配内存，通过算法自动进行垃圾回收，释放内存。局部变量会在离开环境时自动解除引用，后续算法自动计数或标记来确定是否释放。对于全局对象与属性，可通过将值设置成 null 来解除引用以释放内存。而 C 语言等低级语言在代码中显式分配与释放内存。 JS 的自动回收垃圾机制大致如下：垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。垃圾回收开销较大，垃圾回收时会停止其他操作，所以垃圾回收并不是实时的，而是周期性地进行。垃圾标记器会跟踪内存，有用内存打上标记，回收垃圾时，需要将那些未被标记的供垃圾回收器清理。标记的策略一般有两种，引用计数与标记清除。 内存标记策略引用计数（Reference Counting）","text":"垃圾回收(GC:Garbage Collecation) 内存标记策略 引用计数（Reference Counting） 标记清除（Mark &amp; Sweep） BMW WARNING 垃圾回收(GC:Garbage Collecation)在各编程语言中，内存的生命周期大概经历如下三个阶段： 内存分配（allocate） 内存使用（read | write） 内存释放（free） 不管是在高级还是低级语言中，第二阶段的读写都很明确，而内存的分配与释放阶段，JS 等高级语言会自动分配内存，通过算法自动进行垃圾回收，释放内存。局部变量会在离开环境时自动解除引用，后续算法自动计数或标记来确定是否释放。对于全局对象与属性，可通过将值设置成 null 来解除引用以释放内存。而 C 语言等低级语言在代码中显式分配与释放内存。 JS 的自动回收垃圾机制大致如下：垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。垃圾回收开销较大，垃圾回收时会停止其他操作，所以垃圾回收并不是实时的，而是周期性地进行。垃圾标记器会跟踪内存，有用内存打上标记，回收垃圾时，需要将那些未被标记的供垃圾回收器清理。标记的策略一般有两种，引用计数与标记清除。 内存标记策略引用计数（Reference Counting） 传统的引用计数方式简单来说就是记录内存引用的总数，当总数为 0 时，该内存将被回收。该方式最大的弊端是循环引用时对应的内存将不能被回收。引用计数的主要标记策略为获取不再使用的对象（计数为 0 即不再使用）循环引用代码示例： function test() &#123; var a = new Object() var b = new Object() a.child = b b.child = a&#125; 标记清除（Mark &amp; Sweep）根对象长驻内存，故其关联引用的后代可认为也该常驻内存。故标记清除基本策略可认为就是扫描根对象与关联对象，有关联保留，无关联销毁。标记清除的主要标记策略为对象可否获取。 标记阶段 JavaScript 由根对象开始，例如浏览器中的 window，定期遍历找出其所有关联引用的对象。即找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些存在引用关系的对象进行标记，这是标记阶段。 清除阶段 清除阶段就是垃圾收集器清除那些没有被标记的对象，释放其内存。 现代浏览器一般采用此方式来 GC。内存泄漏可认为是开发者不再使用的对象但标记阶段仍可以由根节点关联到。 对于标记清除策略，循环引用将不再是问题，在上述循环引用实例中，test 执行完毕上下文被销毁后，其内部变量 a 或 b 都不可以通过 window 对象获取，故而被销毁。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#reference-counting_garbage_collection Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Refactor&Optimization","slug":"Refactor-Optimization","permalink":"http://www.skyline.show/tags/Refactor-Optimization/"}]},{"title":"ES简单类型","slug":"ES简单类型","date":"2022-06-21T10:02:02.000Z","updated":"2023-02-15T08:48:57.000Z","comments":true,"path":"ES简单类型.html","link":"","permalink":"http://www.skyline.show/ES简单类型.html","excerpt":"ES 类型 Number Number进制表示 NaN Null &amp; undefined null vs undefined String 字符串替换 字符串截取 BMW WARNING ES 类型ES 将会类型分为简单类型（原始类型）和复杂类型（结构类型）其中常见的类型可用 typeof 进行简单判定。 // Primitives:Boolean : typeof instance === \"boolean\"Number : typeof instance === \"number\"String : typeof instance === \"string\"BigInt : typeof instance === \"bigint\"Symbol : typeof instance === \"symbol\"undefined : typeof instance === \"undefined\"// Structural Types:Object : typeof instance === \"object\"Function : typeof instance === \"function\"// Structural Root Primitive:null : typeof instance === \"object\" 对于复杂类型中 Array、RegExp 等对象的判定，要得到其明确类型而非’object’需要使用Object.prototype.toString.call例如 Array: Object.prototype.toString.call(instance) //'[object Array]'RegExp: Object.prototype.toString.call(instance) //'[object RegExp]' NumberNumber进制表示","text":"ES 类型 Number Number进制表示 NaN Null &amp; undefined null vs undefined String 字符串替换 字符串截取 BMW WARNING ES 类型ES 将会类型分为简单类型（原始类型）和复杂类型（结构类型）其中常见的类型可用 typeof 进行简单判定。 // Primitives:Boolean : typeof instance === \"boolean\"Number : typeof instance === \"number\"String : typeof instance === \"string\"BigInt : typeof instance === \"bigint\"Symbol : typeof instance === \"symbol\"undefined : typeof instance === \"undefined\"// Structural Types:Object : typeof instance === \"object\"Function : typeof instance === \"function\"// Structural Root Primitive:null : typeof instance === \"object\" 对于复杂类型中 Array、RegExp 等对象的判定，要得到其明确类型而非’object’需要使用Object.prototype.toString.call例如 Array: Object.prototype.toString.call(instance) //'[object Array]'RegExp: Object.prototype.toString.call(instance) //'[object RegExp]' NumberNumber进制表示 数字进制表示 进制 EN 表示 Input Output 2 binary 0b 0b11 3 8 octal 0 0o 011 9 16 hexadecimal 0x 0x11 17 NaN NaN 的特征涉及 NaN 的操作返回 NaNNaN 不等于任何值，包括本身 isNaN()isNaN 在接收到一个值以后会尝试将这个值转换成数字任何不能转换成数字的值都会导致该函数返回 true。 Null &amp; undefinednull vs undefinednull 仿Java，表示存在但是为空（空对象指针），沿用c语言传统，隐式转换为0。如果定义的变量将来用于保存对象，建议初始化为 null 而不是其他值undefined 表示不存在，转为数值时为NaN Name 表示 示例 用法 null 表示存在但是为空 5 + null // 5 对象原型链的终点 undefined 表示不存在 5 + undefined// NaN 变量未赋值，函数未返回 String字符串替换// String.prototype.replace()str.replace(regexp|substr, newSubstr|function) 字符串 replace 函数，接收两个参数，返回一个新的字符串。 第一个参数为匹配模式，第二参数为替换方案。如果第一参数为字符串，则字符串中只有符合匹配的第一个位置会被替换。 如果第一个参数是全局匹配模式的正则表达式，同时指定字符串作为第二个参数；可以下列字符序列表中的字符序列，将正则的到的值插入结果字符串。 字符序列表 字符序列 正则属性 含义 $&amp; regExp.lastMatch 匹配的子串（即匹配项） $’ regExp.leftContext 匹配子串左边内容 $` regExp.rightContext 匹配子串右边内容 $n regExp[“$n”] 匹配第n个捕获组子串 如果第一个参数是全局匹配模式的正则表达式，同时指定一个函数作为第二个参数；当匹配执行后，第二参数对应的函数就会执行，该函数的返回值作为替换字符串。第二参数对应的函数，其参数如下： function(match,p1,p2, ... ,offset, string, groups)&#123;return newStr&#125; 该函数的参数解析如下： key value match 匹配的子串 p1,p2, … 假如 replace()方法的第一个参数是一个 RegExp 对象，则代表第 n 个括号匹配的字符串 offset 匹配到的子字符串在原字符串中的偏移量） string 被匹配的原字符串 groups 具名组构成的一个对象 字符串截取字符串截取常用方法为substr、substring、slice。var a = \"skylinety\"a.slice(2,5)//\"yli\"a.substr(2,5)//\"yline\"a.substring(2,5)//\"yli\" 方法 参数 使用 slice 开始位置，结束位置 slice的start如果为正数,end如果为负数，end从尾部算起，如果其位置超过开始位置，返回空字符串；slice中的start如果为负数，会从尾部算起，-1表示倒数第一个，-2表示倒数第2个。 substring 开始位置，结束位置 substring会取start和end中较小的值为start,二者相等返回空字符串，任何一个参数为负数被替换为0(即该值会成为start参数) substr 开始位置，截取长度 substr第一个参数可正负，第二个参数表示，要截取的长度,若该参数为负数或0，都将返回空字符串 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES简单类型.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"ES基础汇总","slug":"ES基础汇总","date":"2022-06-21T10:02:02.000Z","updated":"2023-02-09T01:12:14.000Z","comments":true,"path":"ES基础汇总.html","link":"","permalink":"http://www.skyline.show/ES基础汇总.html","excerpt":"","text":"switch 语句 JS 与 ES switch 语句switch 使用的是全等判定通过为每个 case 语句后添加 break 来避免执行多个 case 的情况，合并多种情况时最好加入注释 JS 与 ES","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"跨境物流查询","slug":"跨境物流查询","date":"2022-06-21T10:02:00.000Z","updated":"2022-06-22T07:42:56.000Z","comments":true,"path":"跨境物流查询.html","link":"","permalink":"http://www.skyline.show/跨境物流查询.html","excerpt":"亚马逊 物流与订单 物流查询 BMW WARNING 亚马逊物流与订单亚马逊一般使用如下跨境物流 UPS DHL 物流 易客满 HS Code HS Code 物流容易遇到通关问题后被退货，其他物流还好。 当在亚马逊官方查到快递单号时，官方的更新速度较慢，可通过后续方式查询物流详细信息。 物流查询","text":"亚马逊 物流与订单 物流查询 BMW WARNING 亚马逊物流与订单亚马逊一般使用如下跨境物流 UPS DHL 物流 易客满 HS Code HS Code 物流容易遇到通关问题后被退货，其他物流还好。 当在亚马逊官方查到快递单号时，官方的更新速度较慢，可通过后续方式查询物流详细信息。 物流查询 HS Code物流单号可以直接在官网查询http://new.wherexpress.com/index.php?r=track%2Findex&amp;assbillno=但是查到的信息甚至比亚马逊的还少。拿到物流单号可以直接在快递 100 查询拿到里面的航空主运单号后可以去http://www.mawb.cn/zh-CN/查询航空信息。PEK 即北京，这里面可以看航班信息，到站信息以及和其他物品一起的总重等。 到站后，一般隔几天才会报关。海关清关速度一般很快，可到如下网站实名后查询https://www.singlewindow.cn/ 跨境电商-公共服务 可以查询到所有走电商通关通道的包裹，或通过掌上海关 APP 物品通关-快件通关 可以查询到个人行邮通关通道的详情(分运单号就是亚马逊订单里的那个包裹号) 查询不到就是还未报关。基本报关当天就会通关放行到亚马逊国内仓库。 一般几天后再由亚马逊国内仓库发给顺丰转运国内。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://ngabbs.com/read.php?tid=24852536&amp;rand=667 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Life","slug":"Life","permalink":"http://www.skyline.show/categories/Life/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://www.skyline.show/tags/Tips/"}]},{"title":"内存基础知识汇总","slug":"内存基础知识汇总","date":"2022-06-21T10:02:00.000Z","updated":"2022-06-21T10:02:00.000Z","comments":true,"path":"内存基础知识汇总.html","link":"","permalink":"http://www.skyline.show/内存基础知识汇总.html","excerpt":"ECC 内存简介ECC 即 Error Correcting Code，错误检查和纠正简写。ECC 内存通过加入一个单独的芯片来校验数据的准确性。 错误产生","text":"ECC 内存简介ECC 即 Error Correcting Code，错误检查和纠正简写。ECC 内存通过加入一个单独的芯片来校验数据的准确性。 错误产生 电脑内部的电磁辐射干扰内存工作，导致动态随机存取内存的单 bit 位数据错误，影响数据的准确性。 原理ECC 内存在写入数据时，额外引入的芯片会将数据进行编码，并存下编码。当读取时，采用相同的算法对读到的数据编码，从芯片取出之前的编码进行对比。一旦不匹配，就会对之前的编码进行解码并对比数据的错误位，然后修复。 辨认可以简单地通过数内存颗粒数来判定是否支持 ECC，一般内存为偶数倍颗粒，当奇数倍颗粒时多出的那一颗就是专门的纠错芯片。ECC 内存相比更加昂贵。 颗粒的正与黑白正片（原厂颗粒）适用于内存（DRAM）与闪存颗粒（NAND 颗粒）颗粒由晶圆切割产生。晶圆切割后，取出合格的部分（图中黑色部分）Die(晶粒)，剩余为不合格的 Die 通过大厂第一道生产，质量通过测试的叫正片，用于厂商自家品牌内存。其余部分颗粒，部分虽未达到厂商标准，但是达到行业标准，为白片。白片被二线大厂采购生产内存。其余的颗粒称为黑片。质量不过关，满足基本使用需求，流入小厂商或山寨厂商。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://www.crucial.in/articles/pc-builders/what-is-ecc-memory Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Hardware","slug":"Hardware","permalink":"http://www.skyline.show/tags/Hardware/"}]},{"title":"Shell基础命令","slug":"Shell基础命令","date":"2022-06-21T08:48:42.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell基础命令.html","link":"","permalink":"http://www.skyline.show/Shell基础命令.html","excerpt":"","text":"echo head echoecho 打印输出命令 echo \"Hello World\" 启用特殊字符转换（\\特殊字符） echo -e \"Column 1\\tColumn 2\"# Column 1 Column 2 head根据要求展示输入的前置部分 output the first part of files ls -lh | head -2# total 8# drwxr-xr-x 5 macmini staff 170B Mar 3 17:06 Demos# 其他方案ls -lh | sed -n '1,2p'# total 8# drwxr-xr-x 5 macmini staff 170B Mar 3 17:06 Demos","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"CSS基础属性","slug":"CSS基础属性","date":"2022-06-15T07:58:53.000Z","updated":"2023-01-24T09:57:06.000Z","comments":true,"path":"CSS基础属性.html","link":"","permalink":"http://www.skyline.show/CSS基础属性.html","excerpt":"","text":"backgroundbackground-size 值 描述 特征 contain 缩放图片直到长或宽延伸到边界，包含（contain）在容器中，background-repeat: no-repeat 会造成背景留白 留白 cover 缩放图片直到覆盖（cover）容器，超出裁剪 裁剪 auto 默认属性，保持图片原有比例 原比例 100% 100% 缩放图片正好填充完宽高 填充 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/CSS 基础属性.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"CSS样式命中优先级","slug":"CSS样式命中优先级","date":"2022-06-15T07:58:53.000Z","updated":"2023-01-24T09:57:07.000Z","comments":true,"path":"CSS样式命中优先级.html","link":"","permalink":"http://www.skyline.show/CSS样式命中优先级.html","excerpt":"样式命中优先级 其他优先级 优先级示例 BMW WARNING 样式命中优先级样式命中优先级递增表大致如下： 选择器 权重值 * 0 元素/伪元素 1 属性选择器 类/伪类 10 ID 100 内联样式 1000 !important 其他优先级如果权重一致，最后一个指定的样式命中。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div.skyline &#123; background-color: blue; &#125; div.liu &#123; background-color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"skyline liu\"&gt;Skyline is red&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 属性选择器权重介于元素与类选择器之间 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div[id='skyline'] &#123; background-color: blue; &#125; body div &#123; background-color: yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"skyline\"&gt;Skyline is blue&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 优先级示例","text":"样式命中优先级 其他优先级 优先级示例 BMW WARNING 样式命中优先级样式命中优先级递增表大致如下： 选择器 权重值 * 0 元素/伪元素 1 属性选择器 类/伪类 10 ID 100 内联样式 1000 !important 其他优先级如果权重一致，最后一个指定的样式命中。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div.skyline &#123; background-color: blue; &#125; div.liu &#123; background-color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"skyline liu\"&gt;Skyline is red&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 属性选择器权重介于元素与类选择器之间 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; div[id='skyline'] &#123; background-color: blue; &#125; body div &#123; background-color: yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"skyline\"&gt;Skyline is blue&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 优先级示例 选择器 权重总值 计算 p 1 1 p.skyline 11 1 + 10 p#demo 101 1 + 100 &lt;p style=&quot;color: pink;&quot;&gt; 1000 1000 #demo 100 100 .skyline 10 10 p.skyline1.skyline2 21 1 + 10 + 10 #navbar p#demo 201 100 + 1 + 100 * 0 0 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://www.w3schools.com/css/css_specificity.asp Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/CSS样式命中优先级.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"HTML标签","slug":"HTML标签","date":"2022-06-10T08:10:24.000Z","updated":"2023-01-24T09:57:07.000Z","comments":true,"path":"HTML标签.html","link":"","permalink":"http://www.skyline.show/HTML标签.html","excerpt":"script type 属性 BMW WARNING scripttype 属性defer 要等到整个页面在内存中 DOM 渲染结束与其他脚本执行之后，才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行改脚本，再继续渲染。defer 是“渲染完再执行”，async 是“下载完就执行”。 type 值 async defer 描述 立即下载脚本，不妨碍其他操作，不依赖其他脚本，不阻塞文档 延迟脚本到文档被解析与显示之后 要点 下载完就执行 渲染完再执行 适用范围 外部引入脚本 外部引入脚本 多个执行顺序 不保证加载顺序 先后顺序 多个执行顺序指同时出现多个 type 设置为 async 或 defer 的 script 标签。type=”module”是表明引入的是一个 ES6 模块脚本，其脚本内的模块需要遵循 ES6 模块规范，其他表现类似于 type 指定为 defer BMW WARNING","text":"script type 属性 BMW WARNING scripttype 属性defer 要等到整个页面在内存中 DOM 渲染结束与其他脚本执行之后，才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行改脚本，再继续渲染。defer 是“渲染完再执行”，async 是“下载完就执行”。 type 值 async defer 描述 立即下载脚本，不妨碍其他操作，不依赖其他脚本，不阻塞文档 延迟脚本到文档被解析与显示之后 要点 下载完就执行 渲染完再执行 适用范围 外部引入脚本 外部引入脚本 多个执行顺序 不保证加载顺序 先后顺序 多个执行顺序指同时出现多个 type 设置为 async 或 defer 的 script 标签。type=”module”是表明引入的是一个 ES6 模块脚本，其脚本内的模块需要遵循 ES6 模块规范，其他表现类似于 type 指定为 defer BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/HTML标签.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://www.skyline.show/tags/HTML/"}]},{"title":"Nas使用frp内网穿透","slug":"Nas使用frp内网穿透","date":"2022-06-09T09:41:58.000Z","updated":"2022-06-03T09:47:42.000Z","comments":true,"path":"Nas使用frp内网穿透.html","link":"","permalink":"http://www.skyline.show/Nas使用frp内网穿透.html","excerpt":"简介 Server 端 下载包 试运行 后台运行服务 Client 端 frpc 配置 添加 docker 镜像 启动容器 套件映射 frpc.ini 简介frp 是一款开源的内网穿透软件，github 主页为：https://github.com/fatedier/frp其架构如下图所示： Server 端下载包在 Release 页面下载服务器 CPU 架构对应的版本 https://github.com/fatedier/frp/releases如果不知道，可以通过 lscpu 命令查看，一般为 arm_64 位或 X86_64 位。确定后通过 weget 命令下载。如 X86_64 对应下载为 weget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_freebsd_amd64.tar.gz github 国内速度较慢，也可通过迅雷等工具下载到本地后通过 SecureCRT 等工具上传. 试运行tar -zxvf frp_0.38.0_linux_amd64.tar.gz 解压成功后打开目录下的 frps.ini 文件，修改如下 [common]bind_port = 7000token = mima 尝试启动服务 ./frps -c frps.ini 成功一般有 success 提示信息，如果遇到 Segmentation fault 错误，检查下载的包版本是否有错。 后台运行服务创建服务文件： touch /etc/systemd/system/frp.service 修改 frp.service 内容如下： [Unit]Description=FRP serviceAfter=network.target syslog.targetWants=network.target[Service]ExecStart=/root/apps/frp/frps -c /root/apps/frp/frps.iniRestart=alwaysUser=root[Install]WantedBy=multi-user.target 重置守护进程服务 systemctl daemon-reload 开启服务 systemctl start frp 检查服务是否开启成功，查看 7000 端口是否开启服务即可。 netstat -anp | grep 7000 注意，此处需要在服务器提供网站对应的配置处将 7000 端口的防火墙限制打开，centos 等系统下，注意 firewalld 是否开放防火墙端口。如上操作完成后，服务即后台启动成功。要想服务开机自启动，输入： systemctl enable frp 即可。 Client 端frpc 配置","text":"简介 Server 端 下载包 试运行 后台运行服务 Client 端 frpc 配置 添加 docker 镜像 启动容器 套件映射 frpc.ini 简介frp 是一款开源的内网穿透软件，github 主页为：https://github.com/fatedier/frp其架构如下图所示： Server 端下载包在 Release 页面下载服务器 CPU 架构对应的版本 https://github.com/fatedier/frp/releases如果不知道，可以通过 lscpu 命令查看，一般为 arm_64 位或 X86_64 位。确定后通过 weget 命令下载。如 X86_64 对应下载为 weget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_freebsd_amd64.tar.gz github 国内速度较慢，也可通过迅雷等工具下载到本地后通过 SecureCRT 等工具上传. 试运行tar -zxvf frp_0.38.0_linux_amd64.tar.gz 解压成功后打开目录下的 frps.ini 文件，修改如下 [common]bind_port = 7000token = mima 尝试启动服务 ./frps -c frps.ini 成功一般有 success 提示信息，如果遇到 Segmentation fault 错误，检查下载的包版本是否有错。 后台运行服务创建服务文件： touch /etc/systemd/system/frp.service 修改 frp.service 内容如下： [Unit]Description=FRP serviceAfter=network.target syslog.targetWants=network.target[Service]ExecStart=/root/apps/frp/frps -c /root/apps/frp/frps.iniRestart=alwaysUser=root[Install]WantedBy=multi-user.target 重置守护进程服务 systemctl daemon-reload 开启服务 systemctl start frp 检查服务是否开启成功，查看 7000 端口是否开启服务即可。 netstat -anp | grep 7000 注意，此处需要在服务器提供网站对应的配置处将 7000 端口的防火墙限制打开，centos 等系统下，注意 firewalld 是否开放防火墙端口。如上操作完成后，服务即后台启动成功。要想服务开机自启动，输入： systemctl enable frp 即可。 Client 端frpc 配置 本文 Client 端此处采用 Docker 方式。将下载的 frpc.ini 放在 Docker 宿主机本地frpc.ini 内容修改如下： [common]server_addr = 42.113.1.102server_port = 7000token = mima[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[DSM]type = tcplocal_ip = 127.0.0.1local_port = 5000remote_port = 5000 如上配置后，意味着我们之后可以通过 42.113.1.102:5000 来进入群晖，通过 42.113.1.102:22 进入群晖后台。 添加 docker 镜像地址如下：https://hub.docker.com/r/chenhw2/frp下载完成后，双击镜像，做如下三处修改： 应用修改后保存退出。 启动容器点击开关容器启动成功即可，若启动失败，可在 Details 查看启动日志。 在外网环境在浏览器输入 42.113.1.102:5000来到群晖登录页即穿透成功。 套件映射对于多数群晖套件，会单独启动不同的服务端口，对于PhotoStation套件来说，其占用了80端口。通过frp的方式外网直接访问无效，需要添加端口映射。一般来说服务器80端口和443端口后续可能要提供另外的http或https服务，尽量不要被占用，作出如下调整[PHOTOSTATION]type = tcplocal_ip = 127.0.0.1local_port = 80remote_port = 8000 此时，使用DS Photo App时，也需要对应的IP后添加8000端口。其他套件的建议与原端口保持一致。 frpc.ini一个常见的frpc.ini配置如下frpc.ini","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"Nas","slug":"Nas","permalink":"http://www.skyline.show/tags/Nas/"}]},{"title":"Shell条件判定","slug":"Shell条件判定","date":"2022-06-07T09:48:52.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Shell条件判定.html","link":"","permalink":"http://www.skyline.show/Shell条件判定.html","excerpt":"if 基本语法 条件包裹括号 常见判定条件 三元 BMW WARNING if基本语法if 条件; then 命令elif 条件; then 命令else 命令fi 其中条件的包裹括号可以有多种方式，每种方式对应的效果不一致 条件包裹括号","text":"if 基本语法 条件包裹括号 常见判定条件 三元 BMW WARNING if基本语法if 条件; then 命令elif 条件; then 命令else 命令fi 其中条件的包裹括号可以有多种方式，每种方式对应的效果不一致 条件包裹括号 command if 后直接接条件无任何括号包裹。表示验证命令是否成功执行。代码源文件如下对于本文后续所有类似代码，首先执行 read -p \"Enter first string: \" VAR1read -p \"Enter second string: \" VAR2 并进行两次相同输入后。 if \"$VAR1\" == \"$VAR2\"; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# 1: command not found# Strings are not equal. if 后不跟包裹符号时，需要跟可执行命令而不是表达式。若命令执行成功，则执行 then，否则执行 else if echo Skyline; then echo \"echo Skyline.\"else echo \"Something wrong.\"fi# Skyline# echo Skyline [expression] if 后接[]包裹的条件表示验证条件表达式是否成立，进行条件判定。Bash-Conditional-Expressions if [ \"$VAR1\" == \"$VAR2\" ]; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal. [[expression]] if 后接[[]]包裹的条件[[]]是[]的升级版本。 if [[ \"$VAR1\" == \"$VAR2\" ]]; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal. [[]]内部支持更多的表达式语法。 # 检查文件是否为符号链接[[ -L $file &amp;&amp; -f $file ]][ -L \"$file\" ] &amp;&amp; [ -f \"$file\" ] (command) if 后接()包裹的条件。表示验证子命令是否成功执行。()其内部不是表达式而是可执行命令，表示在 subshell 跑 command 命令，可以理解为单开进程执行跟主程序无关的其他命令。 if (\"$VAR1\" == \"$VAR2\"); then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# 依次输入1回车，1回车，结果为：# 1: command not found# Strings are not equal. 上述代码中，()内部内容被当做可执行命令执行，故报错，转到 else 执行。()内部命令执行成功，则才会转到 then 执行。 if (echo Skyline); then echo \"echo Skyline.\"else echo \"Something wrong.\"fi ()内执行的命令结果，不会对父 shell 运行结果 造成影响。 skyline=1; (skyline=2);echo $skyline# 1 当()前面加上$时，表示 Command-Substitution，与command一致，表示其运行结果充当所在命令行的一部分 echo 'skyline'| cut -c`echo 2`-3# kyecho 'skyline'| cut -c$(echo 2)-3# ky ((expression)) if 后接(())包裹的条件。表示内部算数表达式的计算。(())内部进行算数表达式的计算。算数表达式可包含常见的一元二元运算符，逻辑运算符等。 if ((\"$VAR1\" == \"$VAR2\")); then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal.if ((1+1 &gt; 1)); then echo \"True\"else echo \"False\"fi# True Shell-Arithmetic当(())前面加上$时，表示得到的算数结果充当所在命令行的一部分. echo 'skyline'| cut -c$((1 + 1))-3# ky 上述代码实现的效果可以使用 expr 实现 echo 'skyline'| cut -c$(expr 1 + 1)-3# ky 注意，expr 通常与一起使用，或与$()使用，注意 expr 中空格的使用，否则报错也可使用 let 来实现计算 start=1let start+=1echo $startecho 'skyline'| cut -c$start-3 常见判定条件 文件相关 参数 含义 -a FILE 文件存在 -d FILE 文件存在且为文件夹(directory) -e FILE 文件存在 -f FILE 文件存在且为常规文件(file) -g FILE 文件存在 SGID 已设置(SGID) -L FILE 文件存在且为软连接(symbol link) -r FILE 文件存在且可读(readable) -w FILE 文件存在且可写(writeable) -x FILE 文件存在且可执行(executable) 字符相关 参数 含义 STRING1 == STRING2 字符判等 STRING1 != STRING2 字符非等 STRING1 &gt; STRING2 字符排序在前 STRING1 &lt; STRING2 字符排序在后 -n STRING 字符非空 -z STRING 字符为空 STRING =~ REGEXP 正则匹配判定 数字相关 参数 含义 NUMBER1 -eq NUMBER2 数字判等(equal) NUMBER1 -ne NUMBER2 数字非等 (not equal) NUMBER1 -gt NUMBER2 数字大于(greater than) NUMBER1 -ge NUMBER2 数字大于等于(greater or equal) NUMBER1 -lt NUMBER2 数字小于(less than) NUMBER1 -le NUMBER2 数字小于等于(less or equal) NUMBER =~ REGEXP 正则匹配判定 三元test \"$VAR1\" == \"$VAR2\" &amp;&amp; echo \"Strings are equal.\" || echo \"Strings are not equal.\" BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Shell 条件判定.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"Linux系统信息","slug":"Linux系统信息","date":"2022-06-03T09:41:58.000Z","updated":"2022-06-03T09:41:58.000Z","comments":true,"path":"Linux系统信息.html","link":"","permalink":"http://www.skyline.show/Linux系统信息.html","excerpt":"系统信息 uname lshw CPU 硬盘 df du diskutil lsblk fdisk USB PCI 内存 系统信息uname查看系统版本信息，使用 uname 命令uname 直接使用时，显示系统内核名。显示完整系统信息 uname -a lshwlshw 即 list hardware 可以查看 cpu, disks, memory, usb controllers 等相关信息，一般需要 sudo 权限 直接使用该命令查看展示内容比较繁杂添加 short 参数来显示扼要信息 sudo lshw -short CPU查看 CPU 信息采用 lscpu 命令 硬盘df即 disk usage information，展示系统中各分区可用空间。 du","text":"系统信息 uname lshw CPU 硬盘 df du diskutil lsblk fdisk USB PCI 内存 系统信息uname查看系统版本信息，使用 uname 命令uname 直接使用时，显示系统内核名。显示完整系统信息 uname -a lshwlshw 即 list hardware 可以查看 cpu, disks, memory, usb controllers 等相关信息，一般需要 sudo 权限 直接使用该命令查看展示内容比较繁杂添加 short 参数来显示扼要信息 sudo lshw -short CPU查看 CPU 信息采用 lscpu 命令 硬盘df即 disk usage information，展示系统中各分区可用空间。 du 即 disk usage，分析计算指定目录对应的硬盘空间使用情况。 du -hd 0 ./*# du -h -d 0 ./* 参数解析-h 可读化展示-d 指定分析的目录层级，后接数字，部分系统下必接数字，部分系统不接默认为 0-a 列出指定目录下所有文件与层级目录-s 只列出指定目录的大小–exclud 排除指定目录，如–exclude=./node_modules diskutil在 MacOS 下使用 diskutil 管理硬盘，查看硬盘信息命令如下 diskutil list lsblk即 list block devices，包括硬盘，闪存等。 fdiskfdisk 主要用于修改系统分区，在 linux 下加-l 参数也可用来查看硬盘分区信息。 fdisk -l 在 MacOS 下，不支持-l 参数 USB通过 lsusb 查看 USB 连接设备信息。 PCI通过 lspci 查看 PCI 连接设备信息。可能包含图形卡、网卡、USB 等设备。 内存free 来查看内存空间使用情况，包括交换空间","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"Linux","slug":"Linux","permalink":"http://www.skyline.show/tags/Linux/"}]},{"title":"SSH使用","slug":"SSH使用","date":"2022-06-03T09:39:34.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"SSH使用.html","link":"","permalink":"http://www.skyline.show/SSH使用.html","excerpt":"SSH 登陆 SSH 连接历史 方法集 who &amp; w last netstat &amp; ss BMW WARNING SSH 登陆对于默认使用了默认 SSH 配置的服务器，可以直接如下登陆 ssh root@10.2.160.12 根据提示输入密码即可。上述使用了 SSH 常用的 root 用户，默认的 22 端口 ssh -i /a/b/c/d.private -p 50777 root@10.2.160.12 i 指定秘钥位置，p 指定端口。 SSH 连接历史方法集","text":"SSH 登陆 SSH 连接历史 方法集 who &amp; w last netstat &amp; ss BMW WARNING SSH 登陆对于默认使用了默认 SSH 配置的服务器，可以直接如下登陆 ssh root@10.2.160.12 根据提示输入密码即可。上述使用了 SSH 常用的 root 用户，默认的 22 端口 ssh -i /a/b/c/d.private -p 50777 root@10.2.160.12 i 指定秘钥位置，p 指定端口。 SSH 连接历史方法集 常用如下命令查看 SSH 连接。 命令 描述 who 查看当前连接用户、连接 IP、登录时间 w 查看当前连接用户与连接 IP、登录时间、当前启动的进程等 last 查看登入历史等信息 netstat 查看网络状态 ss 查看网络连接信息，与 netstat 类似，但可查看根据状态信息 who &amp; w相比于 who，w 可以获取登陆用户当前正在进行的进程操作(对应命令) lastlast 其实质是读取/var/log/wtmp(从该文件创建开始)中的内容并整理成输出。wtmp 日志文件主要记录系统登入、\b 重启等关键信息。last 输出内容较多，当在普通个人电脑上执行该命令的由于经常开关机内容更加庞杂，可通过如下方式进行筛选。last 命令参数 last shutdownlast reboot grep 查找 last | grep rebootlast | grep still netstat &amp; ssnetstat | grep sshss | grep ssh BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"JS内存泄漏与处理","slug":"JS内存泄漏与处理","date":"2022-06-03T09:39:33.000Z","updated":"2022-06-22T07:42:59.000Z","comments":true,"path":"JS内存泄漏与处理.html","link":"","permalink":"http://www.skyline.show/JS内存泄漏与处理.html","excerpt":"垃圾回收(GC:Garbage Collecation) 简介 引用计数（Reference Counting） 标记清除（Mark &amp; Sweep） 内存泄漏（Memory Leaks） 简介 常见内存泄漏情况 常见情况示例 内存泄漏处理 Chrome Memory 调试 内存泄漏监测 泄漏内存对比 泄漏内存对象详情 对象引用链 BMW WARNING 垃圾回收(GC:Garbage Collecation)简介JS 自动进行垃圾回收，不需要如 C 语言等一般需要代码中指定回收。垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。垃圾回收开销较大，垃圾回收时会停止其他操作，所以垃圾回收并不是实时的，而是周期性地进行。回收垃圾时，需要将那些被标记的清除掉，垃圾标记器会跟踪无用内存并打上标记，以供垃圾回收器清理。标记的策略一般有两种，引用计数与标记清除。 引用计数（Reference Counting）","text":"垃圾回收(GC:Garbage Collecation) 简介 引用计数（Reference Counting） 标记清除（Mark &amp; Sweep） 内存泄漏（Memory Leaks） 简介 常见内存泄漏情况 常见情况示例 内存泄漏处理 Chrome Memory 调试 内存泄漏监测 泄漏内存对比 泄漏内存对象详情 对象引用链 BMW WARNING 垃圾回收(GC:Garbage Collecation)简介JS 自动进行垃圾回收，不需要如 C 语言等一般需要代码中指定回收。垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。垃圾回收开销较大，垃圾回收时会停止其他操作，所以垃圾回收并不是实时的，而是周期性地进行。回收垃圾时，需要将那些被标记的清除掉，垃圾标记器会跟踪无用内存并打上标记，以供垃圾回收器清理。标记的策略一般有两种，引用计数与标记清除。 引用计数（Reference Counting） 传统的引用计数方式简单来说就是记录内存引用的总数，当总数为 0 时，该内存将被回收。该方式最大的弊端是循环引用对应的内存将不能被回收。循环引用代码示例： function test() &#123; var a = new Object() var b = new Object() a.child = b b.child = a&#125; 标记清除（Mark &amp; Sweep） 标记阶段 JavaScript 由根对象开始，例如浏览器中的 window，定期遍历找出其所有关联引用的对象。即找所有从这个全局对象开始引用的对象，再找这些对象引用的对象…对这些存在引用关系的对象进行标记，这是标记阶段。 清除阶段 清除阶段就是垃圾收集器清除那些没有被标记的对象，释放其内存。 内存泄漏（Memory Leaks）简介JS 为复杂对象分配堆内存，对象被引用，该堆内存存在。一旦对象不再被引用，此时 JS 垃圾回收机制将回收该堆内存。内存泄漏（Memory Leak）一般指当代码中不再使用该对象而未及时解除引用关系时（对象指针没有被置为 null），该内存分配将一直存在。造成 JS 内存泄漏的主要原因就是非正常引用。现代浏览器一般采用标记清除方式清理内存，故内存泄漏也可认为是：开发者不再使用的对象但标记阶段仍可以由根节点关联到。 常见内存泄漏情况 意外全局对象 DOM 多方引用 绑定的事件未销毁 定时器未清除 闭包未销毁 EventBus 事件没解绑 Vuex $store watch 后没 unwatch 三方库函数对象未调用销毁函数 单页应用跳转原组件未销毁（即 Keep-alive 需要按需使用） 常见情况示例 意外全局对象 function foo(arg) &#123; skyline = 'skyline 是全局变量' this.haha = 'haha 也是全局变量'&#125; 函数执行完成后 skyline 与 haha 并不会被销毁 DOM 多方引用 在 JS 代码中引用了 DOM 对象，DOM 对象被移除，引用未解除，造成该 DOM 对象一直存在内存中。 window.test = &#123; node: document.getElementById('home'),&#125;document.body.removeChild(document.getElementById('home')) 上述例子中，移除 home 节点前，对于 home 节点对象，存在两个引用。一个是 DOM Tree 中的引用，另一个是全局变量 test 的引用。移除 home 节点，只是将 DOM Tree 中的引用解除掉。在全局变量 test 中仍旧存在对 home 的引用，造成 home 节点在 removeChild（人为废弃）后仍旧游离于内存之中。需要特别注意的是，如果上述情况发生在 li、tr 等节点上，那么其关联的 ul 以及 table 等节点也将一致保存在内存中。一个更加常见的例子是在使用 echarts 的单页面项目中，图表容器与某个 DOM 节点绑定。如果图表在路由切换后不再使用，需要在 unmount，destroy 等生命周期中调用 echarts 实例的 dispose 方法。 绑定的事件未销毁 var element = document.getElementById('button')function onClick(event) &#123; element.innerHtml = 'text'&#125;element.addEventListener('click', onClick)// element.removeEventListener('click', onClick); // 加入此行代码解除事件监听element.parentNode.removeChild(element) 上述代码中 element 被引用两次且被点击事件的回调函数使用。将 DOM Tree 中的引用解除掉后，节点引用并未完全解除。需要调用element.removeEventListener(&#39;click&#39;, onClick)将事件监听销毁来解除 element 对节点的引用。这种内存泄漏常见于老一代（IE6 等）浏览器中。现代浏览器或一些三方库（JQuery 等），能够在移除节点前，自动将所有节点上的监听事件移除掉，避免内存泄漏。 定时器未清除 另一个回调内引用节点的常见例子是 timeout 与 interval 中 var someResource = 'I am skyline'var node = document.getElementById('Node')setInterval(function () &#123; if (node) &#123; node.innerHTML = someResource &#125;&#125;, 1000)element.parentNode.removeChild(node) 上诉代码不调用 clearInterval，node 变量将常驻内存中。 闭包未销毁 一个内存泄漏更加严重的例子如下 var theThing = nullvar replaceThing = function () &#123; var originalThing = theThing var unused = function () &#123; if (originalThing) console.log('hi') &#125; theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; console.log(someMessage) &#125;, &#125;&#125;setInterval(replaceThing, 1000) 由于 unused 与 someMethod 的作用域链都引用了 replaceThing 的活动对象 AO。unused 的作用域链为 [unusedContext.AO, replaceThingContext.AO, globalContext.VO] someMethod 的作用域链为 [someMethodContext.AO, replaceThingContext.AO, globalContext.VO] unused 与 someMethod 作用域链引用同一个 replaceThingContext.AO由于 unused 引用 originalThing 导致 replaceThingContext 即便执行完成，其 replaceThingContext.AO 仍旧会被保留。由于 someMethod 保留在全局变量 theThing 中故而其作用域链也并不会被销毁上述代码造成内存泄漏的效果与如下代码一致，下述代码更易于理解。 var theThing = nullvar replaceThing = function () &#123; var originalThing = theThing theThing = &#123; longStr: new Array(1000000).join('*'), someMethod: function () &#123; if (originalThing) console.log('hi') &#125;, &#125;&#125;setInterval(replaceThing, 1000) 从 Chrome 内存分析工具可以看到，由于 originalThing 的闭包使用，导致 originalThing 引用上一轮的 theThing 而造成内存泄漏链条。详细分析参考 An interesting kind of JavaScript memory leak 内存泄漏处理Chrome Memory 调试Chrome 控制台的 Memory 板块提供 3 个功能选项。 Heap snapshot 堆快照。堆快照提供 JS 对象与关联 DOM 节点的内存分配情况。 Allocation instrumentation on timeline 内存分配时间轴。通过内存分配时间轴可以监测内存在时间轴上随着时间变化的分配情况。如上图A 可以选部分时间段。B 处悬浮 2S 查看内存中的对象。C 处查看内存分配调用栈。 Allocation sampling 内存分配抽样抽样获取最耗损内存的操作（函数等），性能开销最小，通过采样方法记录内存分配，提供 JS 执行堆栈的近似分配值。默认以 Heavy 排序，即耗损排序。 内存泄漏监测当页面卡顿或者直接卡死报错页面无响应时，一般都是内存泄漏造成的。定位内存泄漏，首先定位造成内存泄漏的页面或者操作。在浏览器控制台，打开 Performance Monitor 查看内存状态，定位内存激增的操作。建议用此方式排查，也可以通过 Allocation instrumentation on timeline 来找到内存泄漏的地方。 泄漏内存对比在内存泄漏的操作前拍下快照，执行操作，拍下快照，对比两次快照。在搜索框输入 detached 过滤泄漏的对象，选择 Comparison。可以看到泄漏的 DIV DOM 对象新增了 88 个（截图是将代码置于项目中测试，有干扰，忽略）。 泄漏内存对象详情查看泄漏内存对应对象详情，只需将 鼠标移动到对应的节点上等待两秒。 对象引用链在 Object 板块，可以查看该对象引用链，可以看到泄漏的对象位于一个 test 对象的 node 属性上，test 对象位于 window 当中 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 An interesting kind of JavaScript memory leak Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Refactor&Optimization","slug":"Refactor-Optimization","permalink":"http://www.skyline.show/tags/Refactor-Optimization/"}]},{"title":"TS语法校验常见错误","slug":"TS语法校验常见错误","date":"2022-06-03T09:39:33.000Z","updated":"2023-02-04T07:45:53.000Z","comments":true,"path":"TS语法校验常见错误.html","link":"","permalink":"http://www.skyline.show/TS语法校验常见错误.html","excerpt":"property does not exist on type Object 复现 解决 Expression of type ‘string’ can’t be used to index type 复现 解决 BMW WARNING property does not exist on type Object复现Property ‘length’ does not exist on type’Object’. var obj: Object = Object.create(null);obj.value = \"value\"; //[ts] Property 'length' does not exist on type'Object'. 解决","text":"property does not exist on type Object 复现 解决 Expression of type ‘string’ can’t be used to index type 复现 解决 BMW WARNING property does not exist on type Object复现Property ‘length’ does not exist on type’Object’. var obj: Object = Object.create(null);obj.value = \"value\"; //[ts] Property 'length' does not exist on type'Object'. 解决 将对象类型设置为 any var obj: any = Object.create(null);obj.value = \"value\"; 通过字符方式获取对象属性 var obj: Object = Object.create(null);obj[\"value\"] = \"value\"; 通过接口定义对象所具有的属性 var obj: ValueObject = Object.create(null);obj.value = \"value\";interface ValueObject &#123; value?: string;&#125; 使用断言强制执行 var obj: Object = Object.create(null);(obj as any).value = \"value\" Expression of type ‘string’ can’t be used to index type复现Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index type person 并未明确指定键值类型（即隐式指定为任意类型），任意类型与 getValue 传参的 string 类型冲突。 const person = &#123; name: \"sk\", age: 22,&#125;;function getValue(arg: string) &#123; return person[arg]; // Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '&#123; name: string; age: number; &#125;'.&#125; 解决tsconfig.json tsconfig.json中配置suppressImplicitAnyIndexErrors: true 定义接口 const person = &#123; name: 'sk', age: 22&#125;;function getValue(arg: string) &#123; interface IPerson &#123; [key: string]: any &#125; return (&lt;IPerson&gt;person)[arg];&#125; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"TS","slug":"TS","permalink":"http://www.skyline.show/tags/TS/"}]},{"title":"Interface与AbstractClass","slug":"Interface与AbstractClass","date":"2022-06-03T09:39:33.000Z","updated":"2023-02-04T07:45:53.000Z","comments":true,"path":"Interface与AbstractClass.html","link":"","permalink":"http://www.skyline.show/Interface与AbstractClass.html","excerpt":"Interface Abstract Class 综述 BMW WARNING Interface在 JS 中，在没有技术文档或找到对应函数(对象)定义在代码中位置的情况下，我们很难确认： 函数参数方式 函数参数的类型 使用参数的方式 对象提供的方法与属性 同时，在对象中，多层嵌套时，需要写如下代码：a &amp;&amp; a.b ** a.b.c()在 TS 中，与大多数面向对象编程语言一样，引入了 Interface。Interface 用以描述对象结构Interface 的职责在于签订契约，即使用该接口则必须实现该接口中的属性和方法。使用时只需要知道接口，就可知道使用该接口对象的一些基础的构造。 Abstract Class虚拟类不能直接实例化。 abstract class Base &#123; abstract getName(): string; printName() &#123; console.log(\"Hello, \" + this.getName()); &#125;&#125;var a = new Base() // Cannot create an instance of an abstract class.( 虚拟方法与虚拟属性只能存在与虚拟类中，均使用 abstract 关键字。虽然 TS 未做错误校验，但虚拟类至少有一个虚拟方法，否则应该定义为实体类。虚拟方法的主要职责是为其派生的实体类提供蓝图，后续实体类需要实现的方法与属性提供参考（需要实现其中定义的虚拟方法属性等）。 综述","text":"Interface Abstract Class 综述 BMW WARNING Interface在 JS 中，在没有技术文档或找到对应函数(对象)定义在代码中位置的情况下，我们很难确认： 函数参数方式 函数参数的类型 使用参数的方式 对象提供的方法与属性 同时，在对象中，多层嵌套时，需要写如下代码：a &amp;&amp; a.b ** a.b.c()在 TS 中，与大多数面向对象编程语言一样，引入了 Interface。Interface 用以描述对象结构Interface 的职责在于签订契约，即使用该接口则必须实现该接口中的属性和方法。使用时只需要知道接口，就可知道使用该接口对象的一些基础的构造。 Abstract Class虚拟类不能直接实例化。 abstract class Base &#123; abstract getName(): string; printName() &#123; console.log(\"Hello, \" + this.getName()); &#125;&#125;var a = new Base() // Cannot create an instance of an abstract class.( 虚拟方法与虚拟属性只能存在与虚拟类中，均使用 abstract 关键字。虽然 TS 未做错误校验，但虚拟类至少有一个虚拟方法，否则应该定义为实体类。虚拟方法的主要职责是为其派生的实体类提供蓝图，后续实体类需要实现的方法与属性提供参考（需要实现其中定义的虚拟方法属性等）。 综述 type 继承数 使用时机 可否拥有实体方法 主要职责 Interface implements 多个接口 编译时 false 签订契约 Abstract Class extends 一个基类（不管虚实） 运行时 true 绘制蓝图 虚拟类可在运行时使用，而接口只在编译时使用。例如对于接口，你不能使用 instanceof abstract class Base &#123; abstract getName(): string; printName() &#123; console.log(\"Hello, \" + this.getName()); &#125;&#125;interface IBase &#123; getName(): string; printName():void&#125;let x: any;if (x instanceof IBase) &#123; // Error: 'IBase' only refers to a type, but is being used as a value here.&#125;if (x instanceof Base) &#123; // OK&#125; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"TS","slug":"TS","permalink":"http://www.skyline.show/tags/TS/"}]},{"title":"UML类图画图图解","slug":"UML类图画图图解","date":"2022-06-03T09:39:32.000Z","updated":"2022-06-22T07:42:56.000Z","comments":true,"path":"UML类图画图图解.html","link":"","permalink":"http://www.skyline.show/UML类图画图图解.html","excerpt":"简介 Object Classes Interface Abstract Classes Relations Dependency Association Aggregation Composition Inheritance BMW WARNING 简介统一建模语言（Unified Modeling Language）简写 UML ObjectClasses","text":"简介 Object Classes Interface Abstract Classes Relations Dependency Association Aggregation Composition Inheritance BMW WARNING 简介统一建模语言（Unified Modeling Language）简写 UML ObjectClasses 在面向对象编程语言中，常使用 UML 画对象关系图。Class 图包含三个部分(三行) 类名 属性与属性类型 方法名、方法参数与返回值类型 属性方法访问符标记 Public (+) Private (-) Protected (#) Package (~) Derived (/) Static (underlined) InterfaceInterface 与 Class 类似，只需在第一层类名头部加上 &lt;&lt;interface&gt;&gt;即可，接口第二层一般为空。 Abstract ClassesAbstract Classes 与 Interface 类似，只需在第一层类名头部加上 &lt;&lt;abstract&gt;&gt;即可 RelationsDependency依赖关系是一种弱关联关系。依赖（Dependency）体现的是对象间的使用关系，即 ‘use a’ 的关系。类在其方法中使用了另一个类（类实例）图示 Person 的 hasRead 方法使用了 Book 实例，存在依赖关系。 Association关联关系即是强关联，存在两种。Unidirectional Association 单边关系类某个属性引用了另一个类（类实例） 图示 Person 的 owns 属性引用了一组 Book 实例 Bidirectional Association 双边关系类互相引用了对应的类（实例）图示 Person 的 owns 属性引用了一组 Book 实例，Book 的 owners 储存了一组 Person 实例在 UML 中，通过放置多重性（multipicity）表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。多重性允许的表达式示例如下 数字：精确的数量 *或者 0..*：表示 0 到多个 0..1：表示 0 或者 1 个，在 Java 中经常用一个空引用来实现 1..*：表示 1 到多个 Aggregation聚合关系，是一种弱依赖关系。整体不存在，部分可依旧存在。聚合（Aggregation）体现的是整体与部分的拥有关系，即 ‘has a’ 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。用空心菱形和实线表示。 Composition组合关系（如螺丝钉，整体的一部分），是一种强依赖关系。整体不存在，则部分一定消失。组合（Composition）体现整体与部分间的包含关系，即 ‘contains a’ 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。用实心菱形和实线表示。 InheritanceGeneralization泛化关系，一般用于类继承。泛化（Generalization）体现的是对象与派生对象之间的关系，即 ‘is a’ 的关系。类继承采用实线加三角箭头Realization实现关系，一般用于接口继承。实现（Realization）体现的是对象与接口之间的关系，即 ‘realizes a’ 的关系。接口继承采用虚线加三角箭头 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 http://www.cs.utsa.edu/~cs3443/uml/uml.html Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://www.skyline.show/tags/DesignPatterns/"}]},{"title":"CSS常用伪类伪元素","slug":"CSS常用伪类伪元素","date":"2022-06-03T09:39:32.000Z","updated":"2023-01-24T09:57:06.000Z","comments":true,"path":"CSS常用伪类伪元素.html","link":"","permalink":"http://www.skyline.show/CSS常用伪类伪元素.html","excerpt":"伪类 综述 详解 伪元素 综述 详解 区分 BMW WARNING 伪类综述伪类即伪造一个类来为选定元素来描述特殊状态下的样式。通过伪类实现的效果可以直接在选定元素添加一个 class 来模拟实现。伪类通过:前缀来表示 Name Desc EG :nth-of-type 指定标签在相同类型同级标签的位置 p:nth-of-type(n) :nth-child 指定标签在所有类型同级标签的位置 p:nth-child(n) 其中 n 可以是整数（1，2，3）、关键字（even，odd）、可以是公式 2n+1(奇数），n+5(大于等于 5)，-n+5(小于等于 5),而且n 值起始值 0. 详解","text":"伪类 综述 详解 伪元素 综述 详解 区分 BMW WARNING 伪类综述伪类即伪造一个类来为选定元素来描述特殊状态下的样式。通过伪类实现的效果可以直接在选定元素添加一个 class 来模拟实现。伪类通过:前缀来表示 Name Desc EG :nth-of-type 指定标签在相同类型同级标签的位置 p:nth-of-type(n) :nth-child 指定标签在所有类型同级标签的位置 p:nth-child(n) 其中 n 可以是整数（1，2，3）、关键字（even，odd）、可以是公式 2n+1(奇数），n+5(大于等于 5)，-n+5(小于等于 5),而且n 值起始值 0. 详解 nth-of-type 以标签和伪类作为前置条件进行筛选，选后添加类等其他条件进一步筛选。 p.skyline:nth-of-type(2n+1) &#123; text-decoration: underline;&#125; 上述代码首先选出奇数的 p 标签集合 A，然后进一步在 A 中筛选有 skyline 类的标签。容易错误理解成选出有 skyline 类的 p 标签，然后选出其中的奇数。用下述代码更加不容易出错 p:nth-of-type(2n+1).skyline &#123; text-decoration: underline;&#125; :nth-of-type demo nth-child :nth-child demo 伪元素综述伪元素表现为向 HTML 中添加了一个新的元素，而不是向已有元素中适配一个类的样式。通过伪元素实现的效果可以直接添加一个新的元素来模拟实现。伪元素通过::前缀来表示（标准），但也可通过:表示。 Name Desc EG ::after 指定标签后插入样式元素(content 非 none) ::before 指定标签前插入样式元素(content 非 none) ::first-line 选中标签的第一行 ::first-letter 选中标签的第一个字 ::marker 选中列表前修饰类容，一般为数字或圆点。 li::marker ::selection 选中选择的文档。 详解::marker li::marker &#123; content: '✪';&#125; 区分伪元素目前不多，最常见的为::after 和::before通过字面，其最大的区别就在于伪造类和伪造元素。以伪类:first-child 和伪元素::first-letter 来说明 i:first-child &#123;color: red&#125;&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt;p::first-letter &#123;color: red&#125;&lt;p&gt; first second&lt;/p&gt; 模拟实现 .first-child &#123;color: red&#125;&lt;p&gt; &lt;i class=\"first-child\"&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt;span &#123;color: red&#125;&lt;p&gt; &lt;span&gt;first&lt;/span&gt; second&lt;/p&gt; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-of-type Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"Factory工厂模式","slug":"Factory工厂模式","date":"2022-06-03T09:39:32.000Z","updated":"2022-06-22T07:42:56.000Z","comments":true,"path":"Factory工厂模式.html","link":"","permalink":"http://www.skyline.show/Factory工厂模式.html","excerpt":"概述 工厂 设计模式中的工厂 解耦 简单工厂（静态工厂） 实现 工厂方法 实现 使用 类图图示 抽象工厂 实现 类图图示 BMW WARNING 概述工厂工厂这个词往往让人感到困惑，特别是与设计模式中的工厂模式杂糅在一起的时候。一般来说，工厂可以指用于生产产品的一个函数、方法或者类。对于工厂具体所指，一般可以从所读文章的上下文来得到。如在对象创建的文章中，也采用的是工厂。 在ES 对象的创建的文章中，创建对象使用的也是工厂。 function person(name) &#123; var p = new Object() p.name = name return p&#125;var me = person('skyline')me.name // 'skyline' 另，如下常见的代码中， class Person &#123; create() &#123; return new Object() &#125; static createA() &#123; return new Array() &#125;&#125; 其 create 方法往往被叫做工厂方法。于是在这类方法前加入 static 关键字也就被叫做静态工厂方法。上述方法叫做工厂的思想很简单，调用他们都创建了新的产品，故就是工厂。这与设计模式中的工厂模式往往容易混淆。为了区分，我们可以把这种用包裹构造函数创建对象的方法叫做构建方法（Creation method） 设计模式中的工厂","text":"概述 工厂 设计模式中的工厂 解耦 简单工厂（静态工厂） 实现 工厂方法 实现 使用 类图图示 抽象工厂 实现 类图图示 BMW WARNING 概述工厂工厂这个词往往让人感到困惑，特别是与设计模式中的工厂模式杂糅在一起的时候。一般来说，工厂可以指用于生产产品的一个函数、方法或者类。对于工厂具体所指，一般可以从所读文章的上下文来得到。如在对象创建的文章中，也采用的是工厂。 在ES 对象的创建的文章中，创建对象使用的也是工厂。 function person(name) &#123; var p = new Object() p.name = name return p&#125;var me = person('skyline')me.name // 'skyline' 另，如下常见的代码中， class Person &#123; create() &#123; return new Object() &#125; static createA() &#123; return new Array() &#125;&#125; 其 create 方法往往被叫做工厂方法。于是在这类方法前加入 static 关键字也就被叫做静态工厂方法。上述方法叫做工厂的思想很简单，调用他们都创建了新的产品，故就是工厂。这与设计模式中的工厂模式往往容易混淆。为了区分，我们可以把这种用包裹构造函数创建对象的方法叫做构建方法（Creation method） 设计模式中的工厂 虽然 ES 可以通过 new 关键字直接构造对象，但有时候，只有在具体业务场景中才能知道在多个候选对象中具体实例哪一个，我们可以把实例化的任务委托给工厂。 工厂的关键在于可扩展性，用于生成与管理包含部分相同特性的不同对象。注意本文后续的工厂模式（工厂方法）指的是设计模式中的工厂。『工厂模式』有三个变种，分别是『简单工厂模式』、『工厂方法模式』以及『抽象工厂模式』 解耦工厂模式最大的好处就是解耦。假设当前有多个页面都有造车的需求。根据用户选择来造具体的车辆。A 页面为华北工厂使用，B 页面为华南工厂使用。则存在如下代码。bmw.js export function Bmw(model, price, maxSpeed) &#123; this.model = model this.price = price this.maxSpeed = maxSpeed&#125; a.js import &#123; Bmw &#125; from './bmw.js'var type = $('#input').val()if (type === 'X5') new Bmw(type, 108000, 300)if (type === 'X6') new Bmw(type, 111000, 320) b.js import &#123; Bmw &#125; from './bmw.js'var type = $('#input').val()if (type === 'X5') new Bmw(type, 108000, 300)if (type === 'X6') new Bmw(type, 111000, 320) 如果此时需求进行调整，需要新生产 X100 型号轿车？如果工厂合作方调整，开始生产 Benz 轿车？那么我们除了替换 Bmw 类，还要在各个使用 Bmw 的页面进行替换或修改对应代码。如果很多地方都用到，那么替换就是一场灾难。上述代码使用简单工厂很容易就规避这些问题。 简单工厂（静态工厂）实现ES5 function bmwFactory(type) &#123; if (type === 'X5') return new Bmw(type, 108000, 300) if (type === 'X6') return new Bmw(type, 111000, 320)&#125;function Bmw(model, price, maxSpeed) &#123; this.model = model this.price = price this.maxSpeed = maxSpeed&#125;module.exports = bmwFactory ES6 class BmwFactory &#123; static create(type) &#123; if (type === 'X5') return new Bmw(type, 108000, 300) if (type === 'X6') return new Bmw(type, 111000, 320) &#125;&#125;class Bmw &#123; constructor(model, price, maxSpeed) &#123; this.model = model this.price = price this.maxSpeed = maxSpeed &#125;&#125;export default BmwFactory 直接使用 new 的方式来创建对象，客户(调用方)与 new 出来的这个对象和当前耦合，也就是，当前客户端(调用方)依赖着这个 new 出来的对象，不利于对象或相关逻辑调整！采用简单工厂，如果我们修改了具体的实现类或添加相关类型，当需求有调整时，对客户(调用方)而言是完全不用修改。简单工厂的缺点很明显，就是当有新需求时，需要不断地修改工厂代码。优点也很明确，一个工厂来创建对象，代码量少且逻辑不复杂。简单工厂将所有产品杂糅在一起，直接生产产品，对于只生产某种产品或结构类似的产品，使用此模式特别方便。 工厂方法实现现在 Bmw 获得资本青睐，急速扩张，不仅要生产汽车，还要生产自行车。如果继续使用简单工厂，所有不同类型产品放在一起，逻辑会随着产品的增加而越来越复杂和混乱。将工厂进行拆分，不同类型产品由不同工厂生产。工厂方法定义一个创建对象的工厂接口，让适配接口的子类工厂决定生产哪一类产品，而不是直接通过 new 调用产品类方法。工厂方法使得类实例化延迟到其子类。 abstract class Product &#123; abstract getWheels(): void;&#125;class Car extends Product &#123; model: string; price: number; maxSpeed: number; constructor(model:string, price:number, maxSpeed: number) &#123; super() this.model = model; this.price = price; this.maxSpeed = maxSpeed; &#125; getWheels() &#123; console.log('4 wheels'); &#125;;&#125;class Bike extends Product &#123; model: string; price: number; maxSpeed: number; constructor(model:string, price:number, maxSpeed: number) &#123; super() this.model = model; this.price = price; this.maxSpeed = maxSpeed; &#125; getWheels():void &#123; console.log('2 wheels'); &#125;;&#125;interface ProductFactory &#123; createProduct(model: string):Product;&#125;class CarFactory implements ProductFactory &#123; createProduct(model: string): Product &#123; if (model === \"X5\") return new Car(model, 108000, 300); if (model === \"X6\") return new Car(model, 111000, 320); return new Car(\"X5\", 111000, 320); &#125;&#125;class BikeFactory implements ProductFactory &#123; createProduct(model: string): Product &#123; if (model === \"X500\") return new Bike(model, 18000, 30); if (model === \"X600\") return new Bike(model, 11000, 32); return new Bike(\"X500\", 111000, 320); &#125;&#125; 工厂方法要求不同的工厂要生产具有相同超类或实现同一接口的产品。如上例中的产品都实现了 Product 接口。 使用const bf: ProductFactory = new BikeFactory()const b: Product = bf.createProduct('X500')b.getWheels() // 2 wheels 优势采用工厂方法 使用方不需要负责产品的创建，只需明确工厂类的职责 使用方不关注产品如何创建，创建产品不需要知道其实体类（创建 bike x500 并不需要知道其实体类 Bike） 如果有新的产品增加,只需要增加一个具体的类和具体的工厂类即可不会影响已有的代码,后期维护容易,增强系统的扩展性，避免了大量的 if-else 判断 缺点额外代码较多 类图图示在上诉例子中，对应的类图为工厂方法的类图如下 示例图源 抽象工厂实现抽象工厂将提取产品共性。通过共性将工厂进行分类，以共性来划分工厂。例如在上述例子中，客户只有山地的需求，只会购买山地能力的交通工具。这时，可以将山地越野自行车与汽车化为一类，将城市车划为另一类。抽象工厂让客户能够生产同一系列的产品而不需要知道其中每个产品对应的实体类。 interface AbstractVehicleFactory &#123; createCar(): AbstractCar createBike(): AbstractBike&#125;/** * 越野车辆（off-road vehicle） */class ORVFactory implements AbstractVehicleFactory &#123; public createCar(): AbstractCar &#123; return new ORVCar() &#125; public createBike(): AbstractBike &#123; return new ORVBike() &#125;&#125;/** * 城市车辆 */class UrbanVehicleFactory implements AbstractVehicleFactory &#123; public createCar(): AbstractCar &#123; return new UrbanCar() &#125; public createBike(): AbstractBike &#123; return new UrbanBike() &#125;&#125;interface AbstractCar &#123; desc(): string&#125;class ORVCar implements AbstractCar &#123; public desc(): string &#123; return '越野汽车' &#125;&#125;class UrbanCar implements AbstractCar &#123; public desc(): string &#123; return '城市汽车' &#125;&#125;interface AbstractBike &#123; desc(): string withCar(car: AbstractCar): string&#125;class ORVBike implements AbstractBike &#123; public desc(): string &#123; return '越野自行车' &#125; public withCar(car: AbstractCar): string &#123; const result = car.desc() return `$&#123;this.desc()&#125;与$&#123;result&#125;都用于越野` &#125;&#125;class UrbanBike implements AbstractBike &#123; public desc(): string &#123; return '城市自行车' &#125; public withCar(car: AbstractCar): string &#123; const result = car.desc() return `$&#123;this.desc()&#125;与$&#123;result&#125;都用于城市` &#125;&#125;function clientCode(factory: AbstractVehicleFactory) &#123; const Car = factory.createCar() const Bike = factory.createBike() console.log(Bike.desc()) console.log(Bike.withCar(Car))&#125;clientCode(new ORVFactory())// \"越野自行车\"// \"越野自行车与越野汽车都用于越野\"clientCode(new UrbanVehicleFactory())// \"城市自行车\"// \"城市自行车与城市汽车都用于城市\" 使用工厂模式还是抽象工厂取决于需要是某种产品还是产品系列的需求。工厂模式对应的需求是买车还是买自行车抽象工厂对应的是山村客户还是城市客户买系列交通工具的需求 类图图示 类图图源 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 fbeline/design-patterns-JS/blob &gt; https://www.zhihu.com/question/27125796 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://www.skyline.show/tags/DesignPatterns/"},{"name":"Creational","slug":"Creational","permalink":"http://www.skyline.show/tags/Creational/"}]},{"title":"动态规划算法","slug":"动态规划算法","date":"2022-06-03T09:39:32.000Z","updated":"2023-02-22T02:04:40.000Z","comments":true,"path":"动态规划算法.html","link":"","permalink":"http://www.skyline.show/动态规划算法.html","excerpt":"概述 常见类型 解题思路 子序列问题 问题描述 解题思路 背包问题 问题特征 背包问题状态转移方程 实战 最大子串 一步两步爬楼梯 BMW WARNING 概述常见类型动态规范算法，即 Dynamic Programming。常见类型如下： Name Leetcode Problems 基本动态规划: 一维 70 基本动态规划:二维 63， 64，403 分割类型题 子序列问题 5 背包问题 322，416 字符串编辑 股票交易 解题思路","text":"概述 常见类型 解题思路 子序列问题 问题描述 解题思路 背包问题 问题特征 背包问题状态转移方程 实战 最大子串 一步两步爬楼梯 BMW WARNING 概述常见类型动态规范算法，即 Dynamic Programming。常见类型如下： Name Leetcode Problems 基本动态规划: 一维 70 基本动态规划:二维 63， 64，403 分割类型题 子序列问题 5 背包问题 322，416 字符串编辑 股票交易 解题思路 子序列问题问题描述对于子序列涉及的遍历 通常情况下，遍历子串或者子序列有三种方式以[a, b , c, d , e]为例子 解题思路 节点开头 以某个节点为开头 如 [a]，[a, b]，[ a, b, c] … 再从以 b 为开头的子序列开始遍历 [b] [b, c]常用于暴力解法 长度标杆 以子序列的长度为标杆 先遍历出子序列长度为 1 的子序列，在遍历出长度为 2 的 等等leetcode (5. 最长回文子串 ) 中的解法就用到了。 基准尾节点 以子序列的结束节点为基准 以 b 为结束点的所有子序列: [a , b] [b] 以 c 为结束点的所有子序列: [a, b, c] [b, c] [ c ]这种方式可以产生递推关系, 采用动态规划时, 经常通过此种遍历方式。如背包问题, 最大公共子串。 背包问题问题特征有一个明确的目标值，从一堆值中取出部分值和是否可得到目标值 Name Feature Template Problems 0/1 背包问题 元素最多选取一次 外循环遍历 arrs，内循环遍历 target，且内循环倒序 422，494 完全背包问题(顺序无关) 元素可以重复选择 arrs 放在外循环（保证 arrs 按顺序），target 在内循环。且内循环正序 322 完全背包问题(顺序有关，即组合背包问题) 元素可以重复选择 如果组合问题需考虑元素之间的顺序，需将 target 放在外循环，将 arrs 放在内循环，且内循环正序 377 分组背包问题 不止一个背包，需要遍历每个背包 需要 3+层循环 474 背包问题状态转移方程 Name Formula Problems 组合背包问题 dp[i] += dp[i-num] 377 518 True、False 问题公式 dp[i] = dp[i] or dp[i-num] 139 416 最值问题 `dp[i] = min max(dp[i], dp[i-num]+1))` 322 474 实战最大子串 描述 Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. 基本思路 这里的动态规划解法也是以先遍历出以某个节点为结束节点的最大子序列的思路，并以备忘录来记录最大值减少空间消耗。 状态转移方程 在 n = [a, b , c, d , e]这个数组中，以 c 结尾的最大子序列为 dp[2]，当继续遍历到以 d 结尾时，dp[3]的大小取决于 dp[2] + d 与 d 的大小，由此可以得出状态转移方程dp[i] = max(dp[i - 1) + n[i], n[i]) 题解 /** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function (nums) &#123; let sum = nums[0] let ret = nums[0] // 备忘录 for (let i = 1; i &lt; nums.length; i++) &#123; // 注意边界情况，从1开始 sum = Math.max(sum + nums[i], nums[i]) // 状态转移方程 ret = Math.max(ret, sum) &#125; return ret&#125;var maxSubArray = function (nums) &#123; let ret = nums[0] let sum = 0 for (let num of nums) &#123; // if(sum &gt; 0) &#123; 可以写成这样 if (sum + num &gt; num) &#123; sum = sum + num &#125; else &#123; sum = num &#125; ret = Math.max(ret, sum) &#125; return ret&#125; 一步两步爬楼梯 描述 You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? DP 解法 状态转移方程dp[n] = dp[n - 1] + dp[n - 2] /** * @param &#123;number&#125; n * @return &#123;number&#125; */var climbStairs = function (n) &#123; let pre = 1 let next = 1 for (let i = 1; i &lt; n; i++) &#123; let temp = next next = next + pre pre = temp &#125; return next&#125;// dp[n] 到达第n阶的方案总数// dp[n] = dp[n - 1] + dp[n - 2] 递归解法 在动态规划中，我们看到，状态转移方程是典型的斐波那契函数 var climbStairs = function (n) &#123; const recursion = (n) =&gt; &#123; if (n &lt;= 2) return n return recursion(n - 1) + recursion(n - 2) &#125; return recursion(n)&#125; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"},{"name":"算法","slug":"算法","permalink":"http://www.skyline.show/tags/算法/"}]},{"title":"Cookie、Session与Token","slug":"Cookie、Session与Token","date":"2022-06-03T09:39:32.000Z","updated":"2023-01-24T09:57:06.000Z","comments":true,"path":"Cookie、Session与Token.html","link":"","permalink":"http://www.skyline.show/Cookie、Session与Token.html","excerpt":"请求信息保存 Cookie 概述 属性分析 第三方 Cookie Cookie 前缀 Session BMW WARNING 请求信息保存Http 是无状态（stateless）协议，服务端接收到的每一个请求都是全新请求，之前请求的信息不会被存储。这就导致，服务端无法判定请求是否为同一发送者，需要鉴权的请求，就无法获知用户是否进行过鉴权。Cookie Session 等技术诞生就是为了解决请求信息无法保存的问题。 Cookie概述","text":"请求信息保存 Cookie 概述 属性分析 第三方 Cookie Cookie 前缀 Session BMW WARNING 请求信息保存Http 是无状态（stateless）协议，服务端接收到的每一个请求都是全新请求，之前请求的信息不会被存储。这就导致，服务端无法判定请求是否为同一发送者，需要鉴权的请求，就无法获知用户是否进行过鉴权。Cookie Session 等技术诞生就是为了解决请求信息无法保存的问题。 Cookie概述 Cookie 是服务端向客户端返回的微量信息。当服务端请求响应头包含 Set-Cookie 属性时，Set-Cookie 对应的信息会自动保存在浏览器中。在下次会话请求中，符合条件的请求会自动在请求头中设置 Cookie 属性，并携带之前保存的信息。服务端请求响应携带 Cookie Set-Cookie: skyline=hello 客户端发送请求携带 Cookie Cookie: skyline = hello Cookie 信息存在于客户端中，不可跨域携带。 Cookie 相关属性 属性 解析 name=value Cookie 键值对 domain 携带 Cookie 的域名，默认当前域名 path 指定携带 Cookie 的路径，默认’/‘，所有路径皆携带 maxAge 有效期时长，单位 ms expires 有效期截止时间 secure 安全传输，开启后 Cookie 只在 Https 中被自动携带 httpOnly 仅用户请求携带，禁止 JS 脚本通过 Document.cookie 获取 Cookie，一定程度防止 XSS 攻击 SameSite 同站请求设置，防止 CSRF 攻击 Cookie 常用于临时性的微量信息存储，主要用于如下地方： 保存会话信息如用户登录信息，游客购物车，游戏分数等 保存用户个性化配置如网站皮肤设置等 追踪用户习惯追踪分析用户浏览记录、习惯等 Cookie 在 localStorage、sessionStorage 等现代浏览器存储 API 诞生前曾一度被用于存储浏览器端的信息并供脚本使用（即充当现今 localStorage 等的角色 ）。但其有一个很严重的弊端就是所有的 Cookie 都会跟随请求携带，影响接口速度与网站性能。在现代浏览器存储 API 诞生后，Cookie 基本不再用于一般的浏览器存储。 属性分析 domain指定接收该 Cookie 的主机，默认限制为当前域名（www.example.com），不包含example.com下的其他子域名。若进行指定 example.com，则包含其他子域名如 blog.example.com SameSiteStrict: 严格模式，不允许其他网站发送的请求携带 CookieLax: 宽松模式，遵照在严格模式，但是允许其他网站跳转到本站时携带 Cookie，默认值None: 不做限制，但需要安全传输。故设定为此值时，通常要求设定 secure SameSite 是一个较新的属性，目前多数浏览器已支持，用于限制第三方 Cookie。该属性用于告知浏览器源于第三方网站发出的本站请求是否被允许携带 Cookie，可设定 3 种值。SameSite 一般直接使用默认值 Lax，防止第三方网站直接发送本站请求时，浏览器自动携带本站 Cookie若使用严格模式，其他网站跳转到本站时用户信息会遗失，体验较差。举个例子，假定 github 对用户登录信息校验的 Cookie 使用 Strict，用户在已经登录过 github，当从掘金跳转过来 github 时，仍要重新登录。 第三方 Cookie当携带 Cookie 的请求其协议与域名与当前网站协议域名保持一致时被称为第一方 Cookie当协议或域名不一致时，被称为第三方 Cookie。第三方 Cookie 主要用于用户行为与习惯跟踪，通过分析来给用户更好的体验。当用户在浏览购物网站 A（不一定登陆）时，其搜索，点击等操作请求被网站服务器记录并在响应头中携带有唯一标识的 Cookie 储存在浏览器中。而后用户用同一浏览器访问该购物网站 A 投放广告的网站 B 时，网站 B 中网页内嵌入的购物网站 A 的请求（链接、图片等）会自动携带浏览器存储的 A 站相关 Cookie。购物网站 A 通过分析 Cookie 来响应定制化的个性广告信息，实现精准广告投放到网站 B 上。由于隐私与安全等缘故，部分浏览器默认禁止了三方 Cookie Cookie 前缀由于 Cookie 设计机制问题，服务器并不能确定携带 Cookie除了 secure、httpOnly、SameSite 三个属性来增强 Cookie 的安全机制，也可也对的 Cookie 属性添加如下两个前缀来增强安全。 __Host- __Secure- __Secure-前缀仅用于设定 Secure 的 Cookie，否则被拦截。 Set-Cookie: __Secure-skyline=hello; SecureSet-Cookie: __Secure-test=hello; // 被拦截 __Host-前缀进行了进一步强化，需要设定 Secure; Path=/，同时不能设定 Domin 属性 Set-Cookie: __Host-skyline=hello; Secure; Path=/Set-Cookie: __Host-skyline=hello; Secure; // 被拦截Set-Cookie: __Host-skyline=hello; Path=/ // 被拦截Set-Cookie: __Host-skyline=hello; Secure; Path=/; Domain=example.com // 被拦截 SessionSession 是一种记录浏览器与客户端会话状态的机制，服务器通过该技术来判断浏览器发送的请求是否为同一次会话，并保留会话间产生的信息。在该技术方案中，首次接收到请求时，服务端会存储客户端此次会话期间的基本信息。会话基本信息并不一定包括用户登录信息，也可能保留游客用户操作相关信息。一个典型的例子为京东游客用户也可以加购保留选择的商品。 保存相关信息后，服务端会发出响应信息并在响应头中添加 Set-Cookie：SESSIONID=XXXXXXX浏览器接收到请求，会自动设定一个 SESSIONID=XXXXXXX 的 Cookie，并为后续的请求自动携带该 Cookie。服务通过比对 SESSIONID 来判定后续请求的会话归属。Cookie 中 SESSIONID 的过期时间即为此次会话的有效时间。 Session 本质上利用了 Cookie 技术。Session 利用服务端保存会话信息，同时利用 Cookie 保存 SESSIONID。 第一次请求响应头中包含 Set-Cookie后续请求中携带 Session 关联 Cookie 信息 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies &gt; https://www.cookielawinfo.com/tracking-cookies/ Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Network","slug":"Network","permalink":"http://www.skyline.show/tags/Network/"}]},{"title":"Builder建筑工模式","slug":"Builder建筑工模式","date":"2022-06-03T09:39:32.000Z","updated":"2022-06-22T07:42:56.000Z","comments":true,"path":"Builder建筑工模式.html","link":"","permalink":"http://www.skyline.show/Builder建筑工模式.html","excerpt":"概述 实例 修房子 找工人 监工 BMW WARNING 概述Builder 模式一般翻译为建造者模式。在重构代码的过程中，我们常看到几百上千行的复杂类。这些类往往由于最初设定不合理以及需求不断增加而壮大。建筑工模式主要思想是我们将类的实例（产品）构建相关的代码单独交给一个类来实现。建筑工模式通常支持链式调用。 House.setDoors(1).setRooms(2).getHouse(); 实例修房子","text":"概述 实例 修房子 找工人 监工 BMW WARNING 概述Builder 模式一般翻译为建造者模式。在重构代码的过程中，我们常看到几百上千行的复杂类。这些类往往由于最初设定不合理以及需求不断增加而壮大。建筑工模式主要思想是我们将类的实例（产品）构建相关的代码单独交给一个类来实现。建筑工模式通常支持链式调用。 House.setDoors(1).setRooms(2).getHouse(); 实例修房子 现在有一个基础房屋类如下所示 class House &#123; public windows: string[] = []; public doors: string[] = []; public rooms: string[] = []; public area: number = 0; public parts: string[] = []; constructor() &#123; this.setWindows(\"window\"); this.setDoors(\"door\"); this.setBedRooms(\"room\"); &#125; public listWindows(): House &#123; console.log(`House windows: $&#123;this.windows.join(\", \")&#125;\\n`); return this; &#125; public listDoors(): House &#123; console.log(`House doors: $&#123;this.doors.join(\", \")&#125;\\n`); return this; &#125; public listRooms(): House &#123; console.log(`House rooms: $&#123;this.rooms.join(\", \")&#125;\\n`); return this; &#125; public setWindows(w: string): House &#123; this.windows.push(w); return this; &#125; public setDoors(d: string): House &#123; this.doors.push(d); return this; &#125; public setBedRooms(r: string): House &#123; this.rooms.push(r); this.area += 30; return this; &#125; public setKitchens(r: string): House &#123; this.rooms.push(r); this.area += 20; return this; &#125; public capacity(): number &#123; return this.area / 15; &#125;&#125; 现在生活水平不断提高，我们开始有不同的要求，有车的人需要有车库的房子，有人需要有花园的，有泳池，有庭院等的房子。一种常用的方法是，基于 House 类派生出 HouseWithGarage、HouseWithPool、HouseWithYard… class HouseWithGarage extends House &#123; constructor() &#123; super(); this.setGarges(\"garage\"); &#125; public listGarges(): House &#123; console.log(`House parts: $&#123;this.parts.join(\", \")&#125;\\n`); return this; &#125; public setGarges(g: string): House &#123; this.parts.push(g); return this; &#125;&#125; const hg = new HouseWithGarage();console.log(\"builderProblem.ts第63行:::hg\", hg); 使用后得到如下的建筑 &#123; \"windows\": [\"window\"], \"doors\": [\"door\"], \"rooms\": [\"room\"], \"area\": 30, \"parts\": [\"garage\"]&#125; 详细代码当又有智能家居、新风系统等新需求来的时候，相关的派生类变得非常多。 另一种基本不会用的方法是直接在构造函数中进行相关配置并初始化。 class House &#123; ..., constructor(hasGarage: boolean, hasYard: boolean, hasPool: boolean, ...) &#123; this.setWindows('east-window'); this.setDoors('east-door'); this.setBedRooms('east-room'); if(hasGarage) &#123; this.setGarges(\"garage\"); &#125; &#125; ...&#125; 调用的时候会出现如下情况 new House(true, null, true, ...);new House(null, null, true, ...); 上述方案虽然可以解决一定的问题，但是在易用性与维护性方面大打折扣。这些场景中的建筑工可以很好地解决问题。 找工人在 House 类中，有最终生产与配置房屋实例相关的方法（set…)。这些方法都为构建产品而立，我们可以把这些工作都交给建筑工。 class House &#123; public windows: string[] = []; public doors: string[] = []; public rooms: string[] = []; public area: number = 0; public parts: string[] = []; [s: string]: any; public listWindows(): House &#123; console.log(`House windows: $&#123;this.windows.join(\", \")&#125;\\n`); return this; &#125; public listDoors(): House &#123; console.log(`House doors: $&#123;this.doors.join(\", \")&#125;\\n`); return this; &#125; public listRooms(): House &#123; console.log(`House rooms: $&#123;this.rooms.join(\", \")&#125;\\n`); return this; &#125; public capacity(): number &#123; return this.area / 15; &#125;&#125;/** * 建筑者接口，提供创建产品的基本方法与步骤 */interface Builder &#123; setBase(): Builder; setKitchens(r: string): Builder; setGarges(g: string): Builder; setPools(g: string): Builder; setYards(g: string): Builder;&#125;/** * 建筑者实体类。不同的建筑者实体类可以对方法进行不同实现 */class HouseABuilder implements Builder &#123; private house!: House; constructor() &#123; this.reset(); &#125; public reset(): House &#123; this.house = new House(); return this.house; &#125; /** * * @returns 提供this 链式调用 */ public setBase(): Builder &#123; this.setWindows(\"window\"); this.setDoors(\"door\"); this.setBedRooms(\"room\"); return this; &#125; public setWindows(w: string): Builder &#123; this.house.windows.push(w); return this; &#125; public setDoors(d: string): Builder &#123; this.house.doors.push(d); return this; &#125; public setBedRooms(r: string): Builder &#123; this.house.rooms.push(r); this.house.area += 30; return this; &#125; public setKitchens(r: string): Builder &#123; this.house.rooms.push(r); this.house.area += 20; return this; &#125; public setGarges(g: string): Builder &#123; this.house.parts.push(g); return this; &#125; public setPools(g: string): Builder &#123; this.house.parts.push(g); return this; &#125; public setYards(g: string): Builder &#123; this.house.parts.push(g); return this; &#125; /** * * 暴露产品的方法。 * 在将现有产品交付后，建筑工通常需要初始化一个新的产品，供后续调用。 * 此处通过reset，这不是必须的，可以在客户使用时显示调用reset */ public getHouse(): House &#123; const result = this.house; this.reset(); return result; &#125;&#125; 现在我们可以请建筑工来帮我们建筑不同的房子。 const builder = new HouseABuilder();builder.setBase().setGarges(\"garage\").setYards(\"yard\");const gy = builder.getHouse();console.log(\"builder.ts第85行:::gy\", gy);builder.setBase().setGarges(\"garage\");const g = builder.getHouse();console.log(\"builder.ts第88行:::g\", g);builder.setBase().setPools(\"pool\");const p = builder.getHouse();console.log(\"builder.ts第91行:::p\", p); 得到如下的结果 [LOG]: \"builder.ts第85行:::gy\", House: &#123; \"windows\": [ \"window\" ], \"doors\": [ \"door\" ], \"rooms\": [ \"room\" ], \"area\": 30, \"parts\": [ \"garage\", \"yard\" ]&#125;[LOG]: \"builder.ts第88行:::g\", House: &#123; \"windows\": [ \"window\" ], \"doors\": [ \"door\" ], \"rooms\": [ \"room\" ], \"area\": 30, \"parts\": [ \"garage\" ]&#125;[LOG]: \"builder.ts第91行:::p\", House: &#123; \"windows\": [ \"window\" ], \"doors\": [ \"door\" ], \"rooms\": [ \"room\" ], \"area\": 30, \"parts\": [ \"pool\" ]&#125; 详细代码 通过找建筑工帮忙，我们的产品交付给客户时只剩下客户关心的配置。当客户有不同客制化需求时，我们只需让建筑工工程师帮忙发挥他的技能即可。建筑工模式让我们再构建一个产品时让建筑工来执行一系列步骤，通过执行不同步骤来定制不同的产品。虽然当前的建筑工技能已经比较全面，但是某项特定的需求也可能差异化。例如，建筑普通房子的窗可能只需要挖个洞，而富豪的窗是需要镶钻的。普通的院子大小只能让小孩打滚，富豪的院子则需要能打高尔夫。这时候，我们需要差异化建筑工，用不同的建筑工，构建不同的房子。当不同的建筑工越来越多时，什么时候用什么样的工人，需要统一管理，我们引入监工。 监工/** * 引入监工是为指定的需求做定制， * 如此处定制基础房屋、小房子、大房子等 * 另一个用处是调配工人 * 这不必须的。客户也可去掉这个中间商，直接去找工人 */class Director &#123; private builder: Builder; /** * 调配工人 */ public setBuilder(builder: Builder): void &#123; this.builder = builder; &#125; /** * 建筑基础房子 */ public buildMini(): void &#123; this.builder.setBase(); &#125; public buildMedium(): void &#123; this.builder.setBase().setGarges(\"garage\").setYards(\"yard\"); &#125; public buildLarge(): void &#123; this.builder .setBase() .setGarges(\"garage\") .setYards(\"yard\") .setPools(\"pool\"); &#125;&#125; 监工的使用 const director = new Director();const builderA = new HouseABuilder();director.setBuilder(builderA);director.buildLarge();const f = builderA.getHouse();console.log(\"director.ts第214行:::large base house\", f);const builderB = new HouseBBuilder();director.setBuilder(builderB);director.buildMedium();const m = builderB.getHouse();console.log(\"director.ts第214行:::medium diamond house\", m); 得到如下的结果 [LOG]: \"director.ts第214行:::large base house\", House: &#123; \"windows\": [ \"window\" ], \"doors\": [ \"door\" ], \"rooms\": [ \"room\" ], \"area\": 30, \"parts\": [ \"garage\", \"yard\", \"pool\" ]&#125;[LOG]: \"director.ts第214行:::medium diamond house\", House: &#123; \"windows\": [ \"Diamond window\" ], \"doors\": [ \"Diamond door\" ], \"rooms\": [ \"Diamond room\" ], \"area\": 300, \"parts\": [ \"Diamond garage\", \"Diamond yard\" ]&#125; 监工的引入不是必须的，根据实际的需求，选用简单的建筑工还是引入监工。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://refactoring.guru/design-patterns/builder &gt; https://refactoring.guru/design-patterns/builder/typescript/example Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://www.skyline.show/tags/DesignPatterns/"},{"name":"Creational","slug":"Creational","permalink":"http://www.skyline.show/tags/Creational/"}]},{"title":"CSS格式化上下文","slug":"CSS格式化上下文","date":"2022-06-03T09:39:32.000Z","updated":"2023-01-24T09:57:07.000Z","comments":true,"path":"CSS格式化上下文.html","link":"","permalink":"http://www.skyline.show/CSS格式化上下文.html","excerpt":"Formatting Context BFC BFC 定义 BFC 触发 常见应用 display: flow-root BMW WARNING Formatting Context页面的元素或是格式化上下文的一部分，或本身就是格式化上下文。常见的格式化上下文包括： 块级格式化上下文（block formatting contexts） 内联格式化上下文（inline formatting contexts） 弹性格式化上下文（flex formatting context） 网格格式化上下文（grid formatting context） 构建不同的格式化上下文会影响其内部元素，其子元素都会按照相应特定的规则来展现。 BFCBFC 定义","text":"Formatting Context BFC BFC 定义 BFC 触发 常见应用 display: flow-root BMW WARNING Formatting Context页面的元素或是格式化上下文的一部分，或本身就是格式化上下文。常见的格式化上下文包括： 块级格式化上下文（block formatting contexts） 内联格式化上下文（inline formatting contexts） 弹性格式化上下文（flex formatting context） 网格格式化上下文（grid formatting context） 构建不同的格式化上下文会影响其内部元素，其子元素都会按照相应特定的规则来展现。 BFCBFC 定义 正如上文所说格式化上下文只是约定了自身与内部元素的展示规则。这些规则据定了父子元素、兄弟元素等等元素之间在展示时相互影响。BFC 一样，只是约定了一套规则，没有所谓的定义。在 CSS2.1 规范 中，这套规则描述如下： In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the ‘margin’ properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats). 上述规则规定了 BFC 内部元素的排列方向为由上而下，由左至右。兄弟元素之间的间距由 margin 定，上下毗邻块级元素 marign 会合并。 在这套对 BFC 规则描述中，没有提到但 BFC 却拥有的一个最大的特征（规则）是：BFC 容器内部的元素无论如何不会影响容器外部的元素。 BFC 触发最外层的的页面元素（即 html 元素）创建初始的块级格式化上下文。 html 元素 浮动（float != none） 绝对位置元素（position: fixed, absolute） table 及其部分子属性（ display: table, table-cell, table-caption, table-row, table-row-group, table-header-group, table-footer-group） 内联块级元素（display: inline-block） overflow 非默认 flex 子元素 grid 子元素 display: flow-root 常见应用由 BFC 常用于如下场景中： 包含内部浮动元素（contain internal floats） 浮动的元素会脱离普通文档流，无法将容器撑开，将容器设定为 BFC 可防止其内部元素影响容器外部。 &lt;h3&gt;包含内部浮动&lt;/h3&gt;&lt;div class=\"container\"&gt; &lt;section class=\"example\"&gt; &lt;div style=\"border: 2px solid #666;width: 100px\"&gt; &lt;div class=\"cell\" style=\"float: left;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=\"example\"&gt; &lt;div style=\"border: 2px solid #666;width: 100px; overflow: hidden;\"&gt; &lt;div class=\"cell\" style=\"float: left;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 排斥外部浮动元素（exclude external floats） &lt;h3&gt;排除外部浮动&lt;/h3&gt;&lt;div class=\"container\"&gt; &lt;section class=\"example\"&gt; &lt;div class=\"cell\" style=\"float: left; opacity: 0.5;\"&gt;&lt;/div&gt; &lt;div style=\"border: 2px solid #666;width: 100px;height: 25px;\"&gt;&lt;/div&gt; &lt;/section&gt; &lt;section class=\"example\"&gt; &lt;div class=\"cell\" style=\"float: left; opacity: 0.5;\"&gt;&lt;/div&gt; &lt;div style=\"border: 2px solid #666;width: 100px;height: 25px; overflow: hidden;\" &gt;&lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 抑制边距合并（suppress margin collapsing） margin 合并常被称为 margin 穿透。同一个 BFC 内子节点下上外边距会发生合并，要抑制边距合并，可将子节点放在不同的 BFC 中。HTML 根节点本身为就为 BFC，所以我们可以经常遇到 margin 穿透的情况。 &lt;h3&gt;margin穿透&lt;/h3&gt;&lt;div class=\"container\"&gt; &lt;section class=\"example\"&gt; &lt;div class=\"cell\" style=\"margin: 20px;\"&gt;&lt;/div&gt; &lt;div class=\"cell\" style=\"margin: 20px;\"&gt;&lt;/div&gt; &lt;/section&gt; &lt;section class=\"example\"&gt; &lt;div style=\"overflow: hidden;\"&gt; &lt;div class=\"cell\" style=\"margin: 20px;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style=\"overflow: hidden;\"&gt; &lt;div class=\"cell\" style=\"margin: 20px;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 双栏及多栏布局 &lt;h3&gt;排除外部浮动&lt;/h3&gt;&lt;div class=\"container\"&gt; &lt;section class=\"example\"&gt; &lt;div class=\"cell\" style=\"float: left; opacity: 0.5;\"&gt;&lt;/div&gt; &lt;div class=\"cell\" style=\"float: right; opacity: 0.5;\"&gt;&lt;/div&gt; &lt;div style=\"background:#eee;height: 100px; \"&gt; I am a bucolic migrant worker but I never walk backwards. &lt;/div&gt; &lt;/section&gt; &lt;section class=\"example\"&gt; &lt;div class=\"cell\" style=\"float: left; opacity: 0.5;\"&gt;&lt;/div&gt; &lt;div class=\"cell\" style=\"float: right; opacity: 0.5;\"&gt;&lt;/div&gt; &lt;div style=\"background:#eee;height: 100px; overflow: hidden;\"&gt; I am a bucolic migrant worker but I never walk backwards. &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 代码示例 display: flow-root初始化一个块级元素，其内部采用流式布局，并且产生格式化上下文。与 display: block 块级元素主要差别就是其内部采用格式化上下文的规则。利用该方式产生 BFC 一般不会产生其它副作用。从字面意思来说，其表明创造一个与根元素一样的流式布局元素。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://www.w3.org/TR/CSS2/visuren.html#block-formatting https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"硬盘MR技术","slug":"硬盘MR技术","date":"2022-06-03T09:39:32.000Z","updated":"2022-06-22T07:42:57.000Z","comments":true,"path":"硬盘MR技术.html","link":"","permalink":"http://www.skyline.show/硬盘MR技术.html","excerpt":"硬盘原理简述 MR LMR PMR CMR SMR CMR vs SMR SMR 优势与弊端 BMW WARNING 硬盘原理简述硬盘通过小磁体来记录信息。硬盘通过写磁头翻转磁体来对应二进制。如南北朝向的磁体可能意味着 1，那么北南朝向的磁体意味着 0。 MRLMR","text":"硬盘原理简述 MR LMR PMR CMR SMR CMR vs SMR SMR 优势与弊端 BMW WARNING 硬盘原理简述硬盘通过小磁体来记录信息。硬盘通过写磁头翻转磁体来对应二进制。如南北朝向的磁体可能意味着 1，那么北南朝向的磁体意味着 0。 MRLMR Longitudinal Magnetic Recording机械硬盘的磁录密度影响着数据记录的总量（硬盘容量）。早期的硬盘采用的是水平磁记录，如下图所示。这种单个磁体水平放置的方式总的容量空间较小。 PMRPerpendicular Magnetic Recording (PMR)perpendicular 意为垂直的，垂直。之后的磁体被立起来，如下，这种方式不会影响数据的存取，同时可以获得更多的容量。PMR 目前为止有两种分支，为 CMR 与 SMR。SMR 沿用原先的 PMR 的技术，并进一步对磁录密度进行优化。由于 SMR 也基于 PMR 技术，其中的磁体保持垂直，原有技术继续使用 PMR 名词容易造成混淆。故将原有 PMR 技术另命名为 CMR。但是沿用之前的习惯，CMR 也通常被称作 PMR。故一般 PMR 即指 CMR，新分支就称为 SMR CMRConventional Magnetic Recordingconventional 传统的，惯例的由于写磁头比磁道要宽，CMR 在磁道之间加入磁道保护区来防止相邻磁道的写覆盖。 SMRShingled Magnetic Recording (PMR)Shingled 叠瓦的叠瓦进一步增加磁录密度，将原有的相邻磁道保护区取消。将多个磁道进行分区，每个区之间设立保护区。同时，新磁道写入数据时，会对相邻磁道部分宽度进行写覆盖。被覆盖的磁道只留下下图蓝色部分的宽度供读磁头（写磁头更窄）读取数据。 CMR vs SMR一个比较形象但不是很恰当的例子就是传统的瓦房。相同房屋的屋顶面积固定，盖房顶时，这些瓦的总面积就是总容量明显，将瓦片叠在一起用的瓦相比于一片片拼接在一起更多。故叠瓦获取的总容量更大。 SMR 优势与弊端SMR 让厂家可以用同样的成本造出更大容量的硬盘。当下各大厂新出的硬盘很多采用 SMR 技术，这样的硬盘一般更为便宜。相比于 CMR，相同容量下的 SMR 更加轻薄，价格更有优势。同时，SMR 存在以下弊端。由于叠瓦问题，相同磁片分区的数据需要按照磁道顺序写入。如果要修改某个磁体的信息，由于修改会影响相邻磁道的读区域（信息存放），故需要将后一磁道的信息全部重新录入，进而整个分区的后续磁道信息都需要重新录入。这就是为什么 SMR 写数据慢的原因，其后台可能在重写成倍的数据。这同时也造成了 SMR 寿命比不过 CMR. BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://blag.nullteilerfrei.de/2018/05/31/pmr-smr-cmr-i-just-want-a-hdd-mr/ &gt; https://zonedstorage.io/introduction/smr/ Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Hardware","slug":"Hardware","permalink":"http://www.skyline.show/tags/Hardware/"},{"name":"硬盘","slug":"硬盘","permalink":"http://www.skyline.show/tags/硬盘/"}]},{"title":"","slug":"HTTPS加密方式","date":"2022-04-22T10:00:30.000Z","updated":"2022-06-08T03:09:13.000Z","comments":true,"path":"HTTPS加密方式.html","link":"","permalink":"http://www.skyline.show/HTTPS加密方式.html","excerpt":"--- title: HTTPS加密方式 updated: 2022-02-03 14:21:52 --- &gt;作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比","text":"--- title: HTTPS加密方式 updated: 2022-02-03 14:21:52 --- &gt;作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比 端口：HTTPS 443，HTTP 80 传输： HTTPS密文， HTTP 明文 证书：HTTPS需要，HTTP 不需要 （图源：https://juejin.im/post/6844903604868874247） 加密方式常见的加密方式中，是选择对称加密，非对称加密还是算不上加密的摘要算法？以下进行加密方式选择的讨论 摘要算法摘要算法无法逆向获取原文内容，没有可行性。 对称加密（共享密钥加密算法）对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密 可行性存在密钥传输问题如何保证密钥传输给众多客户端过程中不被泄露？网络存在通信实体庞大，不是单单的一对一的问题，往往一台服务器对应众多的访问客户，如何把密钥传递给庞大的客户群并在传输过程不被泄露，是关键问题。 非对称加密公钥加密，私钥解密 可行性单组非对称加密密钥只能保证单边通信可靠性使用一组非对称加密密钥，存在如下问题。客户端公钥加密，服务器私钥解密，客户端到服务器的通信是可靠的，但是反之，服务器向客户端传递信息，如果用私钥加密，则公开的公钥都能解密 两组公钥私钥客户端服务器分别保留一把公钥，一把私钥，公钥加密，私钥解密可行性差的主要原因是非对称加密非常耗时 对称 + 非对称本质采用用非对称算法传递对称密钥，采用对称加密算法加密传输数据 过程 客户端发起请求 服务器明文发送公钥A，客户端获取公钥A 客户端生成密钥X，用公钥A加密密钥X得到密文XXXA后传给服务器 服务器私钥A’解密密文XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 中间人攻击概述非对称加密算法在传递公钥过程中存在公钥被中间人截取篡改的风险。只要是采用了非对称加密算法，都会存在中间人攻击的风险。 非对称加密中间人攻击 中间人获取服务器的公钥A拦截 中间人把自己生产的公钥B返给客户端 客户端用公钥B加密明文”QQ:123 密码：123”成密文XXXB 中间人用私钥B’解密获取明文 中间人用公钥A加密明文为XXXA并传给服务器 上述过程中，客户端与服务器正常通信，难以发觉信息已经被泄露。 信息抵赖由于存在中间人的已知风险，如果不解决非对称中的这个漏洞，即便不存在中间人攻击，对于错误的消息，服务器可以不承认。（中间过程传递的是密文，为了便于理解直接明文展示） 非对称与对称方案中的中间人攻击上述非对称与对称方案并没有解决针对非对称加密算法的此项漏洞，中间人可以在上述非对称与对称方案中进行攻击。具体过程如下 客户端发起请求 服务器发送公钥A，被拦截，中间人获取公钥A 中间人生成公钥B，私钥B’ 中间人发送公钥B，客户端获取公钥B 客户端生成密钥X，用公钥B加密密钥X得到密文XXXB 客户端发送密文XXXB，中间人截取密文 中间人用私钥B’解密获取密钥X 中间人用公钥A加密密钥X得到XXXA，并发送给服务器 服务器私钥A’解密XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 最终中间人成功的获取了客户端与服务器此次通信的密钥X，此次通行中所用信息都可被中间人解密获取 根本原因中间人成功攻击的根本原因是浏览器无法确认获取的公钥真实性 数字证书与签名数字证书为了保证公钥的正确真实性，需要权威CA机构(证书授权中心/Certificate Authority )来颁发数字证书，数字证书里有证书持有者（持有网站）、持有者公钥等信息。在传输过程中，服务器传输公钥A改为传输数字证书，客户端从证书里获取取公钥A 数字签名如何保证数字证书文件的真实性？数字证书既然通过网络传输，那么中间人也可以直接拦截后篡改内容之后再返回。同样，中间人也可以向同一家机构申请证书然后换成自己的证书。如何避免这些问题？世界没有完全相同的一片叶子，也没有完全相同的一个人。人有指纹，有虹膜，还可以用签名来标识身份信息，在这个场景中，有没有可以借鉴的地方？通过数字签名 签发证书CA机构用非对称加密算法拥有一对公私钥，用摘要算法对证书明文信息获取摘要，然后用私钥对摘要进行加密形成签名，最后将签名与使用的摘要算法置入证书当中。这里，不直接用私钥加密明文主要是因为非对称加密算法存在性能问题，加密内容不宜过长，加密摘要显然优于加密明文。 验证签名 客户端用CA机构公钥解密数字签名得到摘要A（由于是客户端（浏览器等）信任的机构，所以其保有对应证书签发机构的公钥） 客户端用证书中的摘要算法对明文进行摘要得到摘要B 对比摘要A与摘要B是否一致 如果摘要对比一致，则验证成功。 不可篡改为什么数字签名可以保证证书不被篡改？中间人即便篡改明文信息并按照摘要算法重新生成摘要，但是由于没有CA机构的私钥，无法对摘要加密形成有效签名。在客户端验证签名过程中（上节步骤1中），无法正确获取摘要A，验证失败！ 证书掉包既然签名不可伪造，证书内容不可篡改，那么，是否可以将证书整体掉包？证书是可以被掉包的，但是由于证书里包含了申请者的信息比如域名，浏览器等客户端会把证书里的域名与请求时的域名进行比对，掉包随即就被发现。证书被掉包时，浏览器会有如下警告 签名本质采用摘要算法获取明文摘要，采用非对称加密算法私钥加密摘要 证书实例证书通常包含以下信息： 申请者公钥 申请者的组织信息和个人信息 签发机构CA的信息 有效时间、证书序列号等信息明文 签名与签名算法 证书申请 （出自：http://yunlaiwu.github.io/） 本地CA机构公钥加入数字证书是为了让客户端准确获取服务器的公钥。但是要想解开证书中的签名，必须有签发机构的公钥，这些公钥从何而来？事实上，操作系统、浏览器等会在安装时附带其认为安全的 CA机构的根证书列表。例如，在HTTPS通信中使用的服务端证书是CA机构W签发的，如果在浏览器中存在W的根证书，那么就可以直接拿到其公钥。在实际过程中根证书往往不直接颁发服务端证书，而是授权给中间证书。 证书链完整的证书链一般有三级 服务端证书（end-user certificates） 中间证书（intermediates Certificates） 根证书（root Certificates） 点击chrome上这个锁图标，可以看一个https网站经过了几级证书认证，并可以查看每一级证书详细信息 不管存在多少级证书，其最终的目的都是为了验证服务端证书未篡改。中间证书可以存在多级，中间证书不会影响验证结果，证书的签发与验证原理不变，最终只要通过证书链最终被CA根证书验证通过即可中间证书的优势： 分级管理，减少根证书管理量，高效签发与管理证书 根证书内置与客户端中，一旦根证书对应的私钥泄露，吊销根证书非常困难，而中间证书私钥泄露，可先在线吊销 常见证书链如下所示 不被信任证书当证书不是由受信任的机构颁发的，浏览器也会警告，用户可以根据网站提示安装证书或进行其他进一步操作。 服务端如何找到正确的密钥X？一台服务器一般情况是与多个客户端保持连接的，每一个连接都有自己的密钥，如何对对应的客户端用正确的密钥X呢？真正的数据传输前，需要进行SSL/TSL握手，密钥X的传递包含其中。当连接建立后，服务器会为每个客户端维护一个session ID，客户端的每一个请求都会携带该sessionID，而服务器正是通过sessionID找到正确的密钥来解密内容 HTTPS请求流程图解HTTPS请求的大致流程如下所示 拓展SSH常用的SSH协议中(Secure Shell安全外壳协议，简称SSH)，采用的就是非对称加密。SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证，都是自己签发的，那么远程登录使用SSH时是如何防止中间人攻击的？SSH登录有两种方式： 口令登录 公钥登录 口令登录第一次登录时服务器会返回公钥并会给出公钥指纹（摘要算法获取公钥的摘要），用户可以拿到指纹与服务器提供商提供的指纹做对比，验证是否一致 $ ssh user@host The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 如果一致，用户确认之后，公钥将会加密用户输入的密码给服务器，让后建立连接 公钥登录使用口令登录，每次都要输入用户名密码，非常繁琐。在公钥登录方式中，用户自己生成一堆非对称密钥。私钥存于本地，公钥拷贝到服务器，建立连接即可。 参考资料 彻底搞懂HTTPS的加密机制HTTPS安全性原理以及其对前端的影响","categories":[],"tags":[]},{"title":"Husky使用","slug":"Husky使用","date":"2022-04-22T10:00:30.000Z","updated":"2022-06-22T07:42:58.000Z","comments":true,"path":"Husky使用.html","link":"","permalink":"http://www.skyline.show/Husky使用.html","excerpt":"Husky 使用配置 husky 简述 V5+ V4 Husky 配置更新 git hooks 说明 V4 工作原理 V5+ 原理 后续问题 BMW WARNING Husky 使用配置husky 简述husky 支持所有 git 相关钩子，在对应 git 操作触发时，可以执行测试、代码校验等相关任务。 以代码校验为例来说明 代码校验 lint-staged 相关配置如下 &#123; \"devDependencies\": &#123; \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;&#125; 后续代码中，其余配置为 husky 相关，通过这些配置，我们在 commit 代码时，会校验代码错误与格式，校验不通过会有提示。 Husky 在版本 5 中配置做了大变动，具体前后的配置以版本来说明。 V5+","text":"Husky 使用配置 husky 简述 V5+ V4 Husky 配置更新 git hooks 说明 V4 工作原理 V5+ 原理 后续问题 BMW WARNING Husky 使用配置husky 简述husky 支持所有 git 相关钩子，在对应 git 操作触发时，可以执行测试、代码校验等相关任务。 以代码校验为例来说明 代码校验 lint-staged 相关配置如下 &#123; \"devDependencies\": &#123; \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;&#125; 后续代码中，其余配置为 husky 相关，通过这些配置，我们在 commit 代码时，会校验代码错误与格式，校验不通过会有提示。 Husky 在版本 5 中配置做了大变动，具体前后的配置以版本来说明。 V5+ yarn add husky -D 安装 husky 最新包 npx husky-init &amp;&amp; yarn 在 package.json 会自动添加如下选项 &#123; \"scripts\": &#123; ..., \"prepare\": \"husky install\" &#125;, \"devDependencies\": &#123; \"husky\": \"^7.0.0\", \"lint-staged\": \"^11.1.2\", &#125;&#125; 汇总其他相关配置选项，如下package.json &#123; \"scripts\": &#123; ..., \"precommit\": \"lint-staged\", \"prepare\": \"husky install\" &#125;, \"devDependencies\": &#123; \"husky\": \"^7.0.0\", \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;&#125; 同时会在项目目录下自动生成 .husky 目录，包含最基础的 pre-commit bash 脚本，将 bash 脚本的默认 npm test 改为 npm run precommit 即可 pre-commit #!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"npm run precommit V4yarn add husky@v4.3.8 -D package.json &#123; ..., \"devDependencies\": &#123; ..., \"husky\": \"4.3.8\", \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;, \"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125; &#125;&#125; Husky 配置更新git hooks 说明要配置 Git 钩子，只需要简单地在.git/hooks/目录下放对应钩子的可执行文件即可 通过 husky 简述中配置可以看到，husky 更新后配置似乎更加麻烦，如下探讨会为何会有去简就繁的操作。 V4 工作原理在 V4 版本及以前，为了可执行 .huskyrc.js 中配置的钩子， 在装 Husky 的时候，默认初始化了全部钩子在.git/hooks/ 中。例如，在执行 commit 时 ， husky/runner.js 会去检查 .huskyrc.js 中是否有对应的配置 $ git commitpre-commit (native) → husky/runner.js (node)→ is a pre-commit defined in `.huskyrc.js`? → YES, run itprepare-commit-msg (native) → husky/runner.js (node)→ is a prepare-commit-msg defined in `.huskyrc.js`? → NO, do nothingcommit-msg (native) → husky/runner.js (node)→ is a commit-msg defined in `.huskyrc.js`? → NO, do nothingpost-commit (native) → husky/runner.js (node)→ is a post-commit defined in `.huskyrc.js`? → NO, do nothing 初始所有了所有.git/hooks/ 钩子，这样的好处是用户随时可以在.huskyrc.js 中增减配置，缺点是对应钩子没有任何相应的配置时，.git/hooks/对应钩子仍旧存在，husky/runner.js 也仍旧会执行。考虑优化插件方向，如果 Husky 初始根据.huskyrc.js 只在.git/hooks/生成对应的配置考虑如下配置 // .huskyrc.jsmodule.exports = &#123; hooks: &#123; &apos;pre-commit&apos;: &apos;lint-staged&apos; &#125;&#125; .git/hooks/pre-commit ← is somehow created 后续有新的钩子需求 // .huskyrc.jsmodule.exports = &#123; hooks: &#123; // &apos;pre-commit&apos;: &apos;lint-staged&apos;, ← removed &apos;commit-msg&apos;: &apos;lint-staged&apos; ← added &#125;&#125; .git/hooks 目录下仍旧只存在 pre-commit 文件。本例中，如果我们只需要使用 pre-commit 钩子，删除.git/hooks/中其他钩子后程序依旧可以正常运行，但是后续在 .huskyrc.js 添加新钩子并不会在.git/hooks/自动生成对应钩子，新加的配置不会起任何作用。 如果要采用上述方式又不想初始化全部钩子，.huskyrc.js 配置与.git/hooks/ 中自动生成对应钩子文件，这就涉及 JS 与 Git 的配置同步问题。 V5+ 原理2016 年，Git 在 2.9 版本引入了 core.hooksPath. 让 Git hooks 的目录可以个性化定制。Husky 5+ 将相关钩子放置在项目.husky 目录下，默认只创建一个运行 npm test 的 pre-commit 钩子。用户不再去.huskyrc.js 配置钩子，而是需要手动运行 npx husky add .husky/commit-msg ‘npm test’ 添加新的钩子。husky install 更改 Git hooks 目录到 .husky/解决了非必要钩子初始化问题，默认只创建一个运行 npm test 的 pre-commit 钩子。husky add 提供后续添加新钩子的需求解决配置同步问题，不再去使用.huskyrc.js 或者在 package.json 中配置钩子，而是通过该命令直接在.husky 目录下生成） 后续问题引入.husky 目录，代码混乱?引入.huskyrc.js 也存在，.husky 支持统一放在 config 等指定目录下。作为 JS 库不用 JS 来配置？如 Jest, ESLint, Prettier 等用 .jestrc.js, .eslintrc.js, .prettierrc.js 来配置，它们全都是用纯 JS 写的。Husky 并不是纯 JS 开发，包含 Shell 脚本，与 Git 交互。 BMW WARNING Bulletin I am a bucolic migrant worker but I never walk backwards. Material Why husky has dropped conventional JS config Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"Packages","slug":"Packages","permalink":"http://www.skyline.show/tags/Packages/"}]},{"title":"鹧鸪天（花重蓉城）","slug":"鹧鸪天（花重蓉城）","date":"2022-04-10T08:57:40.000Z","updated":"2023-01-24T09:57:10.000Z","comments":true,"path":"鹧鸪天（花重蓉城）.html","link":"","permalink":"http://www.skyline.show/鹧鸪天（花重蓉城）.html","excerpt":"","text":"&nbsp;&nbsp; 花重蓉城三月天，倚栏红袖醉氲烟。句芒折柳拂新靥，崔护携桃唤旧颜。 天晏晏，水涟涟，风轻丹落漫飞妍。稚童不晓春光贵，尤与林鹃笑客眠。 &nbsp;&nbsp; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/鹧鸪天(花重蓉城).html.html) 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Subject","slug":"Subject","permalink":"http://www.skyline.show/categories/Subject/"}],"tags":[{"name":"Literature","slug":"Literature","permalink":"http://www.skyline.show/tags/Literature/"},{"name":"诗词","slug":"诗词","permalink":"http://www.skyline.show/tags/诗词/"},{"name":"随笔","slug":"随笔","permalink":"http://www.skyline.show/tags/随笔/"},{"name":"鹧鸪天","slug":"鹧鸪天","permalink":"http://www.skyline.show/tags/鹧鸪天/"}]},{"title":"CentOS利用systemd开启后台进程","slug":"CentOS利用systemd开启后台进程","date":"2022-01-20T07:47:16.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"CentOS利用systemd开启后台进程.html","link":"","permalink":"http://www.skyline.show/CentOS利用systemd开启后台进程.html","excerpt":"简介 创建新服务 开启服务 systemd服务操作汇总 BMW WARNING 简介systemd 是 Linux 中系统与服务管的系列套件，其中 d 沿用传统指代 daemon。systemd 提供多个命令行工具，最基本的为 systemctlsystemd 体系庞大，提供繁杂的功能，其中一个常用的功能就是开启后台服务。 创建新服务创建服务文件并打开 vi /etc/systemd/system/foo.service 输入以下内容 [Unit]Description=My custom serviceAfter=network.target[Service]Type=simpleExecStart=/usr/bin/brook server --listen :992 --password xxxxRestart=alwaysUser=root[Install]WantedBy=multi-user.target [Unit] 提供服务基础信息 Description 为描述信息 After 服务启动的前置条件 [Service] 提供启动服务的相关信息 [Install] WantedBy 定义服务被谁触发 Defines which service triggers the custom service if enabled with systemctl enable. This is mostly used for starting the custom service on boot. In this example, foo.service uses multi-user.target, which starts foo.service when systemd loads multi-user.target on boot. 开启服务","text":"简介 创建新服务 开启服务 systemd服务操作汇总 BMW WARNING 简介systemd 是 Linux 中系统与服务管的系列套件，其中 d 沿用传统指代 daemon。systemd 提供多个命令行工具，最基本的为 systemctlsystemd 体系庞大，提供繁杂的功能，其中一个常用的功能就是开启后台服务。 创建新服务创建服务文件并打开 vi /etc/systemd/system/foo.service 输入以下内容 [Unit]Description=My custom serviceAfter=network.target[Service]Type=simpleExecStart=/usr/bin/brook server --listen :992 --password xxxxRestart=alwaysUser=root[Install]WantedBy=multi-user.target [Unit] 提供服务基础信息 Description 为描述信息 After 服务启动的前置条件 [Service] 提供启动服务的相关信息 [Install] WantedBy 定义服务被谁触发 Defines which service triggers the custom service if enabled with systemctl enable. This is mostly used for starting the custom service on boot. In this example, foo.service uses multi-user.target, which starts foo.service when systemd loads multi-user.target on boot. 开启服务 创建该服务后，需要重载 systemd 服务文件 systemctl daemon-reload 开启该服务 systemctl start foo 查看该服务运行状态 systemctl status foo systemd服务操作汇总开启服务 systemctl start foo 关闭服务 systemctl stop foo 重启服务 systemctl restart foo 服务状态 systemctl status foo 开机自启动服务 systemctl enable foo 禁止开机启动 systemctl disable foo 查看是否允许开机启动 systemctl is-enabled foo BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/CentOS利用systemd开启后台进程.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"Linux","slug":"Linux","permalink":"http://www.skyline.show/tags/Linux/"}]},{"title":"ES对象创建","slug":"ES对象创建","date":"2022-01-20T07:47:16.000Z","updated":"2023-02-04T08:24:24.000Z","comments":true,"path":"ES对象创建.html","link":"","permalink":"http://www.skyline.show/ES对象创建.html","excerpt":"工厂模式 构造函数模式 实现 优化 原型模式 实现 原型判定 原型重写 原型模式问题 组合构造与原型 动态原型 实现 重写原型 寄生构造函数 稳妥构造函数 BMW WARNING 工厂模式工厂模式解决了创建多个对象的问题，但是没有解决对象识别问题（创建对象后其父对象？） function person(name) &#123; var p = new Object(); p.name = name; return p;&#125;var me = person(\"skyline\");me.name; // 'skyline' 构造函数模式实现","text":"工厂模式 构造函数模式 实现 优化 原型模式 实现 原型判定 原型重写 原型模式问题 组合构造与原型 动态原型 实现 重写原型 寄生构造函数 稳妥构造函数 BMW WARNING 工厂模式工厂模式解决了创建多个对象的问题，但是没有解决对象识别问题（创建对象后其父对象？） function person(name) &#123; var p = new Object(); p.name = name; return p;&#125;var me = person(\"skyline\");me.name; // 'skyline' 构造函数模式实现 解决了对象识别问题 构造函数首字母都要大写，非构造函数小写字母开头 构造函数主要问题是方法会在实例中各自创建，me.say === you.say 说明了这个问题 function Person(name) &#123; this.name = name; this.say = function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;;&#125;var me = new Person(\"skyline\");var you = new Person(\"hahaha\");me.say(); // My name is skylineyou.say(); // My name is hahahame.say === you.say; // false 优化优化方案解决了方法不能复用的问题，但破坏了封装 function sayName() &#123; console.log(`My name is $&#123;this.name&#125;`);&#125;function Person(name) &#123; this.name = name; this.say = sayName;&#125;var me = new Person(\"skyline\");var you = new Person(\"hahaha\");me.say(); // My name is skylineyou.say(); // My name is hahahame.say === you.say; // true 原型模式实现ES 中，无论何时创建的新函数，都会根据一组特定的规则来为函数添加一个指向原型对象名为 prototype 的指针属性，该原型对象自动获得一个 constructor 属性，属性指向该函数，而后基于原型对象添置实例共享的属性和方法 function Person() &#123;&#125;Person.prototype.name = \"skyline\";Person.prototype.age = 27;Person.prototype.sayName = function () &#123; alert(this.name);&#125;;var skyline = new Person();skyline.sayName(); // My name is skylineskyline instanceof Person; // true 原型判定调用构造函数创建一个新的实例之后，该实例内部包含一个指向构造函数原型对象的指针[[Prototype]]（内部属性）。多数浏览器实现了__proto__来获取[[Prototype]]内部属性 可以通过 isPrototypeOf()与 getPrototypeOf()来确定与获取关系 skyline.__proto__ == Person.prototype; // trueObject.getPrototypeOf(skyline) == Person.prototype; // truePerson.prototype.isPrototypeOf(skyline); // true 原型重写为了更好的封装性，有时会进行原型重写。 重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系，故重写需谨慎，最好在新建函数的时候重写 通过直接重写 prototype 时，注意将构造函数属性加上 constructor 属性来指定构造函数，此时重新设定的 constructor 属性是可枚举的，es 原生的是不可枚举的，可通过 Object.defineProperty()来定义 constructor Person.prototype = &#123; // constructor: Person, // 不指定构造函数 say: function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;,&#125;;skyline.constructor === Person; // false 原型模式问题 属性和方法都共享，多个实例之间会相互影响 无法动态传递参数 组合构造与原型组合使用两者，构造函数模式用于实例属性，原型模式用于定义方法和共享属性 应用最广泛的模式，没有在一个地方使用构造函数与原型，对于封装性而言，不算最佳 动态原型实现动态原型模式是将原型与自有的信息都封装在构造函数中，通过在必要情况下初始化原型，实现组合使用构造函数与原型的优点。 实质就是通过检查某个应该存在的方法是否有效来决定是否初始化原型方法，if 语句检查初始化后应该存在的任何属性或方法，检查其中一个即可 function Person() &#123; this.name = \"skyline\"; if (typeof this.say != \"function\") &#123; Person.prototype.say = function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;; Person.prototype.sayHi = function () &#123; console.log(`Hi!$&#123;this.name&#125;`); &#125;; &#125;&#125;var skyline = new Person();skyline.say(); // My name is skyline 重写原型在构造函数中通过对象字面量重写原型 function Person() &#123; this.name = \"skyline\"; if (typeof this.say != \"function\") &#123; // 不能再构造函数中直接用对象字面量重写原型，重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系 Person.prototype = &#123; constructor: Person, // 指定构造函数 say: function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;, &#125;; &#125;&#125;var skyline = new Person();// 首次使用时，skyline的__proto__是指向默认产生的原型对象// 而不是由字面量创建的新原型对象，调用say将会找不到skyline.say(); // VM846:1 Uncaught TypeError: skyline.say is not a function 可以通过如下方式解决上述问题 function Person() &#123; this.name = \"skyline\"; if (typeof this.say != \"function\") &#123; // 不能再构造函数中直接用对象字面量重写原型，重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系 Person.prototype = &#123; constructor: Person, // 指定构造函数 say: function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;, &#125;; return new Person(); &#125;&#125; 寄生构造函数new 操作符并把使用的包装函数叫做构造函数之外，此模式与工厂模式并没有区别 创建的对象与构造函数之间毫无关系 function Person(name) &#123; var p = new Object(); p.name = name; return p;&#125;var me = new Person(\"skyline\");me.name; // 'skyline'me instanceof Person; // false 稳妥构造函数 稳妥对象是指没有公共属性，其方法不使用 this 的对象稳妥构造函数模式与寄生构造函数类似，有两点不同一是实例方法不引用 this，二是构造函数不使用 new。 如下代码中创建了一个稳妥对象，除了 say 没有其他方式可以访问传入构造函数的原始数据。保证了数据的安全性。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型 function Person(name) &#123; var p = new Object(); var age = 27; p.say = function () &#123; console.log(`My name is $&#123;name&#125; and I am $&#123;age&#125;`); &#125;; return p;&#125;var me = Person(\"skyline\"); BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 《JavaScript 高级程序设计》 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"康定周边2日","slug":"康定周边2日","date":"2022-01-20T07:47:16.000Z","updated":"2022-06-22T07:42:56.000Z","comments":true,"path":"康定周边2日.html","link":"","permalink":"http://www.skyline.show/康定周边2日.html","excerpt":"出发前准备 时间 物品清单 路线 主要地点 海螺沟 折多山 新都桥 BMW WARNING 出发前准备时间本路线适合于成都出发，周末游玩，2-3 天时间，2 天最好在周五晚出发。周五晚出发建议在泸定留宿，直接前往磨西古镇也可，需要多一个小时车程。注意 3 岁以下小朋友容易高反，带过去需要有人专职陪伴，备足氧气瓶，折多山上和去沿途有氧气卖。 物品清单","text":"出发前准备 时间 物品清单 路线 主要地点 海螺沟 折多山 新都桥 BMW WARNING 出发前准备时间本路线适合于成都出发，周末游玩，2-3 天时间，2 天最好在周五晚出发。周五晚出发建议在泸定留宿，直接前往磨西古镇也可，需要多一个小时车程。注意 3 岁以下小朋友容易高反，带过去需要有人专职陪伴，备足氧气瓶，折多山上和去沿途有氧气卖。 物品清单 氧气瓶血氧仪防滑链（依照去的时间定）墨镜巧克力葡萄糖鸭舌帽 路线推荐一天去一个选框中相关地点，标红为海拔高度，连线中为不堵时两地驾车时长。路线图采用 sketch 制作。路线图 主要地点海螺沟海螺沟需要在磨西古镇买景区票，然后统一坐大巴，40 分钟左右经过山路，可以选到 3 号营地下或继续坐车到 4 号营地。大巴可选 3 号或 4 号营地下车。看冰川需要在 4 号营地坐缆车。不看冰川可以直接去 3 号营地去月牙湖和冰川舌，4 号营地不坐缆车没有其他游乐设施，需要徒步到 3 号营地，通过人工步道一路穿过林地，风景一般，时间紧可不去 4 号营地。海螺沟前往康定的沿途风景也不错，建议白天出发，沿途非常容易起雾，能见度非常低，路上不时出现趴在上面休息的牛羊，或有拦路的大块石头，起雾驾车需要特别小心。 折多山 折多山山腰处运气好可以拍到云海。折多山上雪景不错，需要备好墨镜和帽子。 新都桥新都桥镇看叶子上可打卡，镇上几处可能不是最漂亮的地方。看叶子最美的地方，由新都桥导航去红海子，在 318 和 434 省道有一段村路，看叶子不错，或者在过新都桥大桥之前的岔路去另一条路往前几公里。新都桥驾车前往红海子的路上 434 省道海拔高的路段容易起雾，且比较弯曲，需要注意。镇上吃烤肉烤全羊等需要晚上。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Life","slug":"Life","permalink":"http://www.skyline.show/categories/Life/"}],"tags":[{"name":"Travel","slug":"Travel","permalink":"http://www.skyline.show/tags/Travel/"}]},{"title":"计算机字符储存与编码","slug":"计算机字符储存与编码","date":"2022-01-20T07:47:16.000Z","updated":"2023-02-11T02:22:20.000Z","comments":true,"path":"计算机字符储存与编码.html","link":"","permalink":"http://www.skyline.show/计算机字符储存与编码.html","excerpt":"数据存储单位 字符集 字符收集 Unicode 编码 给字符集编码 ASCII UTF BMW WARNING 数据存储单位计算机数据存储的常见单位为 bit byte word KB MB GB TB 等额。bit byte word 即位、字节、字。各单位的换算规则为： Bit = 1/0 （基本存储单位） Byte = 8 bits Word = 16, 32, 64 bits（取决于计算机位数） $1 kilobyte = 1 KB = 2^{10} bytes = 1024 bytes$ $1 Megabyte = 1 MB = 2^{20} bytes = 1,048,576 bytes$ $1 Gigabyte = 1 GB = 2^{30} bytes = 1,073,741,824 bytes$ 位是最小的存储单位，每一个位存储一个 1 位的二进制码。一个字节由 8 位组成。字通常为 16、32 或 64 个位组成，取决于计算机 CPU 一次性处理数据的位数，通常由寄存器决定。 字符集字符收集","text":"数据存储单位 字符集 字符收集 Unicode 编码 给字符集编码 ASCII UTF BMW WARNING 数据存储单位计算机数据存储的常见单位为 bit byte word KB MB GB TB 等额。bit byte word 即位、字节、字。各单位的换算规则为： Bit = 1/0 （基本存储单位） Byte = 8 bits Word = 16, 32, 64 bits（取决于计算机位数） $1 kilobyte = 1 KB = 2^{10} bytes = 1024 bytes$ $1 Megabyte = 1 MB = 2^{20} bytes = 1,048,576 bytes$ $1 Gigabyte = 1 GB = 2^{30} bytes = 1,073,741,824 bytes$ 位是最小的存储单位，每一个位存储一个 1 位的二进制码。一个字节由 8 位组成。字通常为 16、32 或 64 个位组成，取决于计算机 CPU 一次性处理数据的位数，通常由寄存器决定。 字符集字符收集 世界众多的文明创造除了庞大的文字，符号；这些符号可以是英语的基本字母和标点，汉语的文字和标点，或者是其他语言的相关字符。根据不同地区的使用需求，将不同的字符放在不同的集合形成众多的字符集。 常见的字符集有 Unicode、GBK、Big5 等。 字符集将需要的字符收集并规定了其中符号的二进制代码，供后续编码使用。这个二进制代码通常被称为码点（Code Point） UnicodeUnicode 是一个独立的字符集，每一个字符有一个对应的 Unicode 编号。目前的 Unicode 字符分为 17 组编排，每组称为平面（Plane），而每平面拥有 65536（即 2 的 16 方）个码点。 目前只用了少数平面第一平面的保留码点为 D800~0xDFFF，是特定为四字节的 UTF-16 编码预留的。 编码给字符集编码编码可以理解为选定字符集后，使用特定规则储存码点。 上文提到，字符集已经规定了每个字符对应的码点，那编码时直接将对应码点存储即可，为何同一字符集会有不同的编码规则，如 Unicode 对应的 UTF-8/UTF-16/UTF-32？ 为了传输和存储需要，同一字符集的对码点的编码的规则可以不一样。 可以采用为每个字符分配固定长度的内存的编码方案，即所有的码点都用固定位数存储，高位不足补零。定长的好处是多个字符形成的数据编码放在一起也可以很好地截断然后解码。但是，这种方式会造成码点小的字符内存空间的浪费。 也可以采用为每个字符分配尽量少的内存的方案，即码点对应实际需要占用的最小字节空间。这种方案节省了内存，但是由于每个字符存储长度不定，计算机不知道如何截断多个字符编码以解码。需要解决字符截断问题，然后才可以进行解码。 ASCII美国信息交换标准码（American Standard Code for Information Interchange）ASCII 码诞生于上世纪 60 年代，是最早的编码之一，共定义了 128 个字符（0-127），沿用至今。这 128 个字符被设计用用电脑的 7 位来存储，但在计算机中占用 1 字节（ 8 位）。这种 8 位 的 2 进制编码，最高位始终为 0，其他 7 位用来表示字符 ASCII 的所有字符码点都只需要一个字节来存储。 UTF UTF-8 Unicode 是一个字符集，如果全部按照 Unicode 中的码点来进行定长编码，程序定长截取字符，不会存在乱码问题。但是，对于全英文文本文件，用 Unicode 编码比 ASCII 编码需要多一倍的存储空间，在存储和传输上就十分不划算。 ​ 一种变长的编码方案由此诞生，该方案使用 1~6 个字节来存储码点，同时兼容 ASCII 码；​ 变长编码首先需要解决的问题就是字符截断问题。 UTF-8 使用如下规则：如果只有一个字节，那么最高的比特位为 0，其他位即实际的码点；这种方式对码点编码得到的记过 ASCII 规则一致，故其兼容 ASCII 码。如果是 n 字节，那么第一个字节前 n 个比特位的值为 1，n+1 为设为 0，剩下的字节（每 8 位）均以 10 开头，其他位为实际的码点。 单字节0xxxxxxx双字节[110x xxxx] [10xx xxxx]三字节[1110 xxxx] [10xx xxxx] [10xx xxxx]四字节[1111 0xxx] [10xx xxxx] [10xx xxxx] [10xx xxxx] 上述’x’的位置纯纯的就是实际的码点。如下示例：在 nodejs 进行测试 Buffer.from('我')// &lt;Buffer e6 88 91&gt;String.fromCodePoint(0x6211)// '我'String.fromCodePoint(25105)// '我''我' == '\\u6211'// truez'我'.charCodeAt(0)// 25105 可以看到，’我’在内存中存为： ;[0xe6][0x88][0x91] 其二进制形式： [1110 0110] [1000 1000] [1001 0001] 按照 utf8 编码，显然 1110 表示该码点使用 3 个字节；接下来的 2 个字节以 10 开头。去掉这些编码标识，“我”的实际二进制 0110 0010 0001 0001（Unicode 码点） ，十六进制 0x6211，十进制 25105 字符 UTF-8 二进制 UTF-8 对应十六进制 二进制 十进制 十六进制 我 [1110 0110] [1000 1000] [1001 0001] [0xe6] [0x88] [0x91] [0110 0010] [0001 0001] 25105 0x6211 ​ UTF-16 介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。UTF-16 的设计也存在读取问题，当遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读。UTF-16 将取基本平面预留段取两个码点组成新的码点，以解决读取问题；一个辅助平面的字符，会被拆成两个基本平面的字符表示。 具体来说，UTF-16 使用的解决规则如下：在基本平面（BMP），0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储，并且直接存储 Unicode 码点。在其他平面（辅助平面）对于 Unicode 码点范围在 10000~10FFFF 之间的字符，UTF-16 使用四个字节存储。具体来说就是：将字符码点的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，称为高位（H）；较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储，称为低位（L） UTF-16 最少使用两个字节来存储码点，故不兼容 ASCII。 UTF-32 一种固定长度的编码方案，不管字符码点大小，始终使用 4 个字节来存储；UTF-32 是固定长度的编码，始终占用 4 个字节，容纳 Unicode 字符集已有所有的 字符，故直接存储 Unicode 码点。 其转换规则简单直观，解码效率高，但其比较浪费空间，故一般不使用这种编码方式，其也不兼容 ASCII。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/字符集与编码.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Software","slug":"Software","permalink":"http://www.skyline.show/tags/Software/"}]},{"title":"ES类的使用","slug":"ES类的使用","date":"2022-01-20T07:47:16.000Z","updated":"2023-02-14T08:49:12.000Z","comments":true,"path":"ES类的使用.html","link":"","permalink":"http://www.skyline.show/ES类的使用.html","excerpt":"静态（类）、实例、原型属性与方法 ES5 ES6 属性访问结论 Class 原型方法语法糖 Class 中属性与方法的枚举性质 BMW WARNING 静态（类）、实例、原型属性与方法ES5Baby 类 //对象构造函数function Baby(name) &#123; var className = \"Baby\"; //实例属性，每个实例私有，在对象实例化后调用，实例属性在对象实力化后创建 this.name = name; this.weight = \"3kg\"; this.hello = function () &#123; console.log(this.name); console.log(this.msg()); //使用原型方法扩充的方法可以在类内部使用 console.log(this.sex); //使用原型方法扩充的属性可以在类内部使用 console.log(Baby.age, this.age); //静态属性调用时格式为[对象.静态属性] &#125;; //对象方法&#125;//类方法 (实际是静态方法直接调用)，只有类才能访问类方法，实例不能访问 ，在类方法中通过this只能访问类属性不能访问其他属性，即在本例中，Run方法只能访问到this.ageBaby.Run = function () &#123; console.log(\"跑起来！！！\");&#125;;//原型方法，如果原型方法当作静态方法直接调用时，this.name无法被调用Baby.prototype.msg = function () &#123; console.log(\"我叫：\" + this.name);&#125;;//类属性 在类的外部。公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用，只有类才能访问类属性，实例不能访问Baby.age = 20;//原型属性，所有实例共有，【this.属性】这种写法访问时，先会访问实例对象属性，没有实例对象属性就会访问原型属性 ，也可以当成公有静态属性使用【对象.prototype.原型属性。Baby.prototype.sex = \"男娃娃\"; 使用 //实例方法和原型方法需要实例化对象后才可以使var bob = new Baby(\"bob\");Baby.name;//\"Baby\" :每一个类都有一个基本的name属性bob.name;//\"bob\"Baby.weight;//undefinedbob.weight;//\"3kg\"Baby.hello();//Uncaught TypeError: Baby.hello is not a functionbob.hello();// bob// 我叫：bob// undefined :this.msg没有返回所以undefined// 男娃娃// 20 undefinedBaby.Run(); //跑起来！！！//类方法也是静态方法，可以直接使用 【对象.静态方法()】bob.run(); // TypeError: bob.run is not a functionBaby.msg();// Uncaught TypeError: Baby.msg is not a functionBaby.prototype.msg();// 我叫：undefined//原型方法当成静态方法使用时【对象.prototype.方法()】bob.msg();// 我叫：bob//原型方法必须实例化对象bob.age;// undefined//错误，公有静态属性只能使用 【对象.属性】调用Baby.age;// 20Baby.prototype.sex;// 男娃娃//原型属性当作静态属性使用时【对象.prototype.方法()】Baby.sex;// undefinedbob.sex;// 男娃娃 ES6","text":"静态（类）、实例、原型属性与方法 ES5 ES6 属性访问结论 Class 原型方法语法糖 Class 中属性与方法的枚举性质 BMW WARNING 静态（类）、实例、原型属性与方法ES5Baby 类 //对象构造函数function Baby(name) &#123; var className = \"Baby\"; //实例属性，每个实例私有，在对象实例化后调用，实例属性在对象实力化后创建 this.name = name; this.weight = \"3kg\"; this.hello = function () &#123; console.log(this.name); console.log(this.msg()); //使用原型方法扩充的方法可以在类内部使用 console.log(this.sex); //使用原型方法扩充的属性可以在类内部使用 console.log(Baby.age, this.age); //静态属性调用时格式为[对象.静态属性] &#125;; //对象方法&#125;//类方法 (实际是静态方法直接调用)，只有类才能访问类方法，实例不能访问 ，在类方法中通过this只能访问类属性不能访问其他属性，即在本例中，Run方法只能访问到this.ageBaby.Run = function () &#123; console.log(\"跑起来！！！\");&#125;;//原型方法，如果原型方法当作静态方法直接调用时，this.name无法被调用Baby.prototype.msg = function () &#123; console.log(\"我叫：\" + this.name);&#125;;//类属性 在类的外部。公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用，只有类才能访问类属性，实例不能访问Baby.age = 20;//原型属性，所有实例共有，【this.属性】这种写法访问时，先会访问实例对象属性，没有实例对象属性就会访问原型属性 ，也可以当成公有静态属性使用【对象.prototype.原型属性。Baby.prototype.sex = \"男娃娃\"; 使用 //实例方法和原型方法需要实例化对象后才可以使var bob = new Baby(\"bob\");Baby.name;//\"Baby\" :每一个类都有一个基本的name属性bob.name;//\"bob\"Baby.weight;//undefinedbob.weight;//\"3kg\"Baby.hello();//Uncaught TypeError: Baby.hello is not a functionbob.hello();// bob// 我叫：bob// undefined :this.msg没有返回所以undefined// 男娃娃// 20 undefinedBaby.Run(); //跑起来！！！//类方法也是静态方法，可以直接使用 【对象.静态方法()】bob.run(); // TypeError: bob.run is not a functionBaby.msg();// Uncaught TypeError: Baby.msg is not a functionBaby.prototype.msg();// 我叫：undefined//原型方法当成静态方法使用时【对象.prototype.方法()】bob.msg();// 我叫：bob//原型方法必须实例化对象bob.age;// undefined//错误，公有静态属性只能使用 【对象.属性】调用Baby.age;// 20Baby.prototype.sex;// 男娃娃//原型属性当作静态属性使用时【对象.prototype.方法()】Baby.sex;// undefinedbob.sex;// 男娃娃 ES6 Baby 类 class Baby &#123; //实例属性、方法 eat = \"meat\"; constructor(x, y) &#123; //实例属性、方法 this.firstName = x; this.lastName = y; this.say = function () &#123; return \"skyline\"; &#125;; &#125; //原型属性，使用存取器 get prop() &#123; return \"skyline getter\"; &#125; set prop(value) &#123; console.log(\"skyline setter: \" + value); &#125; //原型方法 toString() &#123; return \"(\" + this.firstName + \", \" + this.lastName + \")\"; &#125; //类方法 static hello() &#123; return \"hello skyline\"; &#125; static hi() &#123; return this.hello; //如果静态方法包含this关键字，这个this指的是类，而不是实例 &#125;&#125;//类属性，ES6 在当前阶段，Class 内部只有静态方法，没有静态属性，可以直接指定类（静态）属性Baby.age = 1; 属性访问结论不论是哪种方式创建对象，基本遵循以下结论： 静态属性方法，可以直接通过类进行访问 实例属性方法是需要创建实例对象进行访问 静态与实例之间的属性与方法不能互访 Class原型方法语法糖对于 ES6 的 Baby 类的 toString toString() &#123; return '(' + this.firstName + ', ' + this.lastName + ')';&#125; ES5 中可以看做是如下代码的语法糖 Point.prototype.toString = function () &#123; return \"(\" + this.firstName + \", \" + this.lastName + \")\";&#125;; Class 中属性与方法的枚举性质Reflect.ownKeys 可列出所有自有属性，不管枚举与否。Object.keys 可列出可枚举的自有属性。 实例属性可枚举 const skyline = new Baby(1, 1);Reflect.ownKeys(skyline);// (4) ['eat', 'firstName', 'lastName', 'say']Object.keys(skyline);// (4) ['eat', 'firstName', 'lastName', 'say'] 原型属性与方法不可枚举，这与 ES5 中原型属性方法不同，其是可枚举的。 Reflect.ownKeys(skyline.__proto__);// (3) ['constructor', 'prop', 'toString']Object.keys(skyline.__proto__);//[] BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"ES对象属性","slug":"ES对象属性","date":"2022-01-20T07:47:16.000Z","updated":"2023-02-15T07:41:13.000Z","comments":true,"path":"ES对象属性.html","link":"","permalink":"http://www.skyline.show/ES对象属性.html","excerpt":"属性描述符 属性分类 Enumerable Configurable 属性创建 直接创建 defineProperty Object.create 扩展、封印与冻结 preventExtensions seal freeze 属性的屏蔽、检测与遍历 属性屏蔽 属性检测 属性遍历 BMW WARNING 属性描述符属性分类 数据属性 Configurable Enumerable Writable Value 访问器属性 Configurable Enumerable Get Set Enumerable","text":"属性描述符 属性分类 Enumerable Configurable 属性创建 直接创建 defineProperty Object.create 扩展、封印与冻结 preventExtensions seal freeze 属性的屏蔽、检测与遍历 属性屏蔽 属性检测 属性遍历 BMW WARNING 属性描述符属性分类 数据属性 Configurable Enumerable Writable Value 访问器属性 Configurable Enumerable Get Set Enumerable Enumerable 表示能否枚举，常见 ConfigurableConfigurable 表示能否删除属性，能否修改某些属性描述符，能否将属性改为访问器(数据)属性。 configurable 一旦指定为 false，则 configurable、enumerable、value、get、set 将无法通过 Object.defineProperty()重新配置，删除对应的属性将不产生效果（严格模式导致错误），属性将不能转换（数据与访问器之间） configurable 一旦指定为 false,此时的 Writable 如果是 true 则可以修改为 false，但是不能从 false 改为 true（只关不开） configurable true，writable false 时，可以通过 Object.defineProperty()修改 value 的值，直接赋值无效；configurable false，writable true 时可以通过赋值直接修改 value 的值，通过 Object.defineProperty()指定 value 值将会报错。 数据属性能否重新直接赋值取决于 writable属性能否重新通过 defineProperty 定义属性描述与值以及被删除取决于 configurable 忽略 enumerable 为 false 属性的操作 属性创建直接创建直接建立的布尔型属性描述默认都是 true var a = &#123; c: 1 &#125;Object.getOwnPropertyDescriptor(a, 'c')// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;a.d = 2Object.getOwnPropertyDescriptor(a, 'd')//&#123;value: 2, writable: true, enumerable: true, configurable: true&#125; defineProperty通过 Object.defineProperty()来定义或者修改属性 Object.defineProperty()接受三个参数，分别是对象名，属性名，描述符对象。 数据属性描述符对象只接受 configurable、enumerable、writable、value 四种属性中的一个或多个；访问器属性描述符对象只接受 configurable、enumerable、get、set 四种属性中的一个或多个。 描述符对象不指定 configurable、enumerable、writable 时，他们的默认值是 false；不指定 value、get、set 时，默认值是 undefined。在使用 defineProperty 时通常需要代码直接指定布尔型描述全为 true var a = &#123;&#125;Object.defineProperty(a, 'name', &#123; value: 'skyline' &#125;)a // &#123;name: \"skyline\"&#125;a.name = 'lala'a // &#123;name: \"skyline\"&#125; 修改不生效Object.defineProperty(a, 'name', &#123; value: 'skyline', writable: true &#125;) // Uncaught TypeError: Cannot redefine property: name writeable是false，无法再改为trueObject.defineProperty(a, 'age', &#123; value: '18', configurable: true &#125;)a.age = 19 // 19 修改不生效a // &#123;name: \"skyline\", age: \"18\"&#125;Object.defineProperty(a, 'age', &#123; value: '18', writable: true &#125;)a.age = 19a // &#123;name: \"skyline\", age: 19&#125; 修改生效 Object.createObject.create 方法的第二个参数添加的对象属性，同样的，只指定 value 不指定其他将会导致 configurable、enumerable、writable 都是 false const obj = Object.create(&#123;&#125;, &#123; p: &#123; value: 1 &#125; &#125;)Object.values(obj) // []Object.getOwnPropertyDescriptor(obj, 'p')//&#123;value: 1, writable: false, enumerable: false, configurable: false&#125; Object.getOwnPropertyDescriptor(s) 查看属性描述符 扩展、封印与冻结preventExtensionsObject.preventExtensions()禁止扩展，即防止对象添加新的属性，Object.isExtensible()检查是否可扩展 const object1 = &#123;&#125;Object.preventExtensions(object1)try &#123; Object.defineProperty(object1, 'property1', &#123; value: 42, &#125;)&#125; catch (e) &#123; console.log(e) // expected output: TypeError: Cannot define property property1, object is not extensible&#125; sealObject.seal()封印对象，防止对象添加新的属性，且将所有属性的 Configurable 置为 false。Object.isSealed()检查是否被封印 freezeObject.freeze()冻结对象，防止对象添加新的属性，将所有属性的 Configurable 置为 false ，同时将数据属性的所有 writable 设置为 false，防止对象属性直接重新赋值。Object.isFrozen()检查是否被冻结。 被冻结的对象一定被封印了；被封印的对象一定不能扩展。 当一个被封印的对象所有自有（实例）属性的描述符 writable 改为 false 时，那么此时它也是被冻结的，通过 isFrozen 返回 true。 被冻结对象的访问器属性如果有 set 描述符，则它仍旧是可写的。 对比如下： $$Freeze \\space \\left{ \\begin{array}{lcl} [[extensible]]: false,\\ configurable: false, \\ writable: false \\ \\end{array} \\right.$$ $$seal \\space \\left{ \\begin{array}{lcl} [[extensible]]: false,\\ configurable: false, \\ \\end{array} \\right.$$ 属性的屏蔽、检测与遍历属性屏蔽原型属性指存在于原型链上的属性。实例中创建与原型中同名的属性，会屏蔽原型中的属性值。delete 可以删除实例中的属性，来重新暴露原型中的属性 属性检测hasOwnProperty()来获取自有（实例）属性 in 操作符来确定属性是否存在于实例属性与原型链中 属性检测不受枚举与否影响 Detection const obj = Object.create(&#123;&#125;, &#123; p: &#123; value: 1 &#125; &#125;)Object.values(obj) // []Object.getOwnPropertyDescriptor(obj, 'p')// &#123;value: 1, writable: false, enumerable: false, configurable: false&#125;'p' in obj // true'valueOf' in obj // trueobj.hasOwnProperty('p') // trueobj.hasOwnProperty('valueOf') // false 属性遍历for-in 语句遍历所有可枚举的自有（实例）和原型属性 Object.keys()只会收录自有可枚举属性名在数组中 Iteration const obj = Object.create(&#123;&#125;, &#123; p: &#123; value: 1 &#125; &#125;)Object.values(obj) // []Object.getOwnPropertyDescriptor(obj, 'p')// &#123;value: 1, writable: false, enumerable: false, configurable: false&#125;Object.getOwnPropertyNames(obj) //[\"p\"]Object.keys(obj) // [] 常见方法需要可枚举，非常见不限制枚举 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 《JavaScript 高级程序设计》 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES对象属性.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"Number相关基础操作","slug":"Number相关基础操作","date":"2022-01-20T07:47:16.000Z","updated":"2023-02-04T08:24:24.000Z","comments":true,"path":"Number相关基础操作.html","link":"","permalink":"http://www.skyline.show/Number相关基础操作.html","excerpt":"保留小数 四舍五入 不取舍 添加千位分隔符 toLocaleString 正则 BMW WARNING 保留小数四舍五入toFixed (2.123123123).toFixed(3); // 输出结果为 2.123(2.123923123).toFixed(3); // 输出结果为 2.124 toLocaleStringtoLocaleString 默认保留 3 位小数，且会产生千位分隔符 (12332.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '12,332.123923' 可通过 minimumFractionDigits，maximumFractionDigits 来指定保留参数的长度 (2.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '2.123923' 不取舍","text":"保留小数 四舍五入 不取舍 添加千位分隔符 toLocaleString 正则 BMW WARNING 保留小数四舍五入toFixed (2.123123123).toFixed(3); // 输出结果为 2.123(2.123923123).toFixed(3); // 输出结果为 2.124 toLocaleStringtoLocaleString 默认保留 3 位小数，且会产生千位分隔符 (12332.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '12,332.123923' 可通过 minimumFractionDigits，maximumFractionDigits 来指定保留参数的长度 (2.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '2.123923' 不取舍 Math.floor Math.floor(15.7784514 * 1000) / 1000; // \b输出结果为 15.778 添加千位分隔符toLocaleString通过 toLocaleString 很容易直接添加千位。 (1231234234234).toLocaleString(\"en-US\");// '1,231,234,234,234' (1231234234234).toLocaleString();// '1,231,234,234,234' toLocaleString 将字符本地串化，第一个参数为串化标准，默认为’en-US’。对于小数而言，其会四舍五入保留 3 位 正则(1231234234234 + \"\").replace(/(\\d)(?=(\\d&#123;3&#125;)+$)/g, \"$1,\");//'1,231,234,234,234' 设计正则解析 +匹配前面一个表达式 1 次或者多次。等价于{1,}。 x(?=y)匹配 x 仅仅当 x 后面跟着 y。这种叫做先行断言。 整个正则的意思为后面跟有三个或三的倍数个连续数字的数后面加上逗号 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Number相关基础操作.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"Vue基础使用","slug":"Vue基础使用","date":"2022-01-20T07:47:16.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Vue基础使用.html","link":"","permalink":"http://www.skyline.show/Vue基础使用.html","excerpt":"transition 基本使用 使用限制 设定元素背景 Vue Router model img 图片错误默认处理 extend 无法挂载错误 mixin 混入规则 组件挂载顺序 简述 总结 computed 简单说明 setter $watch 用法 注意 返回值 深度监听 资源引用 refs 使用 动态组件 \\$attrs 与\\$listeners 生命周期函数 监听 Vue.observable BMW WARNING transition基本使用将 transition name 命名后书写对应的类来自动生成的对应的类 &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;&lt;/transition&gt;&lt;style&gt; .fade-enter-active, .fade-leave-active &#123; transition: width 3s, opacity 1s; width: 100%; &#125; .fade-enter, .fade-leave-to &#123; width: 0; display: none; opacity: 0; &#125;&lt;/style&gt; 使用限制","text":"transition 基本使用 使用限制 设定元素背景 Vue Router model img 图片错误默认处理 extend 无法挂载错误 mixin 混入规则 组件挂载顺序 简述 总结 computed 简单说明 setter $watch 用法 注意 返回值 深度监听 资源引用 refs 使用 动态组件 \\$attrs 与\\$listeners 生命周期函数 监听 Vue.observable BMW WARNING transition基本使用将 transition name 命名后书写对应的类来自动生成的对应的类 &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;&lt;/transition&gt;&lt;style&gt; .fade-enter-active, .fade-leave-active &#123; transition: width 3s, opacity 1s; width: 100%; &#125; .fade-enter, .fade-leave-to &#123; width: 0; display: none; opacity: 0; &#125;&lt;/style&gt; 使用限制 transition 仅限用于如下组件上 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 对于 v-for 使用不会有任何效果， 需要改为使用 &lt;transition-group&gt;&lt;transition-group&gt; 元素作为多个元素/组件的过渡效果 &lt;transition-group name=\"fade\" tag=\"div\"&gt; &lt;div v-for=\"(item, index) in sources\" :key=\"index\"&gt; &lt;p&gt;&#123;&#123;item.skyline&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/transition-group&gt; 当使用 v-for 并对 key 值进行 index 绑定，会出现如下警告 Do not use v-for index as key on &lt;transition-group&gt; children, this is the same as not using keys. 处理方式如下： :key=\"index + 0\"//或使用 :key=\"item\" 设定元素背景在 Vue 文件中，设定元素的样式可在 CSS 中或 使用 JS 对象进行。涉及到背景时，如下所示：CSS background-image: url('~@/assets/imgs/img_bg.png'); JS :style=\"&#123; width: '100%', height: '100%', backgroundImage: 'url(' + require('@/assets/imgs/img_bg.jpg') + ')' // background: `center no-repeat url('@/assets/imgs/img_bg.jpg') ` //或使用此方式，注意url中的引号&#125;\" Vue Router modelVue 有两种路由模式: Hash History 默认情况下使用 Hash 模式。哈希模式利用 URL Hash 保证单页系统不进行页面重载。但是，传统 URL 的 Hash 中即常见的site#thing是来定位页面内容的，使用site/thing来跳转页面Hash 模式虽然保证了页面不跳转，但是’#’的出现破坏了传统规则。在一些项目中，会使用 History 模式。 const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) History 模式通过 history.pushState 防止路由重载。由于单页问题，History 在对应路由在服务器中位置并没有 HTML 入口文件，这需要我们进行额外的服务配置。若不进行配置，刷新页面会报错。Nginx 配置如下 location / &#123; try_files $uri $uri/ /index.html;&#125; 其余服务端配置参考https://router.vuejs.org/guide/essentials/history-mode.html#example-server-configurations img 图片错误默认处理&lt;img width=\"98\" height=\"112\" :src=\"m.imgAddr || '~@img/suspect.png'\" @error=\"slotimg\" alt/&gt;let defaultImg = require(\"@img/suspect.png\");methods: &#123; slotimg(event) &#123; console.log(\"HotFocus.vue第211行:::err img\"); let img = event.srcElement; img.src = defaultImg; img.onerror = null; //防止闪图 &#125;,&#125; html 原生是 οnerrοr 来监听图片渲染错误事件 extend用于创建 Vue 组件的子类 Vue.extend var button = Vue.extend(FullScreenButton)var b = new button()b.$mount() 无法挂载错误 出现这种错误是由于首字母大写导致，具体缘由待查，如下图中注释所示 mixin混入规则 data 在混入时会进行递归合并，如果两个属性发生冲突，则以组件自身为主 生命周期钩子函数 混入时会将同名钩子函数加入到一个数组中，会先按照数组顺序依次执行执行混入对象的同名钩子函数，再执行本组件的。 组件挂载顺序简述 vue 子组件与父组件之间，父组件首先加载完成（beforeCreate-&gt;beforeMount 率先执行）之后是子组件加载，最后由子向父组件挂载 要在所有组件生命周期完成后执行某个函数，只需要在父组件加入 nextTick 即可 vue 代码结构如下 &lt;template&gt; &lt;div class=&apos;papa&apos;&gt; &lt;c1&gt;&lt;/c1&gt; &lt;c2&gt;&lt;/c2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;PaPa&apos;, components: &#123; c1, c2 &#125;, beforeCreate() &#123; console.log(&apos;papa beforeCreate&apos;) &#125;, created() &#123; console.log(&apos;papa created&apos;) &#125;, beforeMount() &#123; console.log(&apos;papa beforeMount&apos;) &#125;, mounted()&#123; console.log(&apos;papa mounted&apos;) this.$nextTick(() =&gt; &#123; console.log(&apos;papa nextTick&apos;) &#125;) setTimeout(() =&gt; &#123; console.log(&apos;papa setTimeout&apos;) &#125;) &#125;&#125;&lt;/script&gt; 打印结果如下： 其中 nextTick 与 setTimeout 在生命周期的位置无关 总结加载渲染过程 父 beforeCreate=&gt;父 created=&gt;父 beforeMount=&gt;子 beforeCreate=&gt;子 created=&gt;子 beforeMount=&gt;子 mounted=&gt;父 mounted 子组件更新过程 父 beforeUpdate=&gt;子 beforeUpdate=&gt;子 updated=&gt;父 updated 父组件更新过程 父 beforeUpdate=&gt;父 updated 销毁过程 父 beforeDestroy=&gt;子 beforeDestroy=&gt;子 destoryed=&gt;父 destoryed computed简单说明计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要依赖还没有发生改变，多次访问计算属性会立即返回之前的计算结果，这一定程度上节约了开销。 settersetter 需要注意的是，如果需要书写 set 函数，一般需要变更计算属性相关依赖 computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; $watch用法观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代，或写在 computed 中，监听 computed 注意第一参数 $watch 函数接受的第一个参数是属性名的字符串，一定要用引号，不能用变量来获取 data() &#123; return &#123; itemList: [] &#125; &#125;, mounted() &#123; this.$nextTick(() =&gt; &#123; this.$watch('itemList', function(n, v) &#123;//不能写成this.itemList或直接写itemList this.mainPostList = _.takeWhile(n,function(o) &#123; return o.id == 18 &#125;) &#125;) &#125;) &#125; 返回值$watch 返回一个取消观察函数，用来停止触发回调 var unwatch = vm.$watch('a', cb) // 之后取消观察unwatch() 深度监听为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 vm.$watch(&apos;someObject&apos;, callback, &#123; deep: true&#125;) 在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 资源引用vue-html-loader 和 css-loader 认为没带根的路径为相对路径。官方为了让其看起来像模块路径, 加上了~前缀标志，表示让其从 webpack 配置中 alias 的相应项目取值，不加将找不到相应模块。 //webpackresolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), '@assets': resolve('src/assets'), 'static': resolve('static'), &#125;&#125;//less使用&lt;style lang=\"less\"&gt; @import '~vux/src/styles/reset.less';&lt;/style&gt;//dom使用&lt;img class=\"logo\" src=\"~assets/logo.png\"&gt; refs 使用 $refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 各生命周期中，只有 updated 阶段则是完成了数据更新到 DOM 的阶段,但当页面 DOM 频繁更新，需考虑放在此处的合法性 动态组件当 v-if/v-else-if 存在较多情况且其内部渲染的组件较大时，考虑使用动态组件，例如 tab 标签下的内容 示例 1 &lt;component v-bind:is='currentTabComponent'&gt;&lt;/component&gt; 示例 2 export const menus = [ &#123; name: \"业务管理\", icon: \"el-icon-document-copy\", id: \"form\", children: [&#123; name: \"业务注册\", icon: \"el-icon-document\", id: \"formList\", to: \"formList\" &#125; ] &#125;, &#123; name: \"数据源注册\", icon: \"el-icon-finance\", id: \"dataSource\", to: \"dataSource\" &#125;,]&lt;el-menu ref=\"elMenu\" class=\"el-menu-vertical\" :default-active=\"active\" :collapse=\"isCollapse\" :router=\"true\"&gt; &lt;component v-bind:is=\"m.children ? 'ElSubmenu' : 'ElMenuItem'\" v-for=\"(m, i) in menus\" :index=\"m.to\" :key=\"i\" &gt; &lt;template slot=\"title\"&gt; &lt;i :class=\"m.icon\"&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;m.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group v-if=\"m.children\"&gt; &lt;el-menu-item v-for=\"(c, i) in (m.children || [])\" :index=\"c.to\" :key=\"i\"&gt; &lt;template slot=\"title\"&gt; &lt;i :class=\"c.icon\"&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;c.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/component&gt;&lt;/el-menu&gt; \\$attrs 与\\$listeners \\$attrs 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外) $listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。 即接收除了 props 声明外的所有绑定属性（class、style 除外），$listeners包含了父作用域中的事件监听器 在创建高级别的组件时，通过 v-on=”$listeners“，与 v-bind=”$attrs” 将值传入内部组件。 示例 skylline-dialog.vue &lt;el-dialog :visible.sync=\"show\" v-bind=\"$attrs\" v-on=\"$listeners\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;template #footer&gt; &lt;slot name=\"footer\"&gt; &lt;span&gt; &lt;el-button&gt;取 消&lt;/el-button&gt; &lt;el-button&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/slot&gt; &lt;/template&gt;&lt;/el-dialog&gt; 在一个业务系统中所有弹窗都需要两个按钮，为了减少每次使用弹窗都写按钮，我们将弹窗组件进行二次封装。 通过attrs 与listeners，我们避免了 props 及$emit 对属性与事件逐个添加。 &lt;skyline-dialog :visible.sync=\"show\" title=\"测试\" @opened=\"doSth\"&gt; 这是一段内容&lt;/skyline-dialog&gt; 生命周期函数监听可以通过$on 监听 this.on(&#39;hook:updated&#39;, () =&gt; {}) 父组件监听 ` Vue.observableVue.observable 会让一个对象成为响应式的。 const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h( 'button', &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;, &#125;, &#125;, `count is: $&#123;state.count&#125;` ) &#125;,&#125; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/tags/Vue/"}]},{"title":"编程程序设计","slug":"编程程序设计","date":"2022-01-20T07:47:16.000Z","updated":"2023-02-11T02:22:20.000Z","comments":true,"path":"编程程序设计.html","link":"","permalink":"http://www.skyline.show/编程程序设计.html","excerpt":"面向对象（Object Oriented Programming） 三大基本特性 五大基本原则 优缺点 面向过程 (Procedure Oriented) BMW WARNING 面向对象（Object Oriented Programming）三大基本特性面向对象编程就是在编程过程中将客观事物抽象化，在抽象的类中提供数据和操作方法，在有不同的情形和需求下通过继承和多态来实现复用与扩展。 封装客观事物封装成抽象的类。 继承指可以让某个类型的对象获得另一个类型的对象的属性的方法。 多态多态，是指类实例的相同方法在不同情形有不同执行逻辑。 五大基本原则","text":"面向对象（Object Oriented Programming） 三大基本特性 五大基本原则 优缺点 面向过程 (Procedure Oriented) BMW WARNING 面向对象（Object Oriented Programming）三大基本特性面向对象编程就是在编程过程中将客观事物抽象化，在抽象的类中提供数据和操作方法，在有不同的情形和需求下通过继承和多态来实现复用与扩展。 封装客观事物封装成抽象的类。 继承指可以让某个类型的对象获得另一个类型的对象的属性的方法。 多态多态，是指类实例的相同方法在不同情形有不同执行逻辑。 五大基本原则 单一职责原则 SRP(Single Responsibility Principle)是指一个类的功能要单一，不能包罗万象。如同社会上职业拆分，各司其职。 开放封闭原则 OCP(Open－Close Principle)一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。 里式替换原则 LSP(the Liskov Substitution Principle LSP)子类应当可以替换父类并出现在父类能够出现的任何地方。 依赖倒置原则 DIP(the Dependency Inversion Principle DIP)具体依赖抽象，上层依赖下层。 接口分离原则 ISP(the Interface Segregation Principle ISP)模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。 优缺点 优点实现重用、扩展等目标。易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。 缺点性能比面向过程低。 面向过程 (Procedure Oriented)是一种以过程为中心的编程思想，是以什么正在发生为主要目标进行编程。面向对象的编程方式使得每一个类都只做一件事。面向过程会让一个类越来越全能，就像一个管家一样做了所有的事。 优点性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。 缺点没有面向对象易维护、易复用、易扩展 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://zhuanlan.zhihu.com/p/75265007​ Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/编程程序设计.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Software","slug":"Software","permalink":"http://www.skyline.show/tags/Software/"}]},{"title":"Nginx基础","slug":"Nginx基础","date":"2022-01-20T07:47:15.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"Nginx基础.html","link":"","permalink":"http://www.skyline.show/Nginx基础.html","excerpt":"location 基础使用 URL-match modifier proxy_pass 简述 URI 斜杠（/）问题 \\$uri \\$request_uri BMW WARNING location基础使用location 位于 server 下或位于另一个 location 中，基本使用如下 location [modifier] [URL-match] &#123; ...&#125; URL-match","text":"location 基础使用 URL-match modifier proxy_pass 简述 URI 斜杠（/）问题 \\$uri \\$request_uri BMW WARNING location基础使用location 位于 server 下或位于另一个 location 中，基本使用如下 location [modifier] [URL-match] &#123; ...&#125; URL-match 匹配所有路径 location / &#123;&#125; 优先级最低，所有都不匹配时，才会命中 modifierURI 这里指 URL 除了 server:port 的部分。 命中优先级优先级由上依次降低。 modifier desc example = exact (精确匹配) location = /site ^~ priority prefix (优先字符) location ^~ /site ~ case sensitive regex (大小写敏感正则) location ~ /site ~* case insensitive regex(忽略大小写) location ~* /site (none) prefix(字符匹配，无修饰符，由 URI 头字符开始匹配) location /site 在如下网址可进行匹配测试 https://nginx.viraptor.info/ ^~ 与(none)都 进行字符匹配（非正则），^~ 相对于(none) ，提高了命中优先级。 典型示例 示例 1 location ^~ /file/* &#123; proxy_pass http://bbb.com/;&#125; ^~ 进行字符匹配http://domain2.com/file/* 可以命中http://domain2.com/file/1 不能命中 示例 2 location ~ /file/* &#123; proxy_pass http://bbb.com/;&#125;location ^~ /file/ &#123; proxy_pass http://bbb.com/;&#125; http://domain2.com/file/1 根据优先级命中^~ /file/ proxy_pass简述proxy_pass 通常位于 location 下，用于接口转发。 URI一般把 server:port 后的部分叫做 URI，proxy_pass 在其后加不加 URI 表现完全不同。location 非正则匹配时，对于 proxy_pass 有如下规则：proxy_pass 有 URI替换请求中匹配的 URI 并替换成 proxy_pass 中的 URI 并向上游服务转发。 location /file &#123; proxy_pass http://bbb.com/src;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com/src/search location /file &#123; proxy_pass http://bbb.com/;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com//search proxy_pass 无 URI保留请求 URI 并将其转发到上游服务 location /file &#123; proxy_pass http://bbb.com;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com/file/search location 为正则匹配时，由于 nginx 不知道替换哪些字符，proxy_pass 的 URI 不起作用，保留原 URI，转发到上上游服务 location ~ /file &#123; proxy_pass http://bbb.com/src;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com/file/search 斜杠（/）问题location 正则匹配时，不需要考虑 proxy_pass 的 URIlocation 非正则匹配时，当 proxy_pass 有 URI 时，需要注意 URI 的尾斜杠，具体表现为如下 location proxy_pass Request Received by upstream /file/ http://bbb.com/src/ /file/search?name=baz /src/search?name=baz /file/ http://bbb.com/src /file/search?name=baz /srcsearch?name=baz /file http://bbb.com/src/ /file/search?name=baz /src//search?name=baz /file http://bbb.com/src /file/search?name=baz /src/search?name=baz /file http://bbb.com/src /filesearch?name=baz /srcsearch?name=baz ~ /file/ http://bbb.com/src/[^1] /file/search?name=baz /file/search?name=baz ~ /file/search/(.*)$ http://bbb.com/src?name=$1[^1] /file/search/baz /src?name=baz ~ /file/ http://bbb.com /file/search?name=baz /file/search?name=baz location 正则匹配保留 Request 原始 URI非正则（前缀）匹配时，proxy_pass 有 URI 直接用 该 URI 替换 Request 中 URI 与 location 对应的字符，无 URI 则保留 Request 原始 URI 总之一句话location 采用字符前缀匹配时 proxy_pass 中的 URI 替换原始 URI [^1]: 较新版的 nginx 不支持正则中的 proxy_pass 有 URI(指纯字符 URI，经过测试，包含变量如$1等时可以)，会报错。&quot;proxy_pass&quot; cannot have URI part in location given by regular expression, or inside named location, or inside &quot;if&quot; statement, or inside &quot;limit_except&quot; block \\$uri \\$request_uri要同时保留 location 与 proxy_pass 的 URI 需要使用前缀匹配的同时用到 $uri 或$request_uri两者区别是$uri 不会保留请求中的路由参数具体如下 location proxy_pass Request Received by upstream /file/ http://bbb.com/src$uri /file/search?name=baz /src/file/search /file/ http://bbb.com/src$request_uri /file/search?name=baz /src/file/search?name=baz 注意$uri与$request_uri 自带头斜杠 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://nginx.viraptor.info/ https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.skyline.show/tags/Nginx/"}]},{"title":"黑群晖安装","slug":"黑群晖安装","date":"2022-01-20T07:47:15.000Z","updated":"2022-06-22T07:43:01.000Z","comments":true,"path":"黑群晖安装.html","link":"","permalink":"http://www.skyline.show/黑群晖安装.html","excerpt":"硬件准备 Nas 主机 u 盘 电脑 软件准备 系统选择 相关软件 引导盘准备 获取 VID 与 PID 替换 VID 与 PID 格式化硬盘 引导盘制作 安装系统 Nas 进入 BMW WARNING 硬件准备 硬件 要求 Nas 主机 Intel CPU u 盘 &gt; 50M 电脑 Windows 系统 键鼠 进 BIOS 等 硬盘 大大的好 Nas 主机黑群晖对主机的要求不是很高，不需要硬解软路由+移动硬盘都可运行。主机一般推荐使用 10 代以下的 Intel CPU.新代 Intel 与 AMD 等其他 CPU 主机核显硬解不友好，视硬解需求而定。 u 盘","text":"硬件准备 Nas 主机 u 盘 电脑 软件准备 系统选择 相关软件 引导盘准备 获取 VID 与 PID 替换 VID 与 PID 格式化硬盘 引导盘制作 安装系统 Nas 进入 BMW WARNING 硬件准备 硬件 要求 Nas 主机 Intel CPU u 盘 &gt; 50M 电脑 Windows 系统 键鼠 进 BIOS 等 硬盘 大大的好 Nas 主机黑群晖对主机的要求不是很高，不需要硬解软路由+移动硬盘都可运行。主机一般推荐使用 10 代以下的 Intel CPU.新代 Intel 与 AMD 等其他 CPU 主机核显硬解不友好，视硬解需求而定。 u 盘 U 盘用于做系统引导，引导程序的大小为 50M。大于这个容量即可，现在 U 盘基本都满足要求。 电脑需要一台 windows 电脑来安装系统引导程序。键鼠需要插入 Nas 主机操作 BIOS。 软件准备系统选择黑群晖的系统目前主流使用的有三个版本 DS3615xs DS3617xs DS918+ 个人一般使用 DS918+ 。其他两个为企业级用户设计，系统没有显卡驱动，不支持硬解功能。 黑群晖系统分为两部分：引导文件.img系统文件.pat 相关软件在 Windows 电脑上安装如下软件 软件 作用 ChipEasy 芯片无忧 查找 U 盘的 VID 和 PID DiskGenius 修改 grub.cfg 配置 Win32 Disk Imager 写入镜像 引导盘准备获取 VID 与 PID插入 U 盘，打开 ChipEasy 芯片无忧，选择对应 U 盘，获取 VID 与 PID Logical drive : E:\\ Capacity: 29.4GDevice ID : VID = 17EF PID = 38ACDevice SN : SCY0000000001464Device version : 1100 位于信息中的第二行。 关闭 ChipEasy 替换 VID 与 PID打开 DiskGenius，选择“硬盘”-“打开虚拟硬盘文件” 选择 引导文件.img选中 ESP(0)/grub复制 grub.cfg 到桌面 用记事本或其他编辑器打开替换之前获取的 IDsn 与 mac1 是洗白用的，半白网上可搜索对应 SN,替换后图片可看缩略图。全白可在某某宝获取，替换后可用群晖的 QC 实现外网访问。 修改完成后拖动回到 DiskGenius 刚才对应的目录下，替换原始文件。 格式化硬盘写入引导需要 U 盘只有一个分区，否则有错误提示，写入引导最好先进行如下格式化操作。删除硬盘分区重建硬盘分区 保存更改，在弹窗中点击是，进行 U 盘格式化退出 DiskGenius 引导盘制作打开 win32diskimager 选择修改好的 U 盘与 img 文件 写入完成后 U 盘消失，引导盘制作成功 安装系统Nas 进入U 盘插入 Nas 主机，BIOS 设置 U 盘启动。选择默认第一个选项，回车如果出席一下画面，说明引导成功。 在电脑端输入http://find.synology.com进行访问，或使用synology-assistant BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"Nas","slug":"Nas","permalink":"http://www.skyline.show/tags/Nas/"}]},{"title":"Nginx常见问题汇总","slug":"Nginx常见问题汇总","date":"2022-01-20T07:47:15.000Z","updated":"2022-06-22T07:43:00.000Z","comments":true,"path":"Nginx常见问题汇总.html","link":"","permalink":"http://www.skyline.show/Nginx常见问题汇总.html","excerpt":"proxy_pass 代理接口不能访问 问题描述 配置 页面刷新不能进入 BMW WARNING proxy_pass 代理接口不能访问问题描述客户端访问接口，发起请求http://aaa.com/file/123.png 真实接口地址为http://bbb.com/123.png 配置","text":"proxy_pass 代理接口不能访问 问题描述 配置 页面刷新不能进入 BMW WARNING proxy_pass 代理接口不能访问问题描述客户端访问接口，发起请求http://aaa.com/file/123.png 真实接口地址为http://bbb.com/123.png 配置 检查配置，正确的配置如下 location ^~ /file/ &#123; proxy_pass http://bbb.com/;&#125; 检查地址，注意后缀’/‘都不能去掉。一般把 server:port 后的部分叫做 URI，proxy_pass 在其后加不加 URI 表现完全不同。location 非正则匹配时，proxy_pass 有 URI 直接用 URI 把 location 对应的字符替换，无 URI 则直接替换 server:port详细解析查看Nginx 基础 页面刷新不能进入检查页面的路由模式。特别是在 Vue 项目中，具体查看 HTML5 History Modevue 默认的是 hash 路由模式，使用此种模式，页面路由变化时，并不会重载页面在配置网站根文件的位置加入try_files $uri $uri/ /index.html;一般如下配置 location ^~ /skyline&#123; alias /data/wwwroot/skyline/dist; index index.html index.htm; try_files $uri $uri/ /index.html;&#125; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"Nginx","slug":"Nginx","permalink":"http://www.skyline.show/tags/Nginx/"}]},{"title":"VSCode相关问题汇总","slug":"VSCode相关问题汇总","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"VSCode相关问题汇总.html","link":"","permalink":"http://www.skyline.show/VSCode相关问题汇总.html","excerpt":"","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 VSCode 相关问题汇总Snippetsmarkdown 文件 Snippets 不生效问题描述通过 File -&gt; Preferences -&gt; User Snippets -&gt; Markdown写相关代码块如下markdown.json &#123; // Place your snippets for markdown here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: \"JS code block\": &#123; // \"scope\": \"md,markdown\", \"prefix\": \":cjs\", \"body\": [ \"```$&#123;1:js&#125;\", \"$2\", \"```\" ], \"description\": \"JS code block\" &#125;, \"PY code block\": &#123; // \"scope\": \"md,markdown\", \"prefix\": \":cpy\", \"body\": [ \"```$&#123;1:python&#125;\", \"$2\", \"```\" ], \"description\": \"PY code block\" &#125;&#125; 在 markdown 文件中敲击:cjs 不自动提示。解决方案尝试 CTRL + Space 强制开启。在用户配置setting.json中添加如下配置项 \"[markdown]\": &#123; \"editor.quickSuggestions\": true&#125;","categories":[],"tags":[]},{"title":"黑群晖常见问题","slug":"黑群晖常见问题","date":"2022-01-20T07:47:15.000Z","updated":"2022-06-03T09:41:58.000Z","comments":true,"path":"黑群晖常见问题.html","link":"","permalink":"http://www.skyline.show/黑群晖常见问题.html","excerpt":"","text":"黑群晖搜索不到 IP 网络联通检查 网卡驱动问题 SSD 缓存问题 Moments 人物、主题无照片 群晖添加第三方社群套件源显示无效的位置 Jellufin /Plex 扫描不出影片 黑群晖硬件转码 黑群晖搜索不到 IP网络联通检查主板网口灯检查检查主板网口灯，绿灯常亮说明网络连接成功，黄灯闪烁说明有流量传输。若绿灯亮，进入下一步。 网卡驱动问题检查网卡配置，黑群晖默认不支持 2.5G 以及万兆网卡，需要替换引导中的网卡驱动文件。直接 GoogleDS918+ 6.23 &quot;0.13.3&quot;找到 DS918-6.23_1.04b 的扩展驱动 0.13.3.zip解压得到进行两个文件extra.lzma extra2.lzma然后替换[^1]。用 DiskGenius 打开启动 U 盘。在左侧目录下可以看到一个 分区(1)，右键选择”挂载到 windows”。然后选择确定之后。可以发现这个分区出现在文件管理那边。用上述解压得到的文件替换分区里的文件即可。然后退出 U 盘，重新启动，就能支持 2.5G 网卡了[^1]:https://post.smzdm.com/p/aoxd6697/ SSD 缓存问题不打补丁的情况下，黑群晖默认不识别 SSDSSD 补丁如下版本 | 补丁 | 操作— | — | —6.22 | libNVMEpatch.sh | 将 libNVMEpatch.sh 移动到/usr/local/etc/rc.d/ 下 sudo 赋读写执行权限 sudo chmod 755 libNVMEpatch.sh6.23 | libsynonvme.so.1 | 将 libNVMEpatch.sh 移动到/usr/local/etc/rc.d/ 下 sudo 赋读写执行权限 sudo chmod 755 libNVMEpatch.sh 上述操作需要先远程 ssh user@ip ，操作完成后退出重启即可[^2][^2]:https://wp.gxnas.com/6010.html Moments 人物、主题无照片安装 Moments 后人物与主题无法智能识别，进入后显示还有 xxx 张照片待发现。停用 Moments进入 /var/packages/SynologyMoments/target/usr/lib 目录下备份 libsynophoto-plugin-detection.so mv ./libsynophoto-plugin-detection.so ./libsynophoto-plugin-detection.so.bak libsynophoto-plugin-detection.so将下载的新文件放在 /var/packages/SynologyMoments/target/usr/lib 下，对全部用户赋完全权限（777）或对 SynologyMoments 赋控制权限（755）。开启 moments，重建索引。 群晖添加第三方社群套件源显示无效的位置在套件设置常规中的信任层级允许任何发行者。之后在套件来源中添加 http://packages.synocommunity.com显示无效地址。出现问题的原因是在 DSM6 非最新版本的系统证书过期。在控制面板 Terminal &amp; SNMP 打开允许 SSH 连接。用 SecureCRT 等工具远程连接。输入如下命令 sudo mv /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt.bak &amp;&amp; sudo curl -Lko /etc/ssl/certs/ca-certificates.crt https://curl.se/ca/cacert.pem 执行完毕后重新添加源。其他常用的套件源 http://packages.synocommunity.comhttp://packages.pcloadletter.co.ukhttp://www.cphub.nethttp://synology.sysco.chhttp://packages.quadrat4.dehttp://synology.acmenet.ruhttp://cytec.us/spkhttp://spk.naefmarco.ch/spkrepo/packages/http://spk.nas-mirror.de/spkrepo/packageshttp://spk.unzureichende.info/http://packages.synocommunity.com/?beta=1 Jellufin /Plex 扫描不出影片这是由于指定的文件夹没有开发读写权限。对于 Plex，安装时会自动创建 Plex 用户，需要为其赋权。Jellufin 三方套件版会创建 sc-jellyfin 用户， 尝试赋权。若都不行，尝试将扫描目录对所有人赋读写权限。 黑群晖硬件转码https://wp.gxnas.com/7952.html","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"Nas","slug":"Nas","permalink":"http://www.skyline.show/tags/Nas/"}]},{"title":"VIM基本使用","slug":"VIM基本使用","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"VIM基本使用.html","link":"","permalink":"http://www.skyline.show/VIM基本使用.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 VIM 基本使用 VIM 基本使用 模式 正常模式 (Normal-mode) 插入模式 (Insert-mode) 命令模式 (Command-mode) 可视模式 (Visual-mode) .vimrc inoremap 模式正常模式 (Normal-mode)正常模式一般用于浏览文件，同时包括一些复制、粘贴、删除等快捷操作。其他模式通常通过 ESC 键返回正常模式。 操作 按键 EN 撤销 u undo 插入模式 (Insert-mode)用于编辑文档，直接输入内容。 命令模式 (Command-mode)输入:或/进入命令模式命令模式用于执行 VIM 提供的相关指令。 命令 按键 EN 移动 :m move 设定 :set :m:m 多用于换行操作，当前行的位置为 0.具体使用如下 :m -2 移动到-2 行的位置(当前行与上一行互换) :m +1 移动到+1 行的位置(当前行与下一行互换) :m 0 移动到首行的位置 :m $ 移动到尾行的位置 :set:set number 显示行索引 可视模式 (Visual-mode)","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 VIM 基本使用 VIM 基本使用 模式 正常模式 (Normal-mode) 插入模式 (Insert-mode) 命令模式 (Command-mode) 可视模式 (Visual-mode) .vimrc inoremap 模式正常模式 (Normal-mode)正常模式一般用于浏览文件，同时包括一些复制、粘贴、删除等快捷操作。其他模式通常通过 ESC 键返回正常模式。 操作 按键 EN 撤销 u undo 插入模式 (Insert-mode)用于编辑文档，直接输入内容。 命令模式 (Command-mode)输入:或/进入命令模式命令模式用于执行 VIM 提供的相关指令。 命令 按键 EN 移动 :m move 设定 :set :m:m 多用于换行操作，当前行的位置为 0.具体使用如下 :m -2 移动到-2 行的位置(当前行与上一行互换) :m +1 移动到+1 行的位置(当前行与下一行互换) :m 0 移动到首行的位置 :m $ 移动到尾行的位置 :set:set number 显示行索引 可视模式 (Visual-mode) 在正常模式按下 v, V, ^ + v，可以进入可视模式可视模式下执行文本选择操作。 .vimrcinoremap按键映射 inoremap zz","categories":[],"tags":[]},{"title":"MacOS应用清单","slug":"MacOS应用清单","date":"2022-01-20T07:47:15.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"MacOS应用清单.html","link":"","permalink":"http://www.skyline.show/MacOS应用清单.html","excerpt":"开发 学习 效率 汇总 barrier 娱乐 BMW WARNING 开发学习效率","text":"开发 学习 效率 汇总 barrier 娱乐 BMW WARNING 开发学习效率 汇总 APP DESC Free Web Sharemouse 跨端键鼠共用工具 trial https://github.com/debauchee/barrier Synergy 跨端键鼠共用工具 false https://github.com/debauchee/barrier barrier 基于 Synergy-core 1.9 的开源跨端键鼠共用工具 true https://github.com/debauchee/barrier shortery shortcuts 自动化触发工具 pro https://www.lgerckens.de/shortery/ barrierbarrier 是一款基于 Synergy-core 1.9 的开源跨端键鼠共用工具，拥有 Synergy 基本的跨平台共享键鼠，复制粘贴等基础功能。其他类似的软件还有 Sharemouse 和 Synergy。Synergy 目前已闭源收费，功能上与 barrier 差距不大，Synergy 与 barrier 采用主副机设定。只有主机的键鼠可共享，其他设备的键鼠不能共享试用。Sharemouse 相比，所有键鼠都可共享，但是，Sharemouse 提供的免费试用版本，试用版只支持两台电脑，且两台电脑各自只能有一台内置显示器。目前了解到的类似软件还有， Mouse without Borders Input Director 未安装试用验证。在 macOS 系统版本 12.3+以后，已自动支持苹果设备间共用键鼠。 娱乐BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"MacOS","slug":"MacOS","permalink":"http://www.skyline.show/tags/MacOS/"}]},{"title":"MacOS基本操作","slug":"MacOS基本操作","date":"2022-01-20T07:47:15.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"MacOS基本操作.html","link":"","permalink":"http://www.skyline.show/MacOS基本操作.html","excerpt":"Macos Beta 系统更新开启 网络磁盘映射 剪切（移动） 常规 快捷键 直接删除文件 修改终端用户名 启用 SSD 的 TRIM 支持 关闭 SIP 设定文件默认打开方式 单文件 同类文件 打开允许未知来源 app 选项 设定快捷打开程序快捷键 设置 automator 任务 设置程序打开快捷键 Macos Beta 系统更新开启在apple beta 地址上登录https://beta.apple.com 在如下网站下载 MacOS Public Beta Access Utility工具注意开启前在Time Mechine中进行系统备份下载工具安装后即可开启。 网络磁盘映射在 finder 下操作 ⌘ + k在弹出框中输入网络共享服务地址一般有 Samba 或 AFP 等方式共享服务常见地址如下 afp://192.168.2.20smb://192.168.2.20 剪切（移动）","text":"Macos Beta 系统更新开启 网络磁盘映射 剪切（移动） 常规 快捷键 直接删除文件 修改终端用户名 启用 SSD 的 TRIM 支持 关闭 SIP 设定文件默认打开方式 单文件 同类文件 打开允许未知来源 app 选项 设定快捷打开程序快捷键 设置 automator 任务 设置程序打开快捷键 Macos Beta 系统更新开启在apple beta 地址上登录https://beta.apple.com 在如下网站下载 MacOS Public Beta Access Utility工具注意开启前在Time Mechine中进行系统备份下载工具安装后即可开启。 网络磁盘映射在 finder 下操作 ⌘ + k在弹出框中输入网络共享服务地址一般有 Samba 或 AFP 等方式共享服务常见地址如下 afp://192.168.2.20smb://192.168.2.20 剪切（移动） 常规复制需要移动的文件。在目标位置右击鼠标，一般出现粘贴项目选项。此时按住 ⌥ 键，菜单会变为将项目移动到此处。 快捷键⌘ + c⌘ + ⌥ + v ⌘ + c 复制文件在目标目录 ⌘ + ⌥ + v 即可移动成功 直接删除文件放进垃圾桶【Command】+【Backspace】/【Delete】永久删除【Option】+【Command】+【Backspace】/【Delete】 修改终端用户名修改前图示 输入sudo scutil --set HostName &lt;name&gt;改后图示 启用 SSD 的 TRIM 支持mac 更换非官方固态和默认不启动 TRIM 硬盘优化，可输入sudo trimforce enable打开 关闭 SIPmac 关闭系统完整性保护 System Integrity Protection重启时，出现 apple logo 时按住⌘+R进入恢复模式点击工具中的终端输入csrutil disable输出Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.表示关闭 SIP 成功开启命令为csrutil enable 设定文件默认打开方式单文件按住 option 键，鼠标右击，查看菜单栏变化这种方式只会更改当前文件的打开方式，不会修改所有同后缀文件。 同类文件第一步：右键单击该文件，然后选择「显示简介」选项。第二步：找到「打开方式」项目，点击倒三角选择你想指定的默认应用程序。第三步：单击「全部更改」按钮即可生效 打开允许未知来源 app 选项sudo spctl --master-disable 设定快捷打开程序快捷键设置 automator 任务如下动态图所示 设置程序打开快捷键","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"MacOS","slug":"MacOS","permalink":"http://www.skyline.show/tags/MacOS/"}]},{"title":"frp内网穿透","slug":"frp内网穿透","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"frp内网穿透.html","link":"","permalink":"http://www.skyline.show/frp内网穿透.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 frp 内网穿透简介frp 是一款开源的内网穿透软件，github 主页为：https://github.com/fatedier/frp其架构如下图所示： Server 端下载包在 Release 页面下载服务器 CPU 架构对应的版本 https://github.com/fatedier/frp/releases如果不知道，可以通过 lscpu 命令查看，一般为 arm_64 位或 X86_64 位。确定后通过 weget 命令下载。如 X86_64 对应下载为 weget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_freebsd_amd64.tar.gz github国内速度较慢，也可通过迅雷等工具下载到本地后通过 SecureCRT 等工具上传. 试运行tar -zxvf frp_0.38.0_linux_amd64.tar.gz 解压成功后打开目录下的 frps.ini 文件，修改如下 [common]bind_port = 7000token = mima 尝试启动服务 ./frps -c frps.ini 成功一般有 success 提示信息，如果遇到 Segmentation fault 错误，检查下载的包版本是否有错。 后台运行服务创建服务文件：touch /etc/systemd/system/frp.service 修改 frp.service 内容如下： [Unit]Description=FRP serviceAfter=network.target syslog.targetWants=network.target[Service]ExecStart=/root/apps/frp/frps -c /root/apps/frp/frps.iniRestart=alwaysUser=root[Install]WantedBy=multi-user.target 重置守护进程服务 systemctl daemon-reload 开启服务 systemctl start frp 检查服务是否开启成功，查看 7000 端口是否开启服务即可。 netstat -anp | grep 7000 注意，此处需要在服务器提供网站对应的配置处将 7000 端口的防火墙限制打开，centos 等系统下，注意 firewalld 是否开放防火墙端口。如上操作完成后，服务即后台启动成功。要想服务开机自启动，输入：systemctl enable frp 即可。 Client 端frpc配置","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 frp 内网穿透简介frp 是一款开源的内网穿透软件，github 主页为：https://github.com/fatedier/frp其架构如下图所示： Server 端下载包在 Release 页面下载服务器 CPU 架构对应的版本 https://github.com/fatedier/frp/releases如果不知道，可以通过 lscpu 命令查看，一般为 arm_64 位或 X86_64 位。确定后通过 weget 命令下载。如 X86_64 对应下载为 weget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_freebsd_amd64.tar.gz github国内速度较慢，也可通过迅雷等工具下载到本地后通过 SecureCRT 等工具上传. 试运行tar -zxvf frp_0.38.0_linux_amd64.tar.gz 解压成功后打开目录下的 frps.ini 文件，修改如下 [common]bind_port = 7000token = mima 尝试启动服务 ./frps -c frps.ini 成功一般有 success 提示信息，如果遇到 Segmentation fault 错误，检查下载的包版本是否有错。 后台运行服务创建服务文件：touch /etc/systemd/system/frp.service 修改 frp.service 内容如下： [Unit]Description=FRP serviceAfter=network.target syslog.targetWants=network.target[Service]ExecStart=/root/apps/frp/frps -c /root/apps/frp/frps.iniRestart=alwaysUser=root[Install]WantedBy=multi-user.target 重置守护进程服务 systemctl daemon-reload 开启服务 systemctl start frp 检查服务是否开启成功，查看 7000 端口是否开启服务即可。 netstat -anp | grep 7000 注意，此处需要在服务器提供网站对应的配置处将 7000 端口的防火墙限制打开，centos 等系统下，注意 firewalld 是否开放防火墙端口。如上操作完成后，服务即后台启动成功。要想服务开机自启动，输入：systemctl enable frp 即可。 Client 端frpc配置 本文Client 端此处采用 Docker 方式。将下载的 frpc.ini 放在 Docker 宿主机本地frpc.ini 内容修改如下： [common]server_addr = 42.113.1.102server_port = 7000token = mima[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[DSM]type = tcplocal_ip = 127.0.0.1local_port = 5000remote_port = 5000 如上配置后，意味着我们之后可以通过 42.113.1.102:5000 来进入群晖，通过 42.113.1.102:22 进入群晖后台。 添加 docker 镜像地址如下：https://hub.docker.com/r/chenhw2/frp下载完成后，双击镜像，做如下三处修改： 应用修改后保存退出。 启动容器点击开关容器启动成功即可，若启动失败，可在Details查看启动日志。 在外网环境在浏览器输入 42.113.1.102:5000来到群晖登录页即穿透成功。","categories":[],"tags":[]},{"title":"iPadOS常见问题","slug":"iPadOS常见问题","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"iPadOS常见问题.html","link":"","permalink":"http://www.skyline.show/iPadOS常见问题.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 IpadOS 常见问题 IpadOS 常见问题 Apple pencil 断触 软件问题 还原设置 硬件检测 BMW WARNING Bulletin Material Warrant Apple pencil 断触软件问题使用系统自带的备忘录尝试是否为软件问题 部分软件可能手触屏幕会有断触问题 还原设置关掉蓝牙重新连接 Pencil重启 iPad 后再次连接 Pencil打开 ipad 设置—&gt;通用—&gt;还原—&gt;还原所有设置 上述操作只是还原设置，不会删除数据，但是人脸识别和密码，壁纸会还原 硬件检测去除贴膜，笔尖套更换笔头尝试换个 ipad 试下是否为笔的问题 这些操作都不行，联系售后解决 BMW WARNINGBulletin","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 IpadOS 常见问题 IpadOS 常见问题 Apple pencil 断触 软件问题 还原设置 硬件检测 BMW WARNING Bulletin Material Warrant Apple pencil 断触软件问题使用系统自带的备忘录尝试是否为软件问题 部分软件可能手触屏幕会有断触问题 还原设置关掉蓝牙重新连接 Pencil重启 iPad 后再次连接 Pencil打开 ipad 设置—&gt;通用—&gt;还原—&gt;还原所有设置 上述操作只是还原设置，不会删除数据，但是人脸识别和密码，壁纸会还原 硬件检测去除贴膜，笔尖套更换笔头尝试换个 ipad 试下是否为笔的问题 这些操作都不行，联系售后解决 BMW WARNINGBulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"CentOS防火墙","slug":"CentOS防火墙","date":"2022-01-20T07:47:15.000Z","updated":"2022-06-22T07:43:00.000Z","comments":true,"path":"CentOS防火墙.html","link":"","permalink":"http://www.skyline.show/CentOS防火墙.html","excerpt":"firewalld[^1] Concepts Zones Services Runtime State Port Source BMW WARNING firewalld[^1]Conceptsfirewalld 采用区域与服务的概念来控制流量的出入。 zones services firewalld 是 CentOS 7/8, Red Hat Enterprise Linux 7 (RHEL 7), Fedora 18+等 Linux 发行版本默认防火墙程序。其命令行工具为 firewall-cmd Zones","text":"firewalld[^1] Concepts Zones Services Runtime State Port Source BMW WARNING firewalld[^1]Conceptsfirewalld 采用区域与服务的概念来控制流量的出入。 zones services firewalld 是 CentOS 7/8, Red Hat Enterprise Linux 7 (RHEL 7), Fedora 18+等 Linux 发行版本默认防火墙程序。其命令行工具为 firewall-cmd Zones zones 预设级别不同的防火墙策略，用户可以自定义 zones，也可以使用预设的 zones。默认使用 public zone根据拦截级别严格程度，预设 zones 如下 zone 拦截说明 drop 丢弃区，所有接入连接都会进行无消息响应拦截，只有输出连接被允许。 block 拦截区，接入连接都会被拦截，会响应 icmp-host-prohibited 等拦截消息，只有输出连接被允许。 public 公共区，用于不受信任的公共区域，仅允许自选接入连接，默认允许 ssh 和 dhcpv6-client external 外部区，用于外部网络，系统充当网关角色，仅允许自选接入连接，默认允许 ssh internal 内部区，用于内部网络，系统充当网关角色，仅允许自选接入连接 dmz 隔离区，demilitarized zone（隔离区，军事缓冲区），用于允许部分服务被外网访问，仅允许自选接入连接 work 工作区，用于工作网络，信任网络中其他机器，仅允许自选接入连接，默认允许 ssh，ipp-client 和 dhcpv6-client home 家庭区，用于工作家庭网络，信任网络中其他机器，仅允许自选接入连接，默认允许 ssh，ipp-client，mdns，samba-client 和 dhcpv6-client trusted 信任区，并接受所有网络连接 新建防火墙区域策略 sudo firewall-cmd --new-zone=memcached --permanent 查看系统默认区 sudo firewall-cmd --get-default-zone# public 调整系统默认区 sudo firewall-cmd --set-default-zone=home 系统中配置的所有区 sudo firewall-cmd --get-zones# block dmz drop external home internal public trusted work sudo firewall-cmd --list-all-zones# 上述命令会打印所有区与其详细的配置，输出内容较长 查看系统使用区 sudo firewall-cmd --get-active-zones# public# interfaces: eth0 eth1 查看指定区的详细配置 sudo firewall-cmd --zone=public --list-all# public (active)# target: default# icmp-block-inversion: no# interfaces: eth0 eth1# sources:# services: ssh dhcpv6-client# ports:# protocols:# masquerade: no# forward-ports:# source-ports:# icmp-blocks:# rich rules: Servicesservices 在 zones 中为不同的服务预设不同的配置。例如，可以为服务提供不同的端口等配置 查看所有的服务 sudo firewall-cmd --get-services# RH-Satellite-6 RH-Satellite-6-capsule amanda-client amanda-k5-client amqp amqps... git... ssh ...dhcpv6-client 查看当前开放的服务 sudo firewall-cmd --list-services# dhcpv6-client ssh 增加开放服务 sudo firewall-cmd --zone=public --add-service=http 移除开放的服务 sudo firewall-cmd --zone=public --remove-service=http# 永久配置需要添加 --permanent后缀 所有服务的配置都在/usr/lib/firewalld/services 目录下例如 http 服务的配置为 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;service&gt; &lt;short&gt;WWW (HTTP)&lt;/short&gt; &lt;description&gt;HTTP is the protocol used to serve Web pages. If you plan to make your Web server publicly available, enable this option. This option is not required for viewing pages locally or developing Web pages.&lt;/description&gt; &lt;port protocol=\"tcp\" port=\"80\"/&gt;&lt;/service&gt; 自定义服务 sudo cp /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/diyservice.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;service version=\"1.0\"&gt;&lt;short&gt;diyservice&lt;/short&gt;&lt;description&gt;Plex is a streaming media server that brings all your video, music and photo collections together and stream them to your devices at anytime and from anywhere.&lt;/description&gt;&lt;port protocol=\"udp\" port=\"1900\"/&gt;&lt;port protocol=\"tcp\" port=\"32400\"/&gt;&lt;/service&gt; 重启防火墙后就可以看到该服务。 RuntimeFirewalld 提供运行时与永久两种配置有效期限。 runtime permanent runtime 只有当次开机有效，重启会恢复到默认配置，permanent 会让配置永久生效。默认指定防火墙相关配置时使用的是 runtime。要让指定的配置永久有效，需要指定 –permanent sudo firewall-cmd &lt;options&gt; 上述配置生效后只在 runtime 有效 要使其永久有效 sudo firewall-cmd --permanent &lt;options&gt; 使当前 runtime 的所有配置永久有效 sudo firewall-cmd --runtime-to-permanent 要让配置立即生效，需要重启进程 sudo firewall-cmd --reload State 查看防火墙状态 firewall-cmd --state# running #打开状态# not running #关闭状态 防火墙完整信息 firewall-cmd --list-all# public (active)# target: default# icmp-block-inversion: no# interfaces: eth0# sources:# services: dhcpv6-client ssh# ports:# protocols:# masquerade: no# forward-ports:# source-ports:# icmp-blocks:# rich rules: 临时关闭防火墙 sudo systemctl stop firewalld 上述操作只对当前运行时有效 永久关闭防火墙 sudo systemctl stop firewalld 零时关闭防火墙并防止开机重启 sudo systemctl disable firewalld# Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.# Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. 防止其他程序启动防火墙 sudo systemctl mask --now firewalld# Created symlink from /etc/systemd/system/firewalld.service to /dev/null. 打开防火墙 sudo systemctl start firewalld Port 暴露端口段 firewall-cmd --permanent --add-port 8300-8400/tcp 协议可选 tcp, udp, sctp, or dccp 暴露端口 firewall-cmd --permanent --add-port 1191/tcp 临时暴露需要去除 --permanent，重启后端口暴露将会失效。执行暴露端口的命令后，需要重启防火墙 firewall-cmd --reload 查看暴露的端口 firewall-cmd --list-ports# 8300-8400/tcp 移除暴露的端口 firewall-cmd --remove-port 8300-8400/tcp --permanent 注意开启时添加了--permanent，关闭时也需要 查询允许暴露端口的服务 sudo firewall-cmd --list-services# ssh dhcpv6-client http Source 指定允许访问的 IP sudo firewall-cmd --zone=public --add-source=192.168.100.30/32 --permanent# sudo firewall-cmd --add-source=192.168.100.30 --permanent 查看允许访问的 IP sudo firewall-cmd --zone=public --list-sources 移除指定的 IP sudo firewall-cmd --zone=public --remove-source=192.168.1.10 转发 在进行转发前，需要开启转发支持 sudo firewall-cmd --zone=external --add-masquerade --permanent 同主机 sudo firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toport=8080 上述命令会把 80 端口的 tcp 全部转发到当前服务器的 8080 端口 转发到其他主机 sudo firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toaddr=10.10.10.2 上述命令会把 80 端口的 tcp 全部转发到服务器 10.10.10.2 的 80 端口[^1]: 本节命令在 centos7 下验证 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://linuxize.com/post/how-to-configure-and-manage-firewall-on-centos-8/ Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"Linux","slug":"Linux","permalink":"http://www.skyline.show/tags/Linux/"}]},{"title":"设计模式综述","slug":"设计模式综述","date":"2021-06-03T09:39:32.000Z","updated":"2022-06-22T07:42:57.000Z","comments":true,"path":"设计模式综述.html","link":"","permalink":"http://www.skyline.show/设计模式综述.html","excerpt":"简介 设计模式原则 Single Responsibility Principle Open-closed Principle Liskov substitution principle Interface segregation principle Dependency Inversion Principle BMW WARNING 简介设计模式是在软件工程多年的发展中，经过前人不断挖坑填埋总结而来。一般认为有 23 种，其他多是基于这 23 种延伸。在面向对象编程语言中，设计模式一般遵循 SOLID 原则Acronym | EN | CN | DESC– | – | – | –S |Single Responsibility Principle | 单一职责原则 |一个程序只做好一件事，复杂功能拆开O | Open-closed Principle| 开放/封闭原则 | 对扩展开放，对修改封闭，增加需求时，扩展新代码，而非修改已有代码L |Liskov Substitution Principle | 里氏替换原则 |子类能覆盖父类，父类能出现的地方子类就能出现I | Interface Segregation Principle| 接口隔离原则 |接口职责单一，防止接入不使用的接口与方法D |Dependency Inversion Principle | 依赖倒转原则 | 面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现 设计模式原则Single Responsibility Principle","text":"简介 设计模式原则 Single Responsibility Principle Open-closed Principle Liskov substitution principle Interface segregation principle Dependency Inversion Principle BMW WARNING 简介设计模式是在软件工程多年的发展中，经过前人不断挖坑填埋总结而来。一般认为有 23 种，其他多是基于这 23 种延伸。在面向对象编程语言中，设计模式一般遵循 SOLID 原则Acronym | EN | CN | DESC– | – | – | –S |Single Responsibility Principle | 单一职责原则 |一个程序只做好一件事，复杂功能拆开O | Open-closed Principle| 开放/封闭原则 | 对扩展开放，对修改封闭，增加需求时，扩展新代码，而非修改已有代码L |Liskov Substitution Principle | 里氏替换原则 |子类能覆盖父类，父类能出现的地方子类就能出现I | Interface Segregation Principle| 接口隔离原则 |接口职责单一，防止接入不使用的接口与方法D |Dependency Inversion Principle | 依赖倒转原则 | 面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现 设计模式原则Single Responsibility Principle A class should have one and only one reason to change, meaning that a class should have only one job. 思考如下一个例子：计算给定的基本图形的面积总和，以圆形正方形为例。形状 const circle = (radius) =&gt; &#123; const proto = &#123; type: \"Circle\", //code &#125;; return Object.assign(Object.create(proto), &#123; radius &#125;);&#125;;const square = (length) =&gt; &#123; const proto = &#123; type: \"Square\", //code &#125;; return Object.assign(Object.create(proto), &#123; length &#125;);&#125;; 计算面积 const areaCalculator = (shapes) =&gt; &#123; const proto = &#123; sum() &#123; return shapes.reduce((p, n) =&gt; &#123; if (n.type == \"Circle\") &#123; return Math.PI * n.radius * n.radius + p; &#125; if (n.type == \"Square\") &#123; return n.length * n.length + p; &#125; &#125;, 0); // logic to sum &#125;, output() &#123; return ` &lt;h1&gt; Sum of the areas of provided shapes: $&#123;this.sum()&#125; &lt;/h1&gt; `; &#125;, &#125;; return Object.assign(Object.create(proto), &#123; shapes, &#125;);&#125;; 使用 const shapes = [circle(2), square(5), square(6)];const areas = areaCalculator(shapes);console.log(areas.output()); 上述方式违反单 SRP 原则。在计算面积并输出的过程中，存在一个问题：计算面积工厂产出的产品只提供 HTML 一种格式的输出，如果后续需求是输出 JSON 或者 XML?原因在于计算面积工厂承担过多的职责，在计算面积的同时，需要承担输出。将输出单独用一个工厂，并简化计算面积工厂，进行优化 计算面积 const areaCalculator = (shapes) =&gt; &#123; const proto = &#123; sum() &#123; return shapes.reduce((p, n) =&gt; &#123; if (n.type == \"Circle\") &#123; return Math.PI * n.radius * n.radius + p; &#125; if (n.type == \"Square\") &#123; return n.length * n.length + p; &#125; &#125;, 0); // logic to sum &#125;, &#125;; return Object.assign(Object.create(proto), &#123; shapes, &#125;);&#125;; 输出面积 const sumCalculatorOutputter = (sum) =&gt; &#123; const proto = &#123; HTML() &#123; return ` &lt;h1&gt; Sum of the areas of provided shapes: $&#123;sum&#125; &lt;/h1&gt; `; &#125;, JSON() &#123; return JSON.stringify(&#123; sum, &#125;); &#125;, &#125;; return Object.assign(Object.create(proto), &#123; sum &#125;);&#125;; 使用 const shapes = [circle(2), square(5), square(6)];const areas = areaCalculator(shapes);const output = sumCalculatorOutputter(areas.sum());console.log(output.JSON());console.log(output.HTML()); 完整代码示例 如果将 sumCalculatorOutputter 中 HTML 与 JSON 放在 areaCalculator 中，看起好像也没什么大问题。考虑如下情况：当需求不断扩张，当我们需要计算图形面积差，输出多种格式，计算特定图形的面积的时候……如果所有职责都放在一个工厂里面，那么这个函数将会变得臃肿和不可维护，上千行的函数，上万行的文件也就这样诞生。 Open-closed Principle Objects or entities should be open for extension, but closed for modification. 预留需求扩展接口（方法），禁止修改已有接口与方法。在计算面积的工厂中 sum 方法存在如下问题：如果后续有新的图形需求，我们需要不断地修改 sum 方法，sum 方法将变得非常臃肿。这样写肯定违反 OCP 原则。如果该图形不具备通用性，只在某个需求中计算一次面积，那么放在 sum 方法中，所有用 sum 方法的地方都会多余的执行该判定条件，造成多余的开销。计算面积应该属于对应图形的方法，优化代码，将各自的计算面积 area 方法放在对应的图形工厂。square const square = (length) =&gt; &#123; const proto = &#123; type: \"Square\", area() &#123; return this.length ** 2; &#125;, &#125;; return Object.assign(Object.create(proto), &#123; length &#125;);&#125;; circle const circle = (radius) =&gt; &#123; const proto = &#123; type: \"Circle\", area() &#123; return Math.PI * this.radius ** 2; &#125;, &#125;; return Object.assign(Object.create(proto), &#123; radius &#125;);&#125;; rect const rect = (length, width) =&gt; &#123; const proto = &#123; type: \"Rect\", area() &#123; return this.length * this.width; &#125;, &#125;; return Object.assign(Object.create(proto), &#123; length, width &#125;);&#125;; 计算面积 const areaCalculator = (shapes) =&gt; &#123; const proto = &#123; sum() &#123; return shapes.reduce((p, n) =&gt; n.area() + p, 0); // logic to sum &#125;, &#125;; return Object.assign(Object.create(proto), &#123; shapes, &#125;);&#125;; 使用 const shapes = [circle(2), square(5), square(6), rect(3, 4)];const areas = areaCalculator(shapes);const output = sumCalculatorOutputter(areas.sum());console.log(output.JSON());// &#123;\"sum\":85.56637061435917&#125;console.log(output.HTML());// &lt;h1&gt;// Sum of the areas of provided shapes:// 85.56637061435917// &lt;/h1&gt; 完整代码示例 当遇到多个判定条件的时候，可以思考其是否违反了 OCP 原则。 Liskov substitution principle Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T. 如果 q(x)对 T 类型的 x 实例成立，那么对 T 的子类 S 的实例 y，q(y)必成立。子类可替代父类，代替后表现一致，即子类要对父类的特性保持兼容性。后三个原则涉及到接口与类，用新的 TS 示例代码来说明。在几何中，正方形被看做一个特殊的长方形，即其长宽相等。在抽象化的时候，我们趋向于让其继承与长方形。Rectangle class Rectangle &#123; constructor(private width: number, private length: number = 10) &#123;&#125; public setWidth(width: number) &#123; this.width = width; &#125; public setWidth(length: number) &#123; this.length = length; &#125; public getArea() &#123; return this.width * this.length; &#125;&#125; Square class Square extends Rectangle &#123; constructor(side: number) &#123; super(side, side); &#125; public setWidth(width: number) &#123; // A square must maintain equal sides super.setWidth(width); super.setLength(width); &#125; public setLength(length: number) &#123; super.setWidth(length); super.setLength(length); &#125;&#125; 使用 const rect: Rectangle = new Rectangle(10); // Can be either a Rectangle or a Squarerect.setWidth(20);if (rect.getArea() &gt; 300) &#123; console.log(\"It is big!\");&#125; else &#123; console.log(\"It is small!\");&#125; // 200 用 Square 替换 const rect: Rectangle = new Square(10); // Can be either a Rectangle or a Squarerect.setWidth(20);if (rect.getArea() &gt; 300) &#123; console.log(\"It is big!\");&#125; else &#123; console.log(\"It is small!\");&#125; // 400 完整代码示例用子类替换父类后，表现不一致，不符合 LSP。可见，Square 作为 Rectangle 并不是一个好的方案。一个更好的方案为抽象出一个 Shape 接口。 interface Shape &#123; getArea: () =&gt; number;&#125; 调整代码后如下 interface Shape &#123; getArea: () =&gt; number; setWidth: (width: number) =&gt; void; setLength: (length: number) =&gt; void;&#125;class Rectangle implements Shape &#123; width: number length: number constructor(width: number, length: number) &#123; this.width = width; this.length = length; &#125; public setWidth(width: number) &#123; this.width = width; &#125; public setLength(length: number) &#123; this.length = length; &#125; public getArea() &#123; return this.width * this.length; &#125;&#125;class Square implements Shape &#123; width: number; constructor(width: number) &#123; this.width = width; &#125; public setWidth(width: number) &#123; this.width = width; &#125; public setLength(length: number) &#123; &#125; public getArea() &#123; return this.width * this.width; &#125;&#125;const square: Shape = new Square(20);if (square.getArea() &gt; 300) &#123; console.log('It is big!')&#125; else &#123; console.log(square.getArea(), 'It is small!')&#125;// const rect: Shape = new Rectangle(20, 20);// if (rect.getArea() &gt; 300) &#123;// console.log('It is big!')// &#125; else &#123;// console.log(rect.getArea(), 'It is small!')// &#125; Interface segregation principle A Client should not be forced to depend upon interfaces and methods that they do not use. 接口使用方不应该强制接入不使用的接口与方法。 在 LSP 中，最后的代码，Square 被强制实现了不需要的 setLength 方法。需要进一步优化，抽象出不同图形对应的接口 interface Shape &#123; getArea: () =&gt; number;&#125;interface Rectangle extends Shape &#123; width: number; length: number;&#125;interface Square extends Shape &#123; width: number;&#125;Implementation... 优化后的代码如下： interface Shape &#123; getArea: () =&gt; number;&#125;interface RectangleFace extends Shape &#123; width: number; length: number;&#125;interface SquareFace extends Shape &#123; width: number;&#125;class Rectangle implements RectangleFace &#123; width: number length: number constructor(width: number, length: number) &#123; this.width = width; this.length = length; &#125; public setWidth(width: number) &#123; this.width = width; &#125; public setLength(length: number) &#123; this.length = length; &#125; public getArea() &#123; return this.width * this.length; &#125;&#125;class Square implements SquareFace &#123; width: number; constructor(width: number) &#123; this.width = width; &#125; public setWidth(width: number) &#123; this.width = width; &#125; public getArea() &#123; return this.width * this.width; &#125;const square: Shape = new Square(20);if (square.getArea() &gt; 300) &#123; console.log('It is big!')&#125; else &#123; console.log(square.getArea(), 'It is small!')&#125;// const rect: Shape = new Rectangle(20, 20);// if (rect.getArea() &gt; 300) &#123;// console.log('It is big!')// &#125; else &#123;// console.log(rect.getArea(), 'It is small!')// &#125; Dependency Inversion Principle Entities must depend on abstractions not on concretions. It states that the high level module must not depend on the low level module, but both should depend on abstractions. 依赖虚拟接口而不是实体类，关注接口，不关注类。这里的接口与生活中的接口理解上没有太大差别。对于手机充电来说，如果充电器针对手机而不是充电接口来设计，那么该充电器只能用于其型号。如果针对充电接口来设计，比如都设计成 typec 接口的，那么所有实现 typec 接口的设备都可使用。在与后端对接接口时，我们常使用如下代码：infra/HttpClient.ts import axios from \"axios\";export default &#123; createUser: async (user: User) =&gt; &#123; return axios.post(/* ... */); &#125;, getUserByEmail: async (email: string) =&gt; &#123; return axios.get(/* ... */); &#125;,&#125;; domain/SignupService.ts import HttpClient from \"infra/HttpClient\";export async function signup(email: string, password: string) &#123; const existingUser = await HttpClient.getUserByEmail(email); if (existingUser) &#123; throw new Error(\"Email already used\"); &#125; return HttpClient.createUser(&#123; email, password &#125;);&#125; 上述代码 SignupService 与 HttpClient 耦合严重，不便于对其进行单元测试，同时，mock 假数据也不方便。 优化代码domain/ApiClient.ts // domain/ApiClient.tsexport interface ApiClient &#123; createUser: (user: User) =&gt; Promise&lt;void&gt;; getUserByEmail: (email: string) =&gt; Promise&lt;User&gt;; // ...&#125; infra/HttpClient.ts // infra/HttpClient.tsimport axios from \"axios\";import ApiClient from \"domain/ApiClient\";export function HttpClient(): ApiClient &#123; return &#123; createUser: async (user: User) =&gt; &#123; return axios.post(/* ... */); &#125;, getUserByEmail: async (email: string) =&gt; &#123; return axios.get(/* ... */); &#125;, &#125;;&#125; domain/SignupService.ts // domain/SignupService.tsimport ApiClient from \"domain/ApiClient\";export function SignupService(client: ApiClient) &#123; return async (email: string, password: string) =&gt; &#123; const existingUser = await client.getUserByEmail(email); if (existingUser) &#123; throw new Error(\"Email already used\"); &#125; return client.createUser(&#123; email, password &#125;); &#125;;&#125; 实际使用index.ts // index.tsimport SignupService from \"domain/signup\";import HttpClient from \"infra/HttpClient\";const signup = SignupService(HttpClient());signup(\"bob@bob.com\", \"pwd123\"); 测试代码infra/InMemoryClient.ts // infra/InMemoryClient.tsimport ApiClient from \"domain/ApiClient\";export function InMemoryClient(): ApiClient &#123; const users: User[] = []; return &#123; createUser: async (user: User) =&gt; &#123; users.push(user); &#125;, getUserByEmail: async (email: string) =&gt; &#123; return users.find((user) =&gt; user.email === email); &#125;, &#125;;&#125; tests/SignupService.spec.ts // tests/SignupService.spec.tsimport SignupService from \"domain/signup\";import InMemoryClient from \"infra/InMemoryClient\";let signup: ReturnType&lt;typeof SignupService&gt;;beforeEach(() =&gt; &#123; signup = SignupService(InMemoryClient());&#125;);test(\"it should signup a user\", async () =&gt; &#123; await expect(signup(\"john@test.com\", \"pwd123\")).resolves.toBe(undefined);&#125;);test(\"it should fail to signup the same email twice\", async () =&gt; &#123; await signup(\"mark@test.com\", \"pwd123\"); await expect(signup(\"mark@test.com\", \"pwd987\")).rejects.toThrow( new Error(\"Email already used\") );&#125;); BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 S.O.L.I.D The first 5 principles of Object Oriented Design with JavaScript &gt; Liskov Substitution Principle in Functional TypeScript &gt; Dependency Inversion Principle in Functional TypeScript Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://www.skyline.show/tags/DesignPatterns/"}]},{"title":"Shell常见操作汇总","slug":"Shell常见操作汇总","date":"2021-05-27T10:06:41.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Shell常见操作汇总.html","link":"","permalink":"http://www.skyline.show/Shell常见操作汇总.html","excerpt":"获取执行脚本的位置 Shell 脚本相互调用 脚本中断与执行 判定目录或文件存在 算数命令 查看目录下文件夹 创建嵌套文件夹并进入 查看远程服务及端口是否开启 设置别名 临时别名 永久生效 查看端口占用 删除目录下模糊匹配的文件 命令 解析 查找目录下包含指定字符的文件 命令 解析 BMW WARNING 获取执行脚本的位置通过dirname &quot;$0&quot;获取当前执行脚本所在位置。 BASEDIR=$(dirname \"$0\")echo $BASEDIR 示例 Shell 脚本相互调用在 Shell 脚本内部调用其他 Shell 脚本，使用如下方法： sh source 点号(.) 使用点号和 source 的效果基本一致，等同于将其他脚本的内部内容放在当前脚本运行。引入脚本和当前脚本执行时位于同一进程中，引入脚本可以获取到当前脚本中的变量。sh 引入的脚本会单开一个子进程，其无法获取到当前脚本中的变量，要获取该变量，需要使用 export 导出。有如下两个在同级目录的脚本 a 和 ba.sh a=1echo \"b is $b\"# b isBASEDIR=$(dirname \"$0\")echo $BASEDIR. \"$BASEDIR/b.sh\"# a is 1echo \"b is $b\"# b is 2source \"$BASEDIR/b.sh\"# a is 1sh \"$BASEDIR/b.sh\"# a isexport ash \"$BASEDIR/b.sh\"# a is 1 b.sh echo \"a is $a\"b=2 示例 脚本中断与执行","text":"获取执行脚本的位置 Shell 脚本相互调用 脚本中断与执行 判定目录或文件存在 算数命令 查看目录下文件夹 创建嵌套文件夹并进入 查看远程服务及端口是否开启 设置别名 临时别名 永久生效 查看端口占用 删除目录下模糊匹配的文件 命令 解析 查找目录下包含指定字符的文件 命令 解析 BMW WARNING 获取执行脚本的位置通过dirname &quot;$0&quot;获取当前执行脚本所在位置。 BASEDIR=$(dirname \"$0\")echo $BASEDIR 示例 Shell 脚本相互调用在 Shell 脚本内部调用其他 Shell 脚本，使用如下方法： sh source 点号(.) 使用点号和 source 的效果基本一致，等同于将其他脚本的内部内容放在当前脚本运行。引入脚本和当前脚本执行时位于同一进程中，引入脚本可以获取到当前脚本中的变量。sh 引入的脚本会单开一个子进程，其无法获取到当前脚本中的变量，要获取该变量，需要使用 export 导出。有如下两个在同级目录的脚本 a 和 ba.sh a=1echo \"b is $b\"# b isBASEDIR=$(dirname \"$0\")echo $BASEDIR. \"$BASEDIR/b.sh\"# a is 1echo \"b is $b\"# b is 2source \"$BASEDIR/b.sh\"# a is 1sh \"$BASEDIR/b.sh\"# a isexport ash \"$BASEDIR/b.sh\"# a is 1 b.sh echo \"a is $a\"b=2 示例 脚本中断与执行 在控制台输入没有的命令来模拟脚本执行出错 skyline# zsh: command not found: skyline 命令执行出错，继续执行 skyline || true 命令执行出错，终止执行 skyline || exit 2 判定目录或文件存在if [ -d \"Docs/Major/Shell/Scripts\" ]; then echo \"目录存在\"else echo \"目录不存在\"fi# 目录存在if [ -f \"Docs/Major/Shell/Scripts/Shell常见操作汇总.md\" ]; then echo \"文件存在\"else echo \"文件不存在\"fi# 文件存在 类似的其他判定 标记 描述 -L 文件是否为软连接 -h 文件是否为软连接 -d 目录判定 -w 文件可否写入 -x 文件可否执行 -r 文件可否读取 -s 文件存在且占用空间大于 0 算数命令使用 exprming expr 1 + 1 plus=`expr 1 + 1`echo $plus# 2minus=$(expr 1 - 1)echo $minus# 0multiply=$((2 * 2))echo $multiply# 4 当()前面加上$时，表示 Command-Substitution，与command一致，表示其运行结果充当所在命令行的一部分. (())内部进行算数表达式的计算。 查看目录下文件夹查看当前目录信息 ls -dlh /var/log# drwxr-xr-x 47 root wheel 1.5K Jan 6 09:22 /var/log 查看 src 下包含的文件夹 ls -d src/*/ 换行形式查看当前目录下的文件夹 ls -d1 */ 创建嵌套文件夹并进入mkdir -p /home/foo/123 &amp;&amp; cd $_ 查看远程服务及端口是否开启telnet ip 3306 设置别名临时别名alias m=&quot;tldr&quot;tldr 是一个以示例代替说明的命令使用说明工具，比自带的命令行手册易读。 永久生效vim ~/.bashrc# vim ~/.zshrc 在末尾行加入alias m=&quot;tldr&quot;然后source ~/.bashrc 查看端口占用netstat -apn | grep 8884 lsof -i:8884 删除目录下模糊匹配的文件命令find . -name &quot;*.js&quot; | xargs rm -rf 解析Shell 中只有部分命令支持标准输入，例如 wc、grep 等，通过管道 | 很容易将前置命令的标准输出传递给这些命令。但是部分命令不支持标准输入，例如 echo rm mkdir 等，这里需要 xargs 来提供xargs 查找目录下包含指定字符的文件命令在 Docs 目录下查找包含 find 字符的文件 ls ./ | xargs grep -rni findfind . -type f | xargs grep -rni findgrep -rni ./ -e find grep -rniw ./ -e user 上述代码不会匹配 users grep -rniw ./ -e user -l -l –files-with-matches只输出匹配的文件名 Only the names of files containing selected lines are written to standard output 解析grep 参数 r 递归查找子目录文件 n 列出行标 i 忽略大小写 e 搜索时启用正则匹配 w 精确指定单词，需要为单词，英文单词前后有字母不匹配 l 只输出匹配的文件名 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Shell 常见操作汇总.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"Shell中sed的使用","slug":"Shell中sed的使用","date":"2021-05-27T08:29:03.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell中sed的使用.html","link":"","permalink":"http://www.skyline.show/Shell中sed的使用.html","excerpt":"sed 简介 选项参数 -n -e -i 命令参数 i/a d p s/c 常见用法 文末插入 替换字符 获取行数 获取字符行号 BMW WARNING sed 简介sed 是一种流文本编辑器，用于读取指定文件或标准输入。如果没有文件被指定，可由命令列表来指定输入，进行相应修改后写入到标准输出。本文后续内容以skyline.txt示例，可在根目录执行下述脚本。其文本内容为 testskylinetest2skyline test 选项参数-n","text":"sed 简介 选项参数 -n -e -i 命令参数 i/a d p s/c 常见用法 文末插入 替换字符 获取行数 获取字符行号 BMW WARNING sed 简介sed 是一种流文本编辑器，用于读取指定文件或标准输入。如果没有文件被指定，可由命令列表来指定输入，进行相应修改后写入到标准输出。本文后续内容以skyline.txt示例，可在根目录执行下述脚本。其文本内容为 testskylinetest2skyline test 选项参数-n 默认情况下，在所有的标准输出都会被打印到屏幕上。 -n 选项用于指定输出内容。 # 输出1到3行sed -n '1,3p' Demos/Major/Shell/skyline.txt# test# skyline# test2# 输出文件总行数sed -n '$=' Demos/Major/Shell/skyline.txt# 4# 获取文件行数，也可使用cat Demos/Major/Shell/skyline.txt | wc -l 连续的行数用逗号隔开。 -e-e 是编辑命令，用于执行多个编辑任务。 sed -e '1,2d' -e 's/skyline/lty/g' Demos/Major/Shell/skyline.txt# test2# lty test skyline.txt 将依次执行之后的命令，删除 1 到 2 行，并且全局替换’skyline’为’lty’上述操作不会影响 skyline.txt 源文件，只做标准输出，可使用&gt;将结果重定向到另一个文件。 -i-i 指定备份 可指定字符后缀为备份文件 # 指定会在skyline.txt同级目录生产skyline.txt.bak备份，skyline.txt内容将会变更# skyline.txt 源文件内容将会备份到 skyline.txt.bak 文件中sed -i '.bak' 's/skyline/lty/g' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt.bak# test# skyline# test2# skyline testcat Demos/Major/Shell/skyline.txt# test# lty# test2# lty test 指定空字符串或不指定内容直接修改源文件(linux 下可以不指定，mac 下需指定空字符) sed -i '' 's/skyline/lty/g' Demos/Major/Shell/skyline.txt# 将不备份直接修改skyline.txt源文件cat Demos/Major/Shell/skyline.txt# test# lty# test2# lty test sed -i 's/skyline/lty/g' Demos/Major/Shell/skyline.txt# mac下不可执行，linux 可以直接执行修改源文件，mac 下需要如上指定空字符方可# 在 Mac 上，sed 命令直接操作文件的时候，必须指定备份的格式，而在 linux 上，却并没有这个要求 命令参数i/ai 与 a 都是插入参数，后面可以接字串，用 a 插入的字串会在行的下一行行首出现，用 i 插入的字串会在当前行的行首。插入的字符用\\隔开，注意，在 mac 下\\后需要换行 # Mac/Linuxsed -i '' '3i\\test3' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt# test# skyline# test3test2# skyline testsed -i '' '3a\\test3' Demos/Major/Shell/skyline.txt# test# skyline# test2# test3skyline test# Linuxsed -i '' '3a\\test3' Demos/Major/Shell/skyline.txt d 简单使用 删除命令，之后不接内容。 sed -i '' '1,3d' Demos/Major/Shell/skyline.txt# 删除文件的1，2，3行sed -i '' '1d;3d' Demos/Major/Shell/skyline.txt# 删除文件的1行3行sed -i '' '$d' Demos/Major/Shell/skyline.txt# 删除文件的尾行sed -i '' '1,3d!' Demos/Major/Shell/skyline.txt# 删除其他行，只保留1-3行 使用正则 删除空行 # 删除文件中的空行sed -i '' '/^$/d' Demos/Major/Shell/skyline.txt# 开始与结束衔接，表示该行没有任何内容，即空行 删除有匹配成功对应的行 sed -i '' '/skyline/d' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt# test# test2 删除有匹配成功对应的行 sed -i '' '/^skyline$/d' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt# test# test2# skyline test 删除特殊匹配的行 # 删除有空格的行sed -i '' '/[[:space:]]/d' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt# test# skyline# test2# 删除有数字的行sed -i '' '/[[:digit:]]/d' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt# test# skyline# skyline test# 删除有小写字母的行sed -i '' '/[[:lower:]]/d' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt# p标准输出内容 # 输出1到3行sed -n '1,3p' Demos/Major/Shell/skyline.txt# test# skyline# test2 s/c使用 s/c 来替换部分内容。这个 s 通常搭配正则表达式， c 通常替换指定行。 替换行 # 替换1到5行的内容为lalalased -i '' '1,5c\\lalala' Demos/Major/Shell/skyline.txtcat Demos/Major/Shell/skyline.txt# lalala 替换文本 sed -i '' 's/skyline/lty/g' Demos/Major/Shell/skyline.txt# 全局替换skyline为lty，将不备份直接修改skyline.txt源文件cat Demos/Major/Shell/skyline.txt# test# lty# test2# lty test 通过’/原文本/替换文本/‘来指定替换，分隔符号为’/‘,当文本中包含分隔符时，可以使用其他符号来指定分隔符。例如原文本为’skyline/‘，替换文本为’lty-‘，可以使用 sed -i '' 's%skyline/%lty-%g' Demos/Major/Shell/skyline.txt# 或sed -i '' 's|skyline/|lty-|g' Demos/Major/Shell/skyline.txt 也可以使用转义符 sed -i '' 's/skyline\\//lty-/g' Demos/Major/Shell/skyline.txt 转义符方案除了用于’/‘,原文本包含’[‘’]’等字符也需使用。 常见用法文末插入注意 mac 下\\后需要换行 sed -i '' '$a\\skyline' skyline.txt 替换字符替换第 n 个匹配的字符 echo sksksksksksk | sed 's/sk/SK/3'# skskSKsksksk 获取行数输出文件行数 # 输出文件总行数sed -n '$=' Demos/Major/Shell/skyline.txt# 4# 获取文件行数，也可使用cat Demos/Major/Shell/skyline.txt | wc -l 获取字符行号输出文件第 n 个匹配字符所在行号 # 输出所有skyline的行号sed -n /skyline/= Demos/Major/Shell/skyline.txt# 2# 4#输出第2个skyline所在行号sed -n /skyline/= Demos/Major/Shell/skyline.txt | sed -n 2p# 4 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"Shell中字符串相关操作","slug":"Shell中字符串相关操作","date":"2021-05-27T08:06:40.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Shell中字符串相关操作.html","link":"","permalink":"http://www.skyline.show/Shell中字符串相关操作.html","excerpt":"字符替换 字符包含判定 == 正则=~ grep 将字符串作为命令执行 获取子串（字符串切割） cut 截取语法 字符串转数组 read 字符替换 其他场景 BMW WARNING 字符替换将空格字符’ ‘替换为’|’ STR=\"1 2 3 4\";SKYLINE=$&#123;STR// /|&#125;echo $SKYLINE# 1|2|3|4 字符包含判定==","text":"字符替换 字符包含判定 == 正则=~ grep 将字符串作为命令执行 获取子串（字符串切割） cut 截取语法 字符串转数组 read 字符替换 其他场景 BMW WARNING 字符替换将空格字符’ ‘替换为’|’ STR=\"1 2 3 4\";SKYLINE=$&#123;STR// /|&#125;echo $SKYLINE# 1|2|3|4 字符包含判定== STR='GNU/Linux is an operating system'SUB='Linux'if [[ \"$STR\" == *\"$SUB\"* ]]; then echo \"It's there.\"fi 正则=~STR='GNU/Linux is an operating system'SUB='Linux'if eval '[[ \"$STR\" =~ .*\"$SUB\".* ]]'; then echo \"It's there.\"else echo \"It's not there.\"fieval '[[ \"$STR\" =~ .*\"$SUB\".* ]]' &amp;&amp; echo \"It's there.\" || echo \"It's not there.\" 由于上述正则中包含了变量，需要使用 eval 来辅助，一般使用情况如下 STR='GNU/Linux is an operating system'if [[ \"$STR\" =~ .*Linux.* ]]; then echo \"It's there.\"else echo \"It's not there.\"fi[[ \"$STR\" =~ .*Linux.* ]] &amp;&amp; echo \"It's there.\" || echo \"It's not there.\" grep使用 grep STR='GNU/Linux is an operating system'SUB='Linux'if grep -q \"$SUB\" &lt;&lt;&lt; \"$STR\"; then echo \"It's there\"fi 将字符串作为命令执行使用 eval 命令 eval 'echo 1' 获取子串（字符串切割）cut使用 cut 命令，基本使用如下 echo \"STRING\" | cut -cN-M echo \"skyline\" | cut -c2-6# kylin 也可以不传 M echo \"skyline\" | cut -c2-# kyline 上述代码实现的效果类似于 JS 中字符串 slice 的效果，但注意字符串截取的索引指代不同。要实现字符串 split 效果，需要添加额外参数可以通过-d 参数指定分割符号（delimiter）分割字符后将同样得到一个数组（索引以 1 开始的数组？），需要添加 -f 参数来指定截取的索引 echo \"skyline\" | cut -d'i' -f1# skylecho \"skyline\" | cut -d'i' -f2# neecho \"skyline\" | cut -d'i' -f1-# skyline 截取语法基本语法 string='xxx'echo $&#123;string:S&#125;echo $&#123;string:S:E&#125; S 与 E 分别指代开始和结束索引使用 a=skylineecho $&#123;a:1&#125;# kylineecho $&#123;a:2&#125;# ylineecho $&#123;a:2:4&#125;# ylin 字符串转数组readIN=\"skyline/test/a\"# 将字符以 / 分割并以数组存在ADDR中IFS='/' read -ra ADDR &lt;&lt;&lt;\"$IN\"# 打印数组的每一项echo $&#123;ADDR[@]&#125;# skyline test a# 打印数组的第一项echo $&#123;ADDR[0]&#125;# skyline# 打印数组的长度echo $&#123;#ADDR[@]&#125;# 4# 遍历每一项for i in $&#123;ADDR[@]&#125;; do echo \"$i\"done read 命令 -a 参数是指将输入以数组形式存储read 命令 -r 参数是指将输入中的反斜杠\\不具备转义，为普通字符，此处可不加 字符替换将字符串替换为xx xx xx后的形式后用()包裹，即构建数组字面量形式(xx xx xx)(经测试，Mac 下无效，Centos7 可行) IN=\"skyline/test/a\"arrIN=($&#123;IN//// &#125;)echo $&#123;arrIN[1]&#125;# testecho $&#123;arrIN[*]&#125;# skyline test a 其他场景如下场景非严格意义转数组，但应对于需要数组实现的某些效果 cut 若只需要使用分割后的字符某项，使用 cut 更加方便易懂。如上获取子串一节所示，需要注意此处索引不是以 0 开始 echo \"skyline/test/a\" | cut -d'i' -f1# skyline tr 若只需要打印分割后的每项，可以使用 tr IN=\"skyline/test/a\"for i in $(echo $IN | tr \"/\" \"\\n\")do echo $idone BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Shell 中字符串相关操作.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"Shell中xargs使用","slug":"Shell中xargs使用","date":"2021-05-27T08:06:40.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell中xargs使用.html","link":"","permalink":"http://www.skyline.show/Shell中xargs使用.html","excerpt":"概述 基础使用示例 echo wc mkdir 参数 -0 -I -L -n -d -t -p BMW WARNING 概述Shell 中只有部分命令支持标准输入，例如 wc、grep、xargs 等，通过管道 | 很容易将前置命令的标准输出传递给这些命令。但是部分命令不支持标准输入，不能通过管道 | 直接操作，例如 echo rm mkdir 等。这需要 xargs 为那些不支持标准输入的命令提供管道操作。通过 xargs 将标准输入转换成参数来完成后续命令。如果转换成的参数有多个（通过标准输入空符分割），后续命令重复执行。 The xargs command in UNIX is a command line utility for building an execution pipeline from standard input. Whilst tools like grep can accept standard input as a parameter, many other tools cannot. Using xargs allows tools like echo and rm and mkdir to accept standard input as arguments. 基础使用示例echo","text":"概述 基础使用示例 echo wc mkdir 参数 -0 -I -L -n -d -t -p BMW WARNING 概述Shell 中只有部分命令支持标准输入，例如 wc、grep、xargs 等，通过管道 | 很容易将前置命令的标准输出传递给这些命令。但是部分命令不支持标准输入，不能通过管道 | 直接操作，例如 echo rm mkdir 等。这需要 xargs 为那些不支持标准输入的命令提供管道操作。通过 xargs 将标准输入转换成参数来完成后续命令。如果转换成的参数有多个（通过标准输入空符分割），后续命令重复执行。 The xargs command in UNIX is a command line utility for building an execution pipeline from standard input. Whilst tools like grep can accept standard input as a parameter, many other tools cannot. Using xargs allows tools like echo and rm and mkdir to accept standard input as arguments. 基础使用示例echo # inputecho skyline | echo#output # inputecho skyline | xargs echo# outputskyline 在未指定后续操作的情况下，xargs 默认执行 echo 操作 # inputecho skyline | xargs# outputskyline 通常 xargs 与管道符一起使用，但其也可以从其他方式指定标准输入。通过键盘指定标准输入 # inputxargs # 输入 xargs 输入 ⏎skyline # 输入 skyline 输入 ⏎ 输入 ^ + D# outputskyline # 输出 与如下命令等价 # inputxargs echo # 输入 xargs echo 输入 ⏎skyline # 输入 skyline 输入 ⏎ 输入 ^ + D# outputskyline # 输出 wc# inputfind . -name &quot;*.md&quot;# output./Major/Mobile/Flutter/Flutter基础使用汇总.md./Major/Mobile/Flutter/Flutter基础控件使用.md./Major/Shell/Shell中xargs使用.md./Major/Shell/Shell中的符号.md./Major/Shell/Shell常见操作汇总.md./README.md./Tools/DEVs/VSCode/Extensions/PicGo.md./Tools/OS/ipadOS使用.md # inputfind . -name &quot;*.md&quot; | wc -l# output 8 # inputfind . -name &quot;*.md&quot; | xargs wc -l# output 84 ./Major/Mobile/Flutter/Flutter基础使用汇总.md 109 ./Major/Mobile/Flutter/Flutter基础控件使用.md 0 ./Major/Shell/Shell中xargs使用.md 131 ./Major/Shell/Shell中的符号.md 13 ./Major/Shell/Shell常见操作汇总.md 4 ./README.md 44 ./Tools/DEVs/VSCode/Extensions/PicGo.md 5 ./Tools/OS/ipadOS使用.md 390 total mkdir# inputecho 1 2 3 | xargs mkdirls# output1 2 3 参数-0用 null 作为分隔符，与 find 中 -print0 意义一致，且需一起使用 -I将标准输入以指定字符缓存，方便后续使用。类似于正则中()的作用。 将当前目录下文件统一加后缀 # inputls# output# one two three# inputfind . -type f -name '*' -print0 | xargs -0 -I&#123;&#125; mv &#123;&#125; &#123;&#125;.txt &amp;&amp; ls# one.txt two.txt three.txt# inputls | xargs -I_ mv _ _.bak &amp;&amp; ls# output# one.txt.bak three.txt.bak two.txt.bak -Lnumber 类型，解决多行输入问题，将标准输入按照该数字指定的行数进行分隔，假设为 -L 2，则每次执行取两行作为标准输入，执行多次，直到多行执行结束。多数命令不支持多行参数，通常直接指定 -L1 # inputecho -e \"She*\\nFlu*\" | xargs -L 1 find . -name# output# ./Major/Shell# ./Major/Shell/Shell中xargs使用.md# ./Major/Shell/Shell中的符号.md# ./Major/Shell/Shell常见操作汇总.md# ./Major/Mobile/Flutter# ./Major/Mobile/Flutter/Flutter基础使用汇总.md# ./Major/Mobile/Flutter/Flutter基础控件使用.md -nnumber 类型，解决同行多项参数问题。与-L 参数互斥，同时指定选后指定的选项。 # inputecho -e \"She* Flu*\" | xargs -n 1 find . -name# output# ./Major/Shell# ./Major/Shell/Shell中xargs使用.md# ./Major/Shell/Shell中的符号.md# ./Major/Shell/Shell常见操作汇总.md# ./Major/Mobile/Flutter# ./Major/Mobile/Flutter/Flutter基础使用汇总.md# ./Major/Mobile/Flutter/Flutter基础控件使用.md -d指定分隔符这在处理有空格等特殊符号的输入中很有用 -t打印执行日志 # inputecho skyline | xargs -t echo# outputecho skylineskyline -p打印实际操作并让用户选择是否执行 # inputls# outputone three two# inputecho &apos;one two three&apos; | xargs -p rm -rf# input &amp; outputrm -rf one two three?...y# inputls# output 上述确认操作中除了输入 y，其他任何输入都不会进行删除操作 BMW WARNING Bulletin I am a bucolic migrant worker but I never walk backwards. Material Linux and Unix xargs command tutorial with examples &gt; 8 Practical Examples of Linux Xargs Command for Beginners Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"浏览器回流与重绘","slug":"浏览器回流与重绘","date":"2021-05-27T07:41:03.000Z","updated":"2023-02-02T07:41:07.000Z","comments":true,"path":"浏览器回流与重绘.html","link":"","permalink":"http://www.skyline.show/浏览器回流与重绘.html","excerpt":"页面渲染 渲染流程 渲染原理 Layout Paint 回流与重绘触发 回流触发 重绘触发 回流与重绘优化 浏览器优化 代码优化 像素管道 像素管道组成 BMW WARNING 页面渲染渲染流程浏览器使用流式布局模型 (Flow Based Layout)，浏览器从拿到代码到渲染页面，主要流程 解析 HTML 节点，创建 DOM 树 解析 CSS 创建 CSSOM 树 合并 CSSOM 与 DOM 为 渲染树（renderTree） 由 DOM 树 Root 节点开始遍历获取可视节点 对于 DOM 的可视节点，获取其对应 CSSOM 树规则 根据两棵树上获取的节点与样式，合成 renderTree Layout，计算出 renderTree 每个节点的大小和位置 Paint， 绘制 renderTree 到页面上 合并的 renderTree 的过程只获取可视节点，将会忽略不可视节点 (meta, script, link 等节点及 display:none 的节点)。图片源文件 渲染原理","text":"页面渲染 渲染流程 渲染原理 Layout Paint 回流与重绘触发 回流触发 重绘触发 回流与重绘优化 浏览器优化 代码优化 像素管道 像素管道组成 BMW WARNING 页面渲染渲染流程浏览器使用流式布局模型 (Flow Based Layout)，浏览器从拿到代码到渲染页面，主要流程 解析 HTML 节点，创建 DOM 树 解析 CSS 创建 CSSOM 树 合并 CSSOM 与 DOM 为 渲染树（renderTree） 由 DOM 树 Root 节点开始遍历获取可视节点 对于 DOM 的可视节点，获取其对应 CSSOM 树规则 根据两棵树上获取的节点与样式，合成 renderTree Layout，计算出 renderTree 每个节点的大小和位置 Paint， 绘制 renderTree 到页面上 合并的 renderTree 的过程只获取可视节点，将会忽略不可视节点 (meta, script, link 等节点及 display:none 的节点)。图片源文件 渲染原理 浏览器将渲染树上的节点通过渲染类来构建成一个个渲染对象。每个渲染对象将在页面上绘制其对应的矩形区域，根据 display 的不同，有不同的渲染类。 RenderInline RenderBlock RenderListItem 所有渲染类有一个基类 RenderObject class RenderObject&#123; virtual void layout(); virtual void paint(PaintInfo); virtual void rect repaintRect(); Node* node; // the DOM node RenderStyle* style; // the computed style RenderLayer* containgLayer; // the containing z-index layer&#125; 基类中的 layout 对应布局，paint 即为绘制。在渲染页面过程中，由根节点开始，递归遍历渲染树（renderTree）上节点，执行每个节点对应渲染对象的 layout 与 paint 方法。 Layout布局（排列）阶段，包括初始的布局 Layout 以及后续出现的回流 Reflow。为了避免细微更改都进行整体重新布局，浏览器将布局分为全量布局与增量布局。全量布局，渲染流程会在整个页面重新来过，非常耗费性能，一般只有视窗变化或影响全局的样式变更会触发全量布局。增量布局，在渲染树上，将涉及到变更的节点对应渲染对象添加标记位’dirty’，后续布局时只在脏对象进行即可。主要（重新）计算节点的位置与几何形状，可以看做给节点画框架。通常情况下，当前节点布局，会同时触发其关联节点（祖先、后代节点以及兄弟节点）布局。多数布局本质都会造成页面重新渲染。 Paint绘制阶段，主要绘制节点的样式，可以看做给节点加个皮肤。包括初始的绘制 Paint 与后续的重绘 Repaint。与布局一致，绘制阶段也有全量与增量之分。 回流与重绘触发回流触发 窗口调整 字体变更 增删样式 操作节点 style 操作节点 class 内容变更 用户输入（input 等表单） 增删 dom 节点 节点尺寸变化 伪类激活 节点动画 读写 offsetWidth 等 基本上回流都会触发重绘 重绘触发如下仅讨论只触发重绘的情况 visibility 变化 backgroud 背景颜色变化 color 字体颜色 opacity 调整 这些属性的变化一般只简单影响元素的外观、风格。不影响节点的位置、形状等会几何属性的改变时，不会触发回流。 回流与重绘优化浏览器优化 队列机制 在现代浏览器中，由于回流重绘会有较大的性能损耗，多数浏览器会将回流重绘放入队列。当一定时间或操作到指定阀值，浏览器在将队列中的一次性进行处理，减少回流重绘次数。在上文回流触发中，读取 offsetWidth 等的值也会触发回流重绘，其根本原因就是由于这个优化。当代码在读取这些值时，为了获取准确的信息，浏览器不得不将队列清空强制执行回流重绘来得到这些值得最新信息。涉及的相关属性和方法包括： Getting box metrics elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParentelem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeightelem.getClientRects(), elem.getBoundingClientRect() Scroll stuff elem.scrollBy(), elem.scrollTo()elem.scrollIntoView(), elem.scrollIntoViewIfNeeded()elem.scrollWidth, elem.scrollHeightelem.scrollLeft, elem.scrollTop also, setting them 参见 What forces layout / reflow CSS3 硬件加速（GPU） 部分 CSS3 属性的通过设定会触发 GPU 加速，从而不会产生回流重绘。常见的属性有 transform、opacity、filters 等。在较新的浏览器中使用 will-change 来启用硬件加速。will-change 适用于上述属性，使用方式 .skyline &#123; will-change: transform;&#125; 在不支持 will-change的浏览器中，使用translateZ，但该属性仅对 transform 生效 .skyline &#123; transform: translateZ(0);&#125; 不要过分使用硬件加速，会有额外的性能消耗与内存占用。同时，对于 z-index 指定不同层级，低层使用硬件加速，高层也会被强制硬件加速。 代码优化在实际业务中，页面变化不可避免。回流与重绘优化的主要思路与浏览器优化思路基本一致，减少回流重绘次数。技术层面上，优化从 HTML、 CSS 与 JS 大方向入手。 HTML 精简节点嵌套层级避免出现无意义层级 CSS 使用浏览器硬件优化相关属性。 将动画应用于文档流外的节点。可能的话，将动画添加到 absolute 或 fixed 定位的节点上，脱离文档流的节点合成层不会影响其他合成层。 避免表达式属性。类似于 calc 的 css 属性设置方法会在其他节点或回流触发时进行重新计算，从而使得对应节点也触发回流。 JS class 变更选用更底层节点使用样式变更来改变节点而不是使用类变更类属性时，变更的节点尽可能往后而不是在其包裹或祖先节点上。 调整类而不是样式对于多条样式调整的节点，集中更改样式或添加修改类而不是分散修改样式 捆绑 DOM 调整对于 DOM 节点的调整，涉及到多次调整，可以捆绑最后再进行一次插入或替换 DOM 操作，具体方法有 documentFragment通过 documentFragment 新建文档流外的子树，将所有变更应用到子树，最后一次插入或替换到 DOM 中 display:none隐藏节点（display:none）脱离文档流，多次修改该节点，显示节点 集中读写样式代码 缓存引起强制重绘的属性或函数结果对于 clientWith 等引起强制重绘的属性或函数，多次使用时，使用变量缓存其值。 调整类而不是样式 // badvar left = 10, top = 10el.style.left = left + 'px'el.style.top = top + 'px'// betterel.className += ' theclassname'// betterel.style.cssText += '; left: ' + left + 'px; top: ' + top + 'px;' 捆绑 DOM 调整 function appendDataToElement(appendToElement, data) &#123; let li for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li') li.textContent = 'text' appendToElement.appendChild(li) &#125;&#125;const ul = document.getElementById('list')//badappendDataToElement(ul, data)// betterul.style.display = 'none'appendDataToElement(ul, data)ul.style.display = 'block'// betterconst fragment = document.createDocumentFragment()appendDataToElement(fragment, data)ul.appendChild(fragment) 集中读写样式代码 // badvar rh = document.getElementById('rect').clientHeightdocument.getElementById('rect').style.height = rh + 10 + 'px'var ch = document.getElementById('circle').clientHeightdocument.getElementById('circle').style.height = ch + 10 + 'px'//bettervar rh = document.getElementById('rect').clientHeightvar ch = document.getElementById('circle').clientHeightdocument.getElementById('rect').style.height = rh + 10 + 'px'document.getElementById('circle').style.height = ch + 10 + 'px' 缓存引起强制重绘的属性或函数结果 // badfunction initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px' &#125;&#125;//betterconst width = box.offsetWidthfunction initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px' &#125;&#125; 像素管道像素管道组成像素管道主要由五部分组成 JavascriptJS 用于变更页面元素，包括显示调整，动画加入等，这一部分也可由 CSS 动画，渐变以及部分 Web Animation API 来实现 Style这部分为样式计算，计算样式与哪些节点相对应。 Layout 回流基本都会会引起重绘，重绘不一定回流。一般来说，引起位置变化的都会回流并重绘，不引起位置变化的重绘即可。不管是浏览器底层还是业务代码层面，优化回流和重绘的基本思路都是减少其次数。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://dev.to/gopal1996/understanding-reflow-and-repaint-in-the-browser-1jbg 你真的了解回流和重绘吗 浏览器渲染之回流重绘 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/浏览器回流与重绘.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Refactor&Optimization","slug":"Refactor-Optimization","permalink":"http://www.skyline.show/tags/Refactor-Optimization/"}]},{"title":"Shell中的符号","slug":"Shell中的符号","date":"2021-05-27T07:41:03.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell中的符号.html","link":"","permalink":"http://www.skyline.show/Shell中的符号.html","excerpt":"引号 路径符 重定向符 命令执行符 符号标记 BMW WARNING 引号单引号和双引号主要可用于解决字符串中间有空格的问题。单引号将剥夺字符串中特殊字符的含义。双引号中的’$’进行参数替换’&#39;进行命令替换。 反引号与$()是一样的。 `或者$()会将其中的语句当作命令执行一遍，再将结果充当原命令行一部分。 skyline=1echo '$skyline`echo 1`'# $skyline`echo 1`echo \"$skyline`echo 1`\"# 11 路径符Shell 中路径相关的符号，如下表所示 符号 使用 说明 ~ cd ~ 用户主页目录 . ls . 当前目录 .. cd .. 上级目录 / cd / 根目录或路径分隔符 重定向符","text":"引号 路径符 重定向符 命令执行符 符号标记 BMW WARNING 引号单引号和双引号主要可用于解决字符串中间有空格的问题。单引号将剥夺字符串中特殊字符的含义。双引号中的’$’进行参数替换’&#39;进行命令替换。 反引号与$()是一样的。 `或者$()会将其中的语句当作命令执行一遍，再将结果充当原命令行一部分。 skyline=1echo '$skyline`echo 1`'# $skyline`echo 1`echo \"$skyline`echo 1`\"# 11 路径符Shell 中路径相关的符号，如下表所示 符号 使用 说明 ~ cd ~ 用户主页目录 . ls . 当前目录 .. cd .. 上级目录 / cd / 根目录或路径分隔符 重定向符 重定向符表 Shell 中包含输入与输出重定向相关的符号，如下表所示 符号 使用 说明 &gt; command &gt; file 将 command 输出重定向到 file。 &gt; n &gt; file 将文件描述符为 n 的文件重定向到 file。 &gt;&gt; command &gt;&gt; file 将 command 输出以追加的方式重定向到 file。 &gt;&gt; n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 &gt;&amp; n &gt;&amp; m 将输出文件 m 和 n 合并。 &lt; command &lt; file 将 command 输入重定向到 file。 &lt;&amp; n &lt;&amp; m 将输入文件 m 和 n 合并。 > 定义输出重定向command &gt; file 将 command 的输出重定向到 file常见用法 echo Hello &gt; test.txt 上述命令控制台不会有任何输出，Hello 文本将直接覆盖写入 test.txt 2&gt;&amp;1 2指标准错误，1指标准输出，将标准错误重定向到标准输出将错误的信息重新定向到输出，即”2&gt;1”，按照上面的写法，系统会将错误的信息重定向到一个名字为 1 的文件中，会有歧义，因此加&amp;进行区分。这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出 ​ &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃，会起到&quot;禁止输出&quot;的效果 >&gt; 表示追加到文件末尾，而不是一个&gt;时的覆盖 &lt; 输入重定向 command &lt; file 将输入重定向到 file，即将 file 中的内容作为 command 的参数 命令执行符 | 管道，管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入管道命令只处理前一个命令正确输出，不处理错误输出。管道右边的命令，必须能够接收标准输入的数据流命令，否则，管道后的命令将会抛弃之前的产生的结果管道符可以连接多个命令，多个管道时，控制台输出最后一个命令的内容 ! shell 中!叫做事件提示符，可以方便的引用历史命令，当! 后面跟随的字母不是“空格、换行、回车、=和(”时，可以做命令替换 !n 替换命令历史中第 n 个命令 !-n 替换命令历史中倒数第 n 个命令 !! 即!-1 !string 引用最近的以 string 开始的命令注意一定是开始的位置,这条命令在你运行一个命令之后忘记了这个命令的参数是什么，直接!命令既可 ​​ !?string? 指向包含这个字符串 string 的命令，包含字符即可 &amp; 所有命令同时进行 command1 &amp; command2 &amp; command3 &amp;&amp; 命令依次执行只有前面命令执行成功，后面命令才继续执行 command1 &amp;&amp; command2 ; 命令依次执行前面命令执行不管成功否，后面命令继续执行 command1; command2; command3 符号标记 符号标记表 符号 使用 说明 &lt;&lt; &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 # #sth 作为注释或字符剔除操作符 ? ls ?.js 单字符通配符 * ls *.js 多字符通配符 [] ls [abc].js 限定范围单字符通配符 _ mkdir -p ~/123/456 &amp;&amp; cd $_ _指定上个指令的输入参数，有其他用法不常用 ? ls ?.js# 会列出a.js,b.js，不会列出ab.js * ls *.js# 会列出当前目录下所有.js后缀文件 &lt;&lt; 将开始标记 tag 和结束标记 tag 之间的内容作为输入。标记常指定为 EOF 即（End Of File)，也可指定其他字符。此符号常与 cat 一起使用 cat &lt;&lt;EOF &gt;&gt; b.js 将后续输入的内容追加到 b.js 中，后续输入回车可换行，直到遇到 EOF 后退出文本编辑。 # #常用于注释，其他用法包括为剔除字符中的由头部开始指定字符 skyline='Skyline Liu!';echo How-To $&#123;skyline#Skyline&#125;# echo How-To $&#123;skyline#Liu&#125; 不会剔除Liu字符，不生效 指定的字符非变量开始字符为首字符（本例需要 S 开头），不起任何作用 获取字符或数组的长度 dir='/a/b/c'echo $&#123;#dir&#125;# 6arr=(1 2 3)echo $&#123;#arr&#125;# 3 BMW WARNING Bulletin I am a bucolic migrant worker but I never walk backwards. Material Shell 输入/输出重定向 Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"Git常见操作","slug":"Git常见操作","date":"2021-05-27T07:41:03.000Z","updated":"2023-01-24T09:57:11.000Z","comments":true,"path":"Git常见操作.html","link":"","permalink":"http://www.skyline.show/Git常见操作.html","excerpt":"回滚 revert reset git 删除分支 删除本地分支 删除远端分支 git 单列已添加到暂存区的文件 Git 本地分支有提交，单独查看并运行远程该分支 远程仓库迁移（拷贝） 新建仓库时关联远程与本地 git 同时推送多个仓库 git remote add git remote set-url https 方式访问 git 免输密码 Git 用户配置 查看配置 修改全局配置 GIT SSH 免密 同步 Github fork 仓库 BMW WARNING 回滚revertgit revert [commit-id] revert 可将代码回滚到指定版本，但会留下一条回滚记录 reset","text":"回滚 revert reset git 删除分支 删除本地分支 删除远端分支 git 单列已添加到暂存区的文件 Git 本地分支有提交，单独查看并运行远程该分支 远程仓库迁移（拷贝） 新建仓库时关联远程与本地 git 同时推送多个仓库 git remote add git remote set-url https 方式访问 git 免输密码 Git 用户配置 查看配置 修改全局配置 GIT SSH 免密 同步 Github fork 仓库 BMW WARNING 回滚revertgit revert [commit-id] revert 可将代码回滚到指定版本，但会留下一条回滚记录 reset git reset 一般接 –hard/soft/mixed git reset --soft soft当使用 soft 时，git 会重置到对应分支，所有代码变更被保留，且代码处于已暂存状态（git add 后未 git commit 的状态） mixedreset 默认就使用 mixed 参数，git 会重置到对应分支，所有代码变更被保留，且代码处于未暂存状态（git add 后的状态） hardreset 使用 hard 参数，git 会重置到对应分支，所有代码变更被丢弃，慎用 git 删除分支删除本地分支git branch -d &lt;branch&gt; 删除远端分支git push origin --delete &lt;branch&gt; git 单列已添加到暂存区的文件通过git status命令可以列出所有增删改的文件，并做了是否添加跟踪，是否加入暂存区的区分。若只看加入暂存区的文件，使用 git diff --name-only --cached 如上图所示为某次git status后展示的信息。git diff –name-only –cached 展示的信息如下git diff --cached只会展示暂存区文件的变更。 Git 本地分支有提交，单独查看并运行远程该分支本地 dev 分支有自己 commit 的版本，想要获取远端最新代码并运行（不包括本地新 commit 代码） git fetchgit checkout -b test origin/dev test 分支即是最新的远程 dev 副本 git fetch 将本地仓库的所有远程副本更新，但不会更新到工作空间 远程仓库迁移（拷贝）git remote set-url origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;//或者先删除后增加//git remote rm origin//git remote add origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;git branch --set-upstream-to=origin/master master//与远程关联git pull origin master --allow-unrelated-histories //后面参数防止出现fatal: refusing to merge unrelated histories 对于仓库拷贝并放在另一个仓库，至于要本地复制仓库文件夹，再进行如上操作即可。 新建仓库时关联远程与本地git remote add origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;git add -Agit commit -m\"init\"git push -u origin master git 同时推送多个仓库当前仓库正常开发，中途需要添加另一个推送仓库当前仓库只关联一个远程仓库，查看远端仓库信息：git remote -v结果如下 新增关联仓库常用如下两个方案： git remote addgit remote add origingit &lt;https://git.citycloud.com.cn:3000/hcsg_code/xxxx.git&gt; 查看远端仓库信息：git remote -v结果如下 这个地方只能是其他命名而不能是 origin 否则报错 本方案存在一个弊端，需要向远端仓库分别提交代码 git push origin master:mastergit push origingit master:master git remote set-urlgit remote set-url --add origin &lt;https://git.citycloud.com.cn:3000/hcsg_code/xxxx.git git remote -v结果如下 本方案提交时，所有仓库都会同步接收，推荐使用。 https 方式访问 git 免输密码在 git 早期版本中，https 方式每次都要输入密码，按照如下设置即可免去烦恼 设置记住密码（默认 15 分钟）：git config --global credential.helper cache 设置时间，可以这样做：git config credential.helper &#39;cache --timeout=3600&#39; 长期存储密码： linuxgit config --global credential.helper store macgit config --global credential.helper osxkeychain Git 用户配置查看配置# 查看全部配置git config --list#查看指定配置git config user.namegit config user.email 修改全局配置git config --global user.name \"username\"git config --global user.email \"email\" GIT SSH 免密查看本地 SSH 密钥 cd ~/.sshlsid_rsa 是私钥，id_rsa.pub 是公钥。 创建 SSH 密钥 如果没有相关密钥文件，需要生成 ssh-keygen 输入命令，生成相关文件 复制公钥 cat ~/.ssh/id_rsa.pub复制对应内容 远程仓库设置 在 github 等远程仓库设置页面对应的 SSH keys 粘贴公钥内容 同步 Github fork 仓库配置 remote，指向原始仓库 git remote add upstream https://github.com/skyline.git 获取上游仓库分支 获取到上游仓库分支，及相关的提交信息，它们将被保存在本地的 upstream/master，upstream/hotfix 等分支 git fetch upstream 切换到本地的 master 分支 git checkout master 合并上游分支 将 upstream/master 分支合并到本地的 master 分支，本地的 master 分支将与上游仓库保持同步，且不会丢失本地修改。 git merge upstream/master 上传代码 将上游仓库的代码更新到自己的远程仓库中 git push BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Git 常见操作.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"Git","slug":"Git","permalink":"http://www.skyline.show/tags/Git/"}]},{"title":"ES_Module&CommonJS","slug":"ES_Module&CommonJS","date":"2021-05-27T07:41:02.000Z","updated":"2023-02-04T08:24:24.000Z","comments":true,"path":"ES_Module&CommonJS.html","link":"","permalink":"http://www.skyline.show/ES_Module&CommonJS.html","excerpt":"模块系统 ESM VS CJS ESM VS CJS 要点解析 模块输出 模块加载 tree shaking BMW WARNING 模块系统早期 JS 出现只是作为脚本语言来进行简单的表单验证与控制简单动画，所有操作与变量都在全局进行，设计之初，不需要考虑模块系统。随着 JS 的发展，其应用越来越复杂，逐渐进入多 JS 脚本通过 script 标签引入的年代。多脚本需要解决脚本引入的顺序，脚本互相引入，脚本循环引入，全局命名污染，命名冲突等诸多问题，同时后期维护特别困难。对于复杂 JS 程序，需要解决的主要问题如下 模块隔离（私有代码权限访问控制） 模块间依赖 代码传递到执行环境 早期解决方案如下： 命名空间 立即执行匿名函数 + 闭包 ES5 时代，模块化的标准与方案有很多，亟需统一，ES6 的模块系统应运而生。由于影响力较大的 NodeJS 大方向参照了 CommonJS 标准，并在其上做了取舍，故本文主要对比 ES6 与 CommonJS 两种方案。其他规范 AMD（Asynchronous Module Definiton）如 requireJS,CMD(Common Module Definition)如 SeaJS 皆支持异步模块定义，在 ES6 模块系统后使用频率降低，如下简单对比。 AMD 典型示例 //依赖前置require(['a', 'b'], function (a, b) &#123; a.someFn() b.someFn()&#125;) CMD 典型示例 define('main', function (require, exports, module) &#123; var a = require('a') //依赖就近 a.someFn() var b = require('b') b.someFn()&#125;) 上述代码可以看到，AMD 规范在于依赖前置、提前执行，CMD 在于依赖就近、延迟执行。为了兼容各种模块系统，UMD(Universal Module Definition) 通用模块规范进行了兼容处理。常用的开源库打包后会生成 xxx.umd.jswebpack 打包后 UMD 兼容模块代码的如下： ;(function webpackUniversalModuleDefinition(root, factory) &#123; if (typeof exports === 'object' &amp;&amp; typeof module === 'object') //Node.js (拓展CommonJS),ES6 module.exports = factory() else if (typeof define === 'function' &amp;&amp; define.amd) //amd cmd define([], factory) else if (typeof exports === 'object') // CommonJS标准方案 exports['skyline-ui'] = factory() else root['skyline-ui'] = factory() // 未引入规范模块，全局申明&#125;)(typeof self !== 'undefined' ? self : this, function () &#123; // ...some code&#125;) ES6 兼容 Node.js 模块方案 ESM VS CJS 标准 输出 加载时机 加载方式 ES6 模块 值引用（只读） 编译 import 异步 CommonJS 值浅拷贝 运行 require 同步 ESM VS CJS 要点解析","text":"模块系统 ESM VS CJS ESM VS CJS 要点解析 模块输出 模块加载 tree shaking BMW WARNING 模块系统早期 JS 出现只是作为脚本语言来进行简单的表单验证与控制简单动画，所有操作与变量都在全局进行，设计之初，不需要考虑模块系统。随着 JS 的发展，其应用越来越复杂，逐渐进入多 JS 脚本通过 script 标签引入的年代。多脚本需要解决脚本引入的顺序，脚本互相引入，脚本循环引入，全局命名污染，命名冲突等诸多问题，同时后期维护特别困难。对于复杂 JS 程序，需要解决的主要问题如下 模块隔离（私有代码权限访问控制） 模块间依赖 代码传递到执行环境 早期解决方案如下： 命名空间 立即执行匿名函数 + 闭包 ES5 时代，模块化的标准与方案有很多，亟需统一，ES6 的模块系统应运而生。由于影响力较大的 NodeJS 大方向参照了 CommonJS 标准，并在其上做了取舍，故本文主要对比 ES6 与 CommonJS 两种方案。其他规范 AMD（Asynchronous Module Definiton）如 requireJS,CMD(Common Module Definition)如 SeaJS 皆支持异步模块定义，在 ES6 模块系统后使用频率降低，如下简单对比。 AMD 典型示例 //依赖前置require(['a', 'b'], function (a, b) &#123; a.someFn() b.someFn()&#125;) CMD 典型示例 define('main', function (require, exports, module) &#123; var a = require('a') //依赖就近 a.someFn() var b = require('b') b.someFn()&#125;) 上述代码可以看到，AMD 规范在于依赖前置、提前执行，CMD 在于依赖就近、延迟执行。为了兼容各种模块系统，UMD(Universal Module Definition) 通用模块规范进行了兼容处理。常用的开源库打包后会生成 xxx.umd.jswebpack 打包后 UMD 兼容模块代码的如下： ;(function webpackUniversalModuleDefinition(root, factory) &#123; if (typeof exports === 'object' &amp;&amp; typeof module === 'object') //Node.js (拓展CommonJS),ES6 module.exports = factory() else if (typeof define === 'function' &amp;&amp; define.amd) //amd cmd define([], factory) else if (typeof exports === 'object') // CommonJS标准方案 exports['skyline-ui'] = factory() else root['skyline-ui'] = factory() // 未引入规范模块，全局申明&#125;)(typeof self !== 'undefined' ? self : this, function () &#123; // ...some code&#125;) ES6 兼容 Node.js 模块方案 ESM VS CJS 标准 输出 加载时机 加载方式 ES6 模块 值引用（只读） 编译 import 异步 CommonJS 值浅拷贝 运行 require 同步 ESM VS CJS 要点解析 模块输出 ES6 ES6 模块输出的是对值的引用，即便是简单类型，模块内值的改变也会引起之后值得改变JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值（对象存在于导出模块的文件）。ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 例 1 // lib.jsexport let counter = 3export function incCounter() &#123; counter++&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib'console.log(counter) // 3incCounter()console.log(counter) // 4 例 2 // mod.jsfunction C() &#123; this.sum = 0 this.add = function () &#123; this.sum += 1 &#125; this.show = function () &#123; console.log(this.sum) &#125;&#125;export let c = new C()// x.jsimport &#123; c &#125; from './mod'c.add()// y.jsimport &#123; c &#125; from './mod'c.show()// main.jsimport './x'import './y'//输出1 引用只读 // lib.jsexport let obj = &#123;&#125;// main.jsimport &#123; obj &#125; from './lib'obj.prop = 123 // OKobj = &#123;&#125; // TypeError main.js 从 lib.js 输入变量 obj，可以对 obj 添加属性，但是重新赋值就会报错。因为变量 obj 指向的地址是只读的，不能重新赋值，这就好比 main.js 创造了一个名为 obj 的 const 变量 CommonJS 对应 CommonJS 规范中，导出的是一个对象，引入时采用的是对象的浅拷贝（在导出和导入时各有一个对象生成）。该对象的属性如果是简单类型，模块内部值得改变则不会对之后引用产生影响 // lib.jsvar counter = 3function incCounter() &#123; counter++&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;// main.jsvar mod = require('./lib')console.log(mod.counter) // 3mod.incCounter() // 引起lib.js中counter 值改变为4console.log(mod.counter) // 3 模块加载 加载时机 CommonJS 导出的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 加载方式 commonJS 规范用同步的方式加载模块.例如实现该规范的 nodeJS，因为在服务端，模块文件都存在本地磁盘，可以进行快速度读取，等待模块加载不会耗费过多的时间，所以这样做不会有问题。但是在浏览器端，限于网络等各种原因，需要使用异步加载获取更好的体验。 tree shaking由于 ES6 的模块暴露的是引用而不是生成一个对象.从加载时机来看，ES6 的 import 命令会被 JavaScript 引擎静态分析编译时就分析是否被引用，而不是在代码运行时加载。编译时加载使得对 ES6 静态分析并进行无用代码删除成为可能。这就是为什么 ES6 出来之后，tree shaking 才成为可能，这也是为什么要使用 tree shaking，必须使用 ES6 模块。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://es6.ruanyifeng.com/#docs/module-loader Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"Webpack中DllPlugin使用","slug":"Webpack中DllPlugin使用","date":"2021-05-27T07:41:02.000Z","updated":"2022-06-22T07:42:58.000Z","comments":true,"path":"Webpack中DllPlugin使用.html","link":"","permalink":"http://www.skyline.show/Webpack中DllPlugin使用.html","excerpt":"DllPlugin 概述 实质 DllPlugin 配置 引入 dll 库 手动引入 dll 文件（不推荐） 手动引入注意 自动引入(推荐) 自动引入常见问题 成果分析 优化前 优化后： BMW WARNING DllPlugin 概述实质DLL即动态链接库(Dynamic Link Library)。是指包含可由多个程序同时使用的代码库。在前端领域里可简单看做缓存，其实质是把项目中引入的较大模块先行分离出来，打包为DLL文件并存到硬盘里。再次打包时动态链接清单（manifest文件）中的文件就无需再次打包，从而优化打包速度，减少打包时间，其同时兼具分离模块的作用。 webpack v2 时已存在，在 v4+已不推荐使用该配置，新其版本迭代带来的性能提升足以忽略 DllPlugin 所带来的打包优化效益 DllPlugin 配置","text":"DllPlugin 概述 实质 DllPlugin 配置 引入 dll 库 手动引入 dll 文件（不推荐） 手动引入注意 自动引入(推荐) 自动引入常见问题 成果分析 优化前 优化后： BMW WARNING DllPlugin 概述实质DLL即动态链接库(Dynamic Link Library)。是指包含可由多个程序同时使用的代码库。在前端领域里可简单看做缓存，其实质是把项目中引入的较大模块先行分离出来，打包为DLL文件并存到硬盘里。再次打包时动态链接清单（manifest文件）中的文件就无需再次打包，从而优化打包速度，减少打包时间，其同时兼具分离模块的作用。 webpack v2 时已存在，在 v4+已不推荐使用该配置，新其版本迭代带来的性能提升足以忽略 DllPlugin 所带来的打包优化效益 DllPlugin 配置 webpack.dll.config.js 配置 新建单独的配置文件 webpack.dll.config.js var path = require('path')var webpack = require('webpack')module.exports = &#123; // 你想要打包的模块的数组 entry: &#123; vendor: [ 'vue/dist/vue.esm.js', 'vuex', 'axios', 'vue-router', 'element-ui', ], &#125;, output: &#123; path: path.join(__dirname, '../static/js'), // 打包后文件输出的位置 filename: '[name].dll.js', library: '[name]_library', // vendor.dll.js中暴露出的全局变量名。 // 主要是给DllPlugin中的name使用， // 故这里需要和webpack.DllPlugin中的`name: '[name]_library',`保持一致。 &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, '../', '[name]-manifest.json'), name: '[name]_library', context: __dirname, &#125;), // 压缩打包的文件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, &#125;, &#125;), ],&#125; 配置说明 path：manifest.json 生成的文件夹及名字，该项目让它生成在了根目录下。name：和 output. library 保持一致即可。context：选填，manifest 文件中请求的上下文，默认为该 webpack 文件上下文。 在 package.json 中添加执行脚本 \"dll\": \"webpack --config build/webpack.dll.conf.js\", 执行 yarn dll生成 dll 文件和 manifest.json 文件manifest.json 文件包含了引用模块的 id 映射，为 DllReferencePlugin 引用做准备 引入 dll 库手动引入 dll 文件（不推荐）在根目录的 index.html 里引入所生成的 dll 库 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\" /&gt; &lt;title&gt;xx市城市综合管理基础&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"/static/js/vendor.dll.js\"&gt;&lt;/script&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 手动引入注意如果前后端约定了项目访问 url 前缀，如’skyline’,则前端可以在 output.publicPath 指定值为’/skyline/‘同时手动引入是需为如下配置。 同时在测试环境 webpack.dev.conf.js 中，需要设定代理 proxyTable: &#123; '/skyline': &#123; target: 'http://localhost:8080/', // 本地地址，开发环境一旦端口变更就要更改，非常麻烦 pathRewrite: &#123; '^/skyline/static': '/static' &#125;,&#125; 自动引入(推荐)html-webpack-tags-plugin 插件 html-webpack-tags-plugin 插件默认会把 publicPath 加入文件地址前缀，当 output.publicPath = ‘skyline’ 时，插入代码为 html-webpack-tags-plugin 配置代码 new HtmlWebpackTagsPlugin(&#123; tags: ['static/js/vendor.dll.js'], append: false // 默认true&#125;), 自动引入常见问题append 使用默认 true 将会有以下错误这里是由于插入的代码位置不对设定为 false 之后，插入位置如下 Uncaught ReferenceError: \\_dll_vendor is not defined 造成这个错误主要有 4 个可能的原因： context 上下文不一致(DllPlugin context 与 DllReferencePlugin context 一致)library 和 name 不一致（output.library 需要和 DllPlugin option.name 一致）生成的 dll 文件没加入到 html 文件中生成的 dll 文件没加入到 html 文件中位置不对，如本文所示 DllReferencePlugin 配置 plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, //这个上下文对应DllPlugin manifest: require('./vendor-manifest.json'), &#125;),] 成果分析优化前 优化后： BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 DllPlugin &gt; webpack 进阶——DllPlugin 优化打包性能（基于 vue-cli） Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"Packages","slug":"Packages","permalink":"http://www.skyline.show/tags/Packages/"},{"name":"Webpack","slug":"Webpack","permalink":"http://www.skyline.show/tags/Webpack/"}]},{"title":"排序算法","slug":"排序算法","date":"2021-05-27T07:41:02.000Z","updated":"2023-02-02T07:41:06.000Z","comments":true,"path":"排序算法.html","link":"","permalink":"http://www.skyline.show/排序算法.html","excerpt":"选择排序 选排的思想 时间复杂度 冒泡排序 基本思路 时间复杂度 交换判定优化 插入排序 插排的思想 时间复杂度分析 哨兵优化 折半优化 归并排序（Merge Sort） 归并排序思路 合并 时间复杂度分析 快速排序 快排思路 选值优化 多路快排 希尔排序（缩小增量排序） 关键思路 时间复杂度 计数排序 关键思路 时间复杂度分析 堆排序 完全二叉树 堆 构造堆 排序 BMW WARNING 选择排序选排的思想找出每一轮的最值并放在该轮次位置处核心思想是每轮选最值外层循环确定轮次，内层循环确定最值。 def selectionSort(nums): for i in range(len(nums)): pos = i for j in range(i + 1, len(nums)): if nums[pos] &gt; nums[j]: pos = j nums[i], nums[pos] = nums[pos], nums[i] return nums 时间复杂度","text":"选择排序 选排的思想 时间复杂度 冒泡排序 基本思路 时间复杂度 交换判定优化 插入排序 插排的思想 时间复杂度分析 哨兵优化 折半优化 归并排序（Merge Sort） 归并排序思路 合并 时间复杂度分析 快速排序 快排思路 选值优化 多路快排 希尔排序（缩小增量排序） 关键思路 时间复杂度 计数排序 关键思路 时间复杂度分析 堆排序 完全二叉树 堆 构造堆 排序 BMW WARNING 选择排序选排的思想找出每一轮的最值并放在该轮次位置处核心思想是每轮选最值外层循环确定轮次，内层循环确定最值。 def selectionSort(nums): for i in range(len(nums)): pos = i for j in range(i + 1, len(nums)): if nums[pos] &gt; nums[j]: pos = j nums[i], nums[pos] = nums[pos], nums[i] return nums 时间复杂度 选择排序的比较次数 = (n - 1) + (n - 2) + … + 2 + 1 = n * (n - 1) / 2，因此时间复杂度为：O(n²)。 冒泡排序基本思路每一轮通过不断对比交换位置来将该轮最大（小）值上浮（下沉）到对应轮位置核心思想是每轮换位置外层循环确定轮次，内层循环交换位置。 def bubbleSort(nums): for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] return nums 每一轮都进行了多次交换，故相较于选择排序耗时 时间复杂度冒泡排序的比较次数 = (n - 1) + (n - 2) + … + 2 + 1，即：n * (n - 1) / 2，所以冒泡排序的时间复杂度为：O(n²)冒泡排序最优情况的时间复杂度是：O(n) 要达到这个复杂度，上述代码需要进一步优化 交换判定优化对于已经有序的数列，进行了冗余的循环操作，通过在每轮进行交换标记来进行优化 # 冒泡交换判定优化def optimizeBubbleSort(nums): for i in range(len(nums)): swap = False for j in range(i + 1, len(nums)): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] swap = True if not swap: return nums return nums 插入排序插排的思想将 list 分为两部分，前部分作为已排序部分并向其中插入值，注意插入值之后值的移动外层循环确定插入值，内层循环确定插入位置 # 插入排序# 外层循环确定插入值，内层循环确定插入位置# 将list分为两部分，前部分作为已排序部分并向其中插入值，注意值的移动def insertionSort(nums): for i in range(1, len(nums)): if nums[i] &lt; nums[i - 1]: j = i - 1 aim = nums[i] while aim &lt; nums[j] and j &gt; -1: nums[j + 1] = nums[j] j -= 1 nums[j + 1] = aim return nums 时间复杂度分析最坏的情况下，即整个数组是倒序的，比较次数 = 1 + 2 + 3 + … + (n - 2) + (n - 1) = n * (n - 1) / 2，此时的时间复杂度为：O(n²)。在最好的情况下，即整个数组是正序的，比较次数 = n - 1，此时的时间复杂度为：O(n) 哨兵优化在插入排序循环判定中，aim &lt; nums[j] and j &gt; -1，即既要保证不越界又要判断数据是否符合条件，用哨兵代替上述两个条件，每次循环只需一次比较，可以减少一半的比较次数。 哨兵的作用 暂时存放待插入的元素 监视数组下标越界 def sentryInsertionSort(nums): nums.append(nums[0]) for i in range(1, len(nums)): if nums[i] &lt; nums[i - 1]: j = i - 1 nums[0] = nums[i] while nums[0] &lt; nums[j]: nums[j + 1] = nums[j] j -= 1 nums[j + 1] = nums[0] return nums[1:] 折半优化前半部分由于已经排序，故可通过二分查找找出插入位置 # 插入排序折半优化def binaryInsertionSort(nums): for i in range(1, len(nums)): if nums[i] &lt; nums[i - 1]: aim = nums[i] s,m,e = 0, 0, i - 1 while s &lt; e: m = s + e &gt;&gt; 1 if aim &gt; nums[m]: s = m + 1 else: e = m j = i while j &gt; e: nums[j] = nums[j - 1] j -= 1 nums[e] = aim return nums 归并排序（Merge Sort）归并排序思路归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个元素，接着将小数组归并成有序的较大的数组，最后变成一个排序完成的大数组。归并排序中，归是指递归，并即合并递归进行拆分，合并进行排序（两个有序数组合为新的有序数组）归并排序与快排最大的不同在于重合并不重划分，归并需要合并两个有序数列，在划分时，无脑取中位即可。 # 归并排序# 归并排序的主要思想是分治# 将n个元素从中间切开，分成两部分。（左右可能长度差1）# 递归分解，直到所有部分的元素个数都为1# 从最底层开始逐步向上合并两个排好序的数列# 并# 合并两个有序数组为新的有序数组def mergeSorted(nums1, nums2): nums = [] i, j = 0, 0 l = len(nums2) while i &lt; len(nums1): if nums1[i] &lt;= nums2[j]: #判定条件为 nums1[i] &lt; nums2[j]时不稳定 nums.append(nums1[i]) i += 1 else: nums.append(nums2[j]) j += 1 if (j == l): break return nums + nums1[i:] + nums2[j:]# 归def recursionMergeSort(nums): l = len(nums) if l &lt; 2: return nums else: # 整除 m = l // 2 return mergeSorted(recursionMergeSort(nums[:m]), recursionMergeSort(nums[m:])) mergeSorted 方法里面的 nums1[i] &lt;= nums2[j] ，保证了值相同的元素，在合并前后的先后顺序不变。归并排序是一种稳定的排序方法 合并如何将两个有序数组合并成一个新的有序数组?轮番比较两个数列的最低位，直到一方全部比较完毕 def mergeSorted(nums1, nums2): nums = [] i, j = 0, 0 l = len(nums2) while i &lt; len(nums1): if nums1[i] &lt; nums2[j]: nums.append(nums1[i]) i += 1 else: nums.append(nums2[j]) j += 1 if (j == l): break return nums + nums1[i:] + nums2[j:] 由于合并函数需要另开内存空间存储新的数组，归并排序不是原地排序算法。 时间复杂度分析递归中的时间复杂度为 logn，合并数组最多循环 n 次归并排序的时间复杂度为 O(nlogn) 快速排序快排思路采用分治的思想，选取一个值为基准值，假设其放在正确顺序位置 pos，将比其小的放在其前面，比其大的放在其后面，从 pos 处将数列砍成两半，对子序列递归执行前述操作递归进行拆分，双指针进行排序快排重划分，不需要合并，在划分时，可以随意选择一个值，但选值得大小将影响排序的效率通过双指针找到选择值在数列中的正确位置 取中位 取中位，在将中位交换到对应位置时，对比取边界，需要做比较多的处理，容易出错 def quickSort(nums, start, end): if end - start &lt; 1: return # m可取数列中任意数，此处取中位 s, m, e = start, start + end &gt;&gt; 1, end # 通过双指针找到nums[m]正确位置 while s &lt;= e: # 取值判定加等号，防止nums[m]值被交换 while s &lt;= e and nums[s] &lt;= nums[m]: s += 1 # 取值判定加等号，防止nums[m]值被交换，针对中位取值 while s &lt;= e and nums[e] &gt;= nums[m]: e -= 1 if s &lt; e: nums[s], nums[e] = nums[e], nums[s] # 通过交换将nums[m]放在正确的位置 if m &gt; s: nums[s], nums[m] = nums[m], nums[s] # 移动位置，缩减nums[m]位置，防止某些情况死循环（如所有值一致） s += 1 else: nums[e], nums[m] = nums[m], nums[e] e -= 1 if start &lt; e: quickSort(nums, start, e) if s &lt; end: quickSort(nums, s, end) 取边界 def quickSort(nums, start, end): if end - start &lt; 1: return s, m, e = start + 1, start, end # 选取第一个值为基准值 while s &lt;= e: while s &lt;= e and nums[s] &lt; nums[m]: # 找出左边以一个比基准大的数的位置 s += 1 while s &lt;= e and nums[e] &gt;= nums[m]: # 找出右边以一个比基准小的数的位置 e -= 1 if s &lt; e: # 交换双方位置，并进入中间尚未比较位置继续对比交换 nums[s], nums[e] = nums[e], nums[s] nums[e], nums[m] = nums[m], nums[e] if start &lt; e: quickSort(nums, start, e - 1) if s &lt; end: quickSort(nums, s, end) 选值优化 随机选值基准值随机地选取，而不是每次都取第一个数。这样就不会受正序或逆序的数组的干扰 三数取中前中后选三个值选取三数的中位数，以降低取到最大或最小值的概率。三数取中时，比较的同时应将三个元素按中间，小，大的顺序重新排好位置 多路快排在遍历数列时选用指针的数量 单路基准值 base 左边的都比 base 小，而 base 右边的都大于等于 base。等于 base 的这些会聚集到右侧(或者稍微改改大小关系就会聚集到左侧)。总之就会聚集到一边。这样在数组中重复数字很多的时候，就又会导致两边子递归规模差距悬殊的情况 双路上述代码采用的就是双路 三路对于大于小于等于分别选用一个指针在当前值小于目标值时，s 与 c 齐头并进，直到等于出现时，s 停留在第一个相等的位置，c 开始往后移动，通过 c 做中介来交换 s 与 e 位置的值 def quickSort(nums, start, end): if end - start &lt; 1: return s, c, m, e = start + 1, start + 1, start, end while c &lt;= e: if nums[c] == nums[m]: c += 1 elif nums[c] &lt; nums[m]: nums[s], nums[c] = nums[c], nums[s] s += 1 c += 1 else: nums[e], nums[c] = nums[c], nums[e] e -= 1 nums[e], nums[m] = nums[m], nums[e] if start &lt; e: quickSort(nums, start, e - 1) if s &lt; end: quickSort(nums, s, end) 时间复杂度分析待排序为正序或逆序，取值也为最值，这样每次分割后的子序列一个之比上一次序列少一个元素,最终 O(n²)平均为 O(nlogn) 希尔排序（缩小增量排序）关键思路希尔排序又叫缩小增量排序希尔排序是插入排序的优化版本，在插入排序中，将数列分为有序与无序部分，若无序部分的头部每次都需要插入到有序部分的头部，那么最终的总复杂度会到 n²希尔排序将数列每一轮分为多个子数列，对每个子数列进行插入排序，直至整体基本有序时（增量为 1 前），再对全体记录进行插入排序（增量为 1）起来就容易了(由于最后一次基本有序无须多次移位或交换) def shellSort(nums): span = len(nums) while span &gt; 1: span //= 2 # span取数跨度，先将整个待排序的记录序列分割成为若干子序列，每轮缩小取数跨度，子数列长度 insertionSort(nums, span) return numsdef insertionSort(nums, span): for pos in range(span, len(nums), 1): # 由span位置开始，到len(nums) - 1位置结束， 循环步长为1 if nums[pos] &lt; nums[pos - span]: pre = pos - span aim = nums[pos] while aim &lt; nums[pre] and pre &gt; -1: nums[pos] = nums[pre] # 数后移 pre -= span nums[pre + span] = aim 时间复杂度希尔排序的时间复杂度最佳情况：O(n logn)。 最差情况：O(n (log(n))²)。 平均情况：取决于间隙序列 计数排序关键思路对于一个自然数数组 A，选取数组中的最大值 m，然后初始化一个长度为 m + 1 的备用数组 B。对于数组 BB 的索引对应数组 A 的值B 的值对应数组 A 中相应值的个数C 的值记录 A 顺序后前面出现值的个数例如 A = [3, 3, 9, 2, 2, 2, 0]# B = [1, 0, 3, 2, 0, 0, 0, 0, 0, 1]# C = [1, 1, 4, 6, 6, 6, 6, 6, 6, 7]# 以3为例# B: 3有两个# C: 如果有3，最后一个3位于第6位，即索引为5def countingSort(nums): counts = [0] * (max(nums) + 1) for i in nums: counts[i] += 1 accumulation = 0 for index, value in enumerate(counts): accumulation += value counts[index] = accumulation rets = [0] * len(nums) for v in nums: rets[counts[v] - 1] = v counts[v] -= 1 # 下一个相同值索引减1 return rets 时间复杂度分析计数排序利用了空间换时间，对于不同的实现（比如最大值判定循环等），其内部始终是遍历两个定长的数组。O(max)+O(len)+… = O(max+len)即其时间复杂度为 O(n + k) 堆排序完全二叉树二叉树是指最多只存在两个子节点的树形数据结构。完全二叉树是指除了最后一层的叶子节点，每一层节点都存在，且最后一层的叶子节点由左起依次排列不能留空。 数组可以表示一个典型的完全二叉树。i（索引） 为 0 的节点为根节点。所有左子节点的索引为 2i+1，右子节点的索引为 2i+2。同时，可以通过(i-1)/2 获取其父节点的值 堆堆是一颗完全二叉树，且对于所有节点，都要满足父节点的值大于等于（或小于等于）子节点的值。父节点大于等于子节点时，称为大顶堆父节点小于等于子节点时，称为小顶堆 构造堆当跟节点的左子树和右子树已经为堆时，加入父节点构造堆。 # 当跟节点的左子树和右子树已经为堆时，加入父节点构造堆def heapify(nums, pos): length = len(nums) mark = pos left = 2 * pos + 1 right = 2 * pos + 2 if(left &lt; length and nums[pos] &lt; nums[left]): pos = left if(right &lt; length and nums[pos] &lt; nums[right]): pos = right if(mark != pos): nums[mark], nums[pos] = nums[pos], nums[mark] heapify(nums, pos) # 交换位置后，子树需要重新构造堆 return nums 对于任意完全二叉树（数组）构造堆 # 对于任意完全二叉树（数组）构造堆def heapifyArr(nums): start = (len(nums) - 1) // 2 # 大于此索引的其他节点是叶子节点 while (start &gt; -1): heapify(nums, start) #所有非叶子节点，由下到上，从右到左依次遍历构造堆 start -= 1 return nums 排序对于任意数组，当调用上述方法构造堆后，可得其最值位于根节点（索引为 0）利用该特性，堆排序思路如下 将数组构造成堆 交换堆的首节点与尾节点，移除此时处于最后的根节点（或记录偏移位置）。 对于剩下的完全二叉树，根节点的左右子树仍为堆，采用 heapify 来将剩下的完全二叉树构造成堆。 重复 2、3 步，直到移除完所有节点 # 堆排序def heapSort(nums): pos = len(nums) - 1 heapifyArr(nums) ret = [] arr = nums while pos &gt; -1: arr = heapify(arr[:pos + 1], 0) ret.append(arr[0]) arr[0], arr[pos] = arr[pos], arr[0] pos -= 1 return ret 上述排序引入了多余的数组来最后存储与中间存储相关结果，通过对偏移量的记录，所有操作可以源数组进行（原地排序）进一步优化 # 当跟节点的左子树和右子树已经为堆时，加入父节点构造堆def heapify(nums, offset, pos): # length = len(nums) mark = pos left = 2 * pos + 1 right = 2 * pos + 2 if(left &lt; offset and nums[pos] &lt; nums[left]): pos = left if(right &lt; offset and nums[pos] &lt; nums[right]): pos = right if(mark != pos): nums[mark], nums[pos] = nums[pos], nums[mark] heapify(nums, offset, pos) # 交换位置后，子树需要重新构造堆 # return nums# 对于任意完全二叉树（数组）构造堆def heapifyArr(nums): start = (len(nums) - 1) // 2 # 大于此索引的其他节点是叶子节点 while (start &gt; -1): heapify(nums, len(nums), start) # 所有非叶子节点，由下到上，从右到左依次遍历构造堆 start -= 1 # return nums# 堆排序def heapSort(nums): offset = len(nums) - 1 heapifyArr(nums) # ret = [] # arr = nums while offset &gt; -1: heapify(nums, offset, 0) nums[0], nums[offset] = nums[offset], nums[0] offset -= 1 return numsnums = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]# nums = [1, 12, 9, 5, 6, 10]heapSort(nums)print(nums) BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://zhuanlan.zhihu.com/p/36075856 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"},{"name":"算法","slug":"算法","permalink":"http://www.skyline.show/tags/算法/"}]},{"title":"Shell中grep的使用","slug":"Shell中grep的使用","date":"2020-09-12T07:14:56.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell中grep的使用.html","link":"","permalink":"http://www.skyline.show/Shell中grep的使用.html","excerpt":"使用 基础使用 正则 递归查找子目录 忽略大小写 匹配次数 静默查找 选项 BMW WARNING 使用基础使用grep 是一个字符搜索命令，使用的基础语法为 grep [options] pattern [files] 正则","text":"使用 基础使用 正则 递归查找子目录 忽略大小写 匹配次数 静默查找 选项 BMW WARNING 使用基础使用grep 是一个字符搜索命令，使用的基础语法为 grep [options] pattern [files] 正则 ^ 匹配的字符在行首$ 匹配的字符在行尾 grep ^grep Docs/Major/Shell/Commands/Shell中grep的使用.mdgrep shell$ Docs/Major/Shell/Commands/Shell中grep的使用.md 可通过 -e 来开启正则匹配模式，-e 参数在使用多次时很有用 # 搜索包含shell 和grep的行grep -e shell -e grep Docs/Major/Shell/Commands/Shell中grep的使用.md 递归查找子目录-r 选项在项目根目录尝试输入如下命令 grep -r shell -e grep Docs/Major/Shell/ 忽略大小写-i 选项在项目根目录尝试输入如下命令 grep -i shell Docs/Major/Shell/Commands/Shell中grep的使用.md 匹配次数-c 选项，获取匹配次数在项目根目录尝试输入如下命令 grep -c shell Docs/Major/Shell/Commands/Shell中grep的使用.md# 6 静默查找-q 选项静默查找，不做打印输出，只有运行结果状态。常用语条件判定等情况不指定时即为关闭静默。关闭静默 STR='GNU/Linux is an operating system'SUB='Linux'if grep \"$SUB\" &lt;&lt;&lt; \"$STR\"; then echo \"It's there\"fi# GNU/Linux is an operating system# It's there 开启静默 STR='GNU/Linux is an operating system'SUB='Linux'if grep -q \"$SUB\" &lt;&lt;&lt; \"$STR\"; then echo \"It's there\"fi# It's there 选项 选项 描述 q 静默查找，不做输出，常用语条件判定等情况 r 递归查找子目录文件 n 列出行标 i 忽略大小写 e 搜索时启用正则匹配，可使用多次 w 精确指定单词，需要为单词，英文单词前后有字母不匹配 l 只输出匹配的文件名 c 输出匹配字符次数 o 只输出的匹配字符，多个匹配换行输出 v 反转输出，输出不匹配该字符的行 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Shell 中 grep 的使用.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"PS更换指定颜色","slug":"PS更换指定颜色","date":"2020-07-11T10:02:04.000Z","updated":"2022-06-22T07:43:00.000Z","comments":true,"path":"PS更换指定颜色.html","link":"","permalink":"http://www.skyline.show/PS更换指定颜色.html","excerpt":"效果展示 替换颜色 颜色叠加 新选区图层 BMW WARNING 效果展示 替换颜色素材地址首先选中图片或图层。 在 图像 &gt; 调整 &gt; 替换颜色 开启颜色替换工具 在工具中，可以通过拾色器选取被替换色与想要的目标色。选中预览，可通过调整容差可实时预览得到想要的结果。 一个实际的例子如下 按住 command 或 control 键可以在预览中切换选中颜色和原图 颜色叠加","text":"效果展示 替换颜色 颜色叠加 新选区图层 BMW WARNING 效果展示 替换颜色素材地址首先选中图片或图层。 在 图像 &gt; 调整 &gt; 替换颜色 开启颜色替换工具 在工具中，可以通过拾色器选取被替换色与想要的目标色。选中预览，可通过调整容差可实时预览得到想要的结果。 一个实际的例子如下 按住 command 或 control 键可以在预览中切换选中颜色和原图 颜色叠加 本方法适用于单色图标等素材。双击图层，选项中选中 混合选项。 点击颜色叠加 + 可以添加多个颜色叠加 点击选择颜色 选择透明度，多个颜色叠加，后面的颜色需要透明度&lt;100%才可以显现 勾选可调整叠加的颜色 Gradient Overlay 为渐变色叠加。效果如下： 新选区图层在容易抠图的素材中，用魔法选择工具选中需要替换颜色的选区。点击右下角图标，选择 solid color(纯色) 选择需要替换的颜色即可 替换为纯色后，明暗层次效果消失，修改图层混合样式为 color(颜色)或其他选择恢复层次效果。图层混合样式在上图中国标记 1 的位置，被弹窗覆盖了 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://huaban.com/pins/4322595709/ Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"APPs","slug":"APPs","permalink":"http://www.skyline.show/tags/APPs/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://www.skyline.show/tags/Photoshop/"}]},{"title":"磁盘阵列","slug":"磁盘阵列","date":"2019-04-21T10:02:01.000Z","updated":"2022-06-22T07:42:57.000Z","comments":true,"path":"磁盘阵列.html","link":"","permalink":"http://www.skyline.show/磁盘阵列.html","excerpt":"简介 对比 总览 优劣 RAID 0 RAID 1 RAID 5 RAID 6 RAID 10 BMW WARNING 简介独立冗余磁盘阵列(Redundant Arrays Of Independent Disks)，简写 RAID。RAID 技术用以提升存储的性能与可靠性。 对比总览","text":"简介 对比 总览 优劣 RAID 0 RAID 1 RAID 5 RAID 6 RAID 10 BMW WARNING 简介独立冗余磁盘阵列(Redundant Arrays Of Independent Disks)，简写 RAID。RAID 技术用以提升存储的性能与可靠性。 对比总览 阵列 最少硬盘 关键词 原理 RAID 0 2 striping 资料会被均分并写入不同的硬盘上 RAID 1 2 mirroring 数据将会被复制到所有的硬盘上 RAID 5 3 striping + parity 数据会被均分到不同的硬盘上并加上同比特位的数据检查 RAID 6 4 striping + double parity 数据会被均分到不同的硬盘上并加上两份同比特位的数据检查 RAID 10 4 mirroring + striping 混合 RAID0 与 RAID1 优劣 阵列 优势 劣势 RAID 0 数据存取会更快速并更有效率， 多盘同时读取 理论速度为磁盘读写总和。硬盘总量即可用空间量 没有容错机制，单硬盘损毁，所有数据遗失 RAID 1 不管坏了几颗硬盘，只要还有一颗硬盘是正常的，数据将不受影响，由备份来重建数据较快，实现技术简单 无论硬盘数量，可用空间会被局限同容量最小的硬盘 RAID 5 读速快，由于写数据需要同时写校验数据，写速稍慢；奇偶校验确保数据的完整性 添加了比特校验数据的存储，由校验数据来重建速度较慢，实现技术复杂，影响总空间。硬盘不可同时故障 RAID 6 同 RAID5，读速快，写速比 RAID5 稍慢；更安全，允许两块硬盘同时故障 写速比 RAID 5 慢，故障重建时间较长 RAID 10 兼有存取与安全的双重优势，重建数据由备份数据而来（而不是校验数据恢复），速度快。 需要一半空间用于备份数据 RAID 2/3/4/7/8/9 也存在，但是不常用。例如，RAID 3 与 RAID 5 类似，只不过其校验数据会放在同一块硬盘上 RAID 0 RAID 1 RAID 5 RAID 6 RAID 10 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://www.prepressure.com/library/technology/raid Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Hardware","slug":"Hardware","permalink":"http://www.skyline.show/tags/Hardware/"},{"name":"硬盘","slug":"硬盘","permalink":"http://www.skyline.show/tags/硬盘/"}]},{"title":"Shell中数组相关操作","slug":"Shell中数组相关操作","date":"2019-03-22T07:14:56.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Shell中数组相关操作.html","link":"","permalink":"http://www.skyline.show/Shell中数组相关操作.html","excerpt":"获取数组长度 列出数组项 数组合并 数组遍历 数组下标获取 数组转字符串 BMW WARNING 获取数组长度skyline=(4 3 2 1)echo $&#123;#skyline[*]&#125;# 4echo $&#123;#skyline[@]&#125;# 4 列出数组项 列出所有项 skyline=(4 3 2 1)echo $&#123;skyline[@]&#125;# 4 3 2 1echo $&#123;skyline[*]&#125;# 4 3 2 1 列出单项 skyline=(4 3 2 1)echo $&#123;skyline[1]&#125;# 3 数组合并","text":"获取数组长度 列出数组项 数组合并 数组遍历 数组下标获取 数组转字符串 BMW WARNING 获取数组长度skyline=(4 3 2 1)echo $&#123;#skyline[*]&#125;# 4echo $&#123;#skyline[@]&#125;# 4 列出数组项 列出所有项 skyline=(4 3 2 1)echo $&#123;skyline[@]&#125;# 4 3 2 1echo $&#123;skyline[*]&#125;# 4 3 2 1 列出单项 skyline=(4 3 2 1)echo $&#123;skyline[1]&#125;# 3 数组合并 skyline=(4 3 2 1)lty=(2 3 4)ret=($skyline $lty)echo $ret# 4 3 2 1 2 3 4 skyline=(4 3 2 1)ret=($skyline 2 3 4)echo $ret# 4 3 2 1 2 3 4 当数组添加项只有一项时，即可实现 JS 数组类似于 push 的效果 skyline=(4 3 2 1)ret=($skyline 0)echo $ret# 4 3 2 1 0 数组遍历skyline=(4 3 2 1)for value in $skyline# for value in \"$&#123;skyline[@]&#125;\"do echo $valuedone# 4# 3# 2# 1for (( i=1; i&lt;=$&#123;#skyline&#125;; i++ ))do echo $&#123;skyline[$i]&#125;done# 4# 3# 2# 1 数组下标获取skyline=(4 3 2 1)echo $&#123;skyline[1]&#125;# 3echo $&#123;skyline[2]&#125;# 2echo $&#123;skyline[-1]&#125;# 1echo $&#123;skyline[-2]&#125;# 2 数组转字符串直接赋值后即为以空格分隔的字符串，若需要将空格换成其他字符串，使用${STRING//DELIMITER/SUBSTITUTION}方案更换 ARR=(1 2 3 4);STR=$ARR# 将空格换成|SKYLINE=$&#123;STR// /|&#125;echo $SKYLINE# 1|2|3|4 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Shell 中数组相关操作.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"CSS弹性布局主轴元素设置单独对齐方式","slug":"CSS弹性布局主轴元素设置单独对齐方式","date":"2018-07-30T07:14:56.000Z","updated":"2023-01-24T09:57:07.000Z","comments":true,"path":"CSS弹性布局主轴元素设置单独对齐方式.html","link":"","permalink":"http://www.skyline.show/CSS弹性布局主轴元素设置单独对齐方式.html","excerpt":"效果图示 效果实现 BMW WARNING 效果图示灰色为 flex 盒子，其水平方向的主轴内部有 4 个子元素。通过设置特定属性将最后红框圈出的元素置于容器最右侧。 实现效果 效果实现 方案 1为红框子元素设定如下属性 .red &#123; flex-grow: 1; //红框子项目将占据了所有剩余空间 display: flex; //将自身设置为flex,作为容器之后就可以单独对内部文字项目进行右对齐 justify-content: flex-end; // 单独对内部文字项目进行右对齐&#125; 通过浏览器检视如下 方案 2 将前 3 个子元素进行一层包裹，然后调整容器的 justify-contentjustify-content: space-between 方案 3 为红框子项目添加如下属性 margin-left: auto; 方案 4 为红框子项目添加如下属性 .red &#123; flex-grow: 1; text-align: right;&#125; BMW WARNING","text":"效果图示 效果实现 BMW WARNING 效果图示灰色为 flex 盒子，其水平方向的主轴内部有 4 个子元素。通过设置特定属性将最后红框圈出的元素置于容器最右侧。 实现效果 效果实现 方案 1为红框子元素设定如下属性 .red &#123; flex-grow: 1; //红框子项目将占据了所有剩余空间 display: flex; //将自身设置为flex,作为容器之后就可以单独对内部文字项目进行右对齐 justify-content: flex-end; // 单独对内部文字项目进行右对齐&#125; 通过浏览器检视如下 方案 2 将前 3 个子元素进行一层包裹，然后调整容器的 justify-contentjustify-content: space-between 方案 3 为红框子项目添加如下属性 margin-left: auto; 方案 4 为红框子项目添加如下属性 .red &#123; flex-grow: 1; text-align: right;&#125; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/CSS 弹性布局 flex 主轴元素设置单独对齐方式.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"ES继承的实现","slug":"ES继承的实现","date":"2018-01-26T12:49:44.000Z","updated":"2023-02-14T08:05:52.000Z","comments":true,"path":"ES继承的实现.html","link":"","permalink":"http://www.skyline.show/ES继承的实现.html","excerpt":"原型链 概述 代码示例 优劣分析 构造函数 概述 代码示例 优劣分析 组合继承 概述 代码示例 优劣分析 原型式继承(Object.create) 概述 代码示例 优劣分析 寄生式继承 概述 代码示例 优劣分析 寄生组合式继承 概述 代码示例 优劣分析 BMW WARNING 原型链概述由于函数没有签名，ES无法实现接口继承 原型链继承的本质是重写原型对象，代之以一个新类型的实例 通过instanceof isPrototypeOf 来判定原型与实例的关系 给原型添加方法需要在替换原型之后 通过原型链继承，不能通过字面量重写原型 代码示例","text":"原型链 概述 代码示例 优劣分析 构造函数 概述 代码示例 优劣分析 组合继承 概述 代码示例 优劣分析 原型式继承(Object.create) 概述 代码示例 优劣分析 寄生式继承 概述 代码示例 优劣分析 寄生组合式继承 概述 代码示例 优劣分析 BMW WARNING 原型链概述由于函数没有签名，ES无法实现接口继承 原型链继承的本质是重写原型对象，代之以一个新类型的实例 通过instanceof isPrototypeOf 来判定原型与实例的关系 给原型添加方法需要在替换原型之后 通过原型链继承，不能通过字面量重写原型 代码示例 function Person(name) &#123; // 两只眼睛两条腿 this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;function Man() &#123; this.sex = 'male'&#125;function Woman() &#123; this.sex = 'female'&#125;Man.prototype = new Person()var skyline = new Man()skyline.families.push('sister', 'grandma')var haha = new Man()console.log(haha.families) // [\"papa\", \"mama\", \"sister\", \"grandma\"]skyline.__proto__ == Man.prototype // trueMan.prototype.__proto__ == Person.prototype // truehaha.eyes = 2skyline.eyes // 'two' 优劣分析采用原型链继承无法避免原型中共享值所带来的问题。同时无法向超类型构造函数传递参数，实际很少使用（在创建 Man 的实例时，不能向Person传参） 上述示例中haha.eyes = 2 后skyline值不变并不是eyes没有通过原型共享，而是因为haha在其自身添加了实例属性eyes。 进一步尝试如下代码 haha.__proto__.eyes = 2skyline.eyes // 2 构造函数概述为解决原型链继承引用问题而引入，同时解决了无法向超类型传递参数的问题。又称为伪造对象或经典继承 基本思想是子类型构造函数内部调用超类型构造函数 为保证调用超类构造函数不会重写子类属性，需要先调用超类构造函数 代码示例function Person(name) &#123; // 两只眼睛两条腿 this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;function Man() &#123; Person.call(this) this.sex = 'male'&#125;var skyline = new Man()console.log(skyline.feet) // two 优劣分析此方式最大的问题是将产生可以公共使用的方法多次创建，无法复用共有方法。 组合继承概述又称为伪经典继承，就是组合使用原型链和构造函数模式 组合继承是最为常见的继承方式 代码示例function Person(name) &#123; // 两只眼睛两条腿 this.name = name this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;Person.prototype.say = function() &#123; console.log(`My name is $&#123;this.name&#125;`)&#125; // 共享的原型属性在这function Man(name) &#123; Person.call(this, name) // 私有的实例属性在这 this.sex = 'male'&#125;Man.prototype = new Person() var skyline = new Man('skyline')skyline.say() // My name is skylineskyline.families.push('sister', 'grandma')var haha = new Man('haha')console.log(skyline.families) // [\"papa\", \"mama\", \"sister\", \"grandma\"]console.log(haha.families) // [\"papa\", \"mama\"]console.log(skyline.feet) // two 优劣分析Man.prototype通过调用构造函数获取了Person内部的那些实例属性。这导致超类型Person实例属性同时存在于子（孙）类型原型（链）与实例属性中，造成浪费。注意，在重复的属性中，实例属性会覆盖原型属性。 .png) 原型式继承(Object.create)概述借助原型可以基于已有的对象创建新对象，不必因此创建自定义类型，大致思路如下代码所示 代码示例function create(o) &#123; var F = function() &#123;&#125; F.prototype = o return new F()&#125;a = &#123;&#125;b = create(a)b.__proto__ == a // true 该函数为了实现b.__proto__ == a的效果 优劣分析采用此方法与原型链方式相似，类型a中包含引用类型的属性始终会被共享。 ES6新增了Object.create方法规范了原型式继承。 寄生式继承概述创建一个仅用于封装继承过程的函数，函数内部以某种方式来增强对象 代码示例function createA(o) &#123; var clone = Object.create(o) // 调用任意一个可以返回对象的函数 clone.say = function() &#123; // 增强对象 console.log('hahaha') &#125; return clone // 返回对象&#125; 优劣分析与构造函数类似，方法不能复用 寄生组合式继承概述组合式继承会导致超类型构造函数的两次调用，超类型的实例属性将分别在原型中和实例中被复制而产生两组，实例属性屏蔽了原型中的属性 问题的原因是Man.prototype = new Person() 时让原型产生冗余属性，这一步的目的是使得 Man.prototype__proto__ == Person.prototype 。优化时仅需考虑而是间接的让上述等式成立即可。 最为理想的继承方式 💡 寄生组合式继承，就是通过借用构造函数来继承属性，通过原型链混成形式来继承方法 代码示例function copyPrototype(subType, superType) &#123; var p = Object.create(superType.prototype) // p.__proto__ == superType.prototype p.constructor = subType subType.prototype = p&#125;function Person(name) &#123; // 两只眼睛两条腿 this.name = name this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;Person.prototype.say = function() &#123; console.log(`My name is $&#123;this.name&#125;`)&#125; function Man(name) &#123; Person.call(this, name) this.sex = 'male'&#125;copyPrototype(Man, Person)// Man.prototype.__proto__ == Person.prototypevar skyline = new Man('skyline')skyline.say() // My name is skylineskyline.families.push('sister', 'grandma')var haha = new Man('haha')console.log(skyline.families) // [\"papa\", \"mama\", \"sister\", \"grandma\"]console.log(haha.families) // [\"papa\", \"mama\"]console.log(skyline.feet) // twoskyline.__proto__.__proto__ == Person.prototype //trueskyline.__proto__ == Man.prototype //trueMan.prototype.__proto__ == Person.prototype //trueMan.__proto__ == Person.prototype //falseMan.__proto__ == Function.prototype //true 优劣分析子类想要在原型上添加方法，由于subType.prototype = p 进行了赋值，必须在继承之后(copyPrototype后)添加，否则赋值将覆盖掉原有原型上的方法。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 《JavaScript 高级程序设计》 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES继承的实现.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"ES类型转换","slug":"ES类型转换","date":"2018-01-26T07:14:56.000Z","updated":"2023-02-14T08:05:52.000Z","comments":true,"path":"ES类型转换.html","link":"","permalink":"http://www.skyline.show/ES类型转换.html","excerpt":"类型转换 类型转换概述 to boolean to number to string to object ToPrimitive 隐式转换场景 隐式转换场景概述 一元操作符 二元加 乘、除、取余、二元减 比较运算符 Expression or Statement 几个有意思的输出 AST {}语法解析分析 JSON.stringify 处理规则 参数 BMW WARNING 类型转换类型转换概述 隐式转换JS 是弱类型语言，在使用运算符时，多个参与其中的数据类型可以是任意的，最终得到的结果却只是一种类型。结果的类型可能是参与运算操作类型中的一种，也可能并非其中任何一种。这就涉及到运算过程中，进行过的隐式类型转换。 强制转换JS 中每一种类型都有自己的构造函数，直接调用该构造函数可以强制获得该类型的值，同时 JS 还提供了其他显示调用函数转换类型的方法。 to boolean","text":"类型转换 类型转换概述 to boolean to number to string to object ToPrimitive 隐式转换场景 隐式转换场景概述 一元操作符 二元加 乘、除、取余、二元减 比较运算符 Expression or Statement 几个有意思的输出 AST {}语法解析分析 JSON.stringify 处理规则 参数 BMW WARNING 类型转换类型转换概述 隐式转换JS 是弱类型语言，在使用运算符时，多个参与其中的数据类型可以是任意的，最终得到的结果却只是一种类型。结果的类型可能是参与运算操作类型中的一种，也可能并非其中任何一种。这就涉及到运算过程中，进行过的隐式类型转换。 强制转换JS 中每一种类型都有自己的构造函数，直接调用该构造函数可以强制获得该类型的值，同时 JS 还提供了其他显示调用函数转换类型的方法。 to boolean 其他类型转换为布尔值。 隐式转换 隐式转换为布尔值 数据类型 转化成 true 转化成 false String 非空字符 “”(空字符） Number 非零 0 与 NaN Object 非 Null 对象 null undefined 无 undefined 强制转换 强制转换为布尔值调用 Boolean()与隐式转换规则转换一致，当不传参数时为 false console.log(Boolean()) // false to number其他类型转换成数字 隐式转换 隐式转换成数字 数据类型 转化成数字 示例 undefined NaN null 0 Number 等值 Boolean true: 1,false:0 String 忽略前导 0，转换成的 10 进制数，有一个字符不是数字（进制标识除外），则为 NaN，空串为 0 &quot;0x11&quot; - 1 // 16;;&quot;100a&quot; - 1 // NaN; - &#39;&#39; // -0 Object 调用 ToPrimitive var a = {valueOf: function() {return 1}}; a + 1 // 2 '0x11' - 1 // 16var a = &#123; valueOf: function () &#123; return 1 &#125;,&#125;a + 1 // 2 强制转换 Number()其他类型转换为数字时调用的是 Number()，故参考上述隐式转换。要返回数字，只接收纯数字字符串作为参数，允许前后有空格，中间不能有，否则返回 NaN var a = &#123; valueOf: function () &#123; return 1 &#125;,&#125;Number(a) // 1Number('0x11') // 17Number('100a') // NaN parseInt()只要非空格的第一个字符是数字，它就会尽可能长地进行转换，直到遇到空格会或非字母如果第一个非空格字符是其他，则返回 NaN可接受两个参数，第二个参数指定进制 parseFloat()只要非空格的第一个字符是数字或小数点，它就会尽可能长地进行转换，直到遇到空格会或非字母如果第一个非空格字符是其他，则返回 NaN接受一个参数，只解析十进制只解析一个小数点，第二个小数点号以后字符忽略 to string其他类型转换成字符 隐式转换 隐式转换成字符 数据类型 转化成字符 示例 undefined “undefined” null “null” Number 数值字符串形式 Boolean true: ‘true’,false:’false’ Object 调用 ToPrimitive 强制转换 toString() String()规则同隐式转换,，null 和 underfined 没有.toString 方法 to object隐式转换Boolean、Number、String 三种简单类型在设置和访问其属性时会隐式转换成基本包装类型，在使用完后会马上销毁 var s = 'skyline's.age = 23console.log(s.age) 上述代码的 JS 执行可以简单看成 强制转换 直接new关键字调用各类型构造函数，得到对应类型的基本包装类型，调用 Object 得到类似的基本包装对象 ToPrimitive ToPrimitive 综述 在 JS 中，使用 ToPrimitive 将对象转为原始值ToPrimitive 大致的处理逻辑如下图所示 toString() 数据类型 调用 toString() 普通对象 “[object Object]” 数组 arr arr.join(‘,’) 函数类 定义函数的代码 日期类 可读日期 正则对象 正则对象字面量的字符 基本包装类型的引用类型 用其字面量形式的值调用 toString() 如果数组的某一项的值是 null 或者 undefined，join()方法返回的结果以空字符串连接 valueOf()大多数对象，包括普通对象、数组、函数、正则简单返回对象本身日期对象返回 19700101 以来的毫秒数值基本包装类型的引用类型返回其字面量形式的值，该值存在于内部属性 PrimitiveValue 中 隐式转换场景隐式转换场景概述JS 隐式转换规则大致为简单类型调用目标类型的构造函数，复杂类型由内部方法 ToPrimitive 处理，见上述章节。触发隐式转换，通常是以下场景 一元操作符一元+运算符将其操作数转换为 Number 类型。一元减号同理但是反转正负 + '3' // 数字3- '-3' // 数字3+ [] //0+ [1] //1+ [1,2] //NaN 二元加规范地址：http://es5.github.io/#x11.6.1当计算 value1 + value2 时： lprim = ToPrimitive(value1) rprim = ToPrimitive(value2) 如果 lprim 是字符串或者 rprim 是字符串，那么返回 ToString(lprim) 和 ToString(rprim)的拼接结果 返回 ToNumber(lprim) 和 ToNumber(rprim)的运算结果 将加号两边值转换成原始值，原始值中有字符串则转换成字符串拼接，无则转换成数字相加；简单口诀记下：先转原始，有字符转字符，没有字符转数字 多个加号时，按照从左到右的顺序，两两进行计算 2 + '3' // \"23\"1 + 2 + '3' // \"33\"true + 2 + '3' // \"33\"1 + '2' + 3 // \"123\"1 + [] //\"1\"1 + [1] //\"11\"1 + &#123; a: 'a' &#125; //\"1[object Object]\"null + null //0true + &#123; a: 'a' &#125; //\"true[object Object]\"null + undefined //NaN1 + undefined //NaN 乘、除、取余、二元减隐式转换为数字 1 - '5' //-41 - [2, 2] //NaN1 - &#123; a: 1 &#125; //NaN1 - undefined //NaN1 - [] //11 - [2, 2] //NaN1 - null //1 比较运算符包括&gt; &lt; &gt;= &lt;= ==，这里主要以==来说明 规范关于使用”==”进行比较的时候，具体步骤可以查看规范 11.9.5：当执行 x == y 时： 1. 如果 x 与 y 是同一类型： 1. x 是 Undefined，返回 true 2. x 是 Null，返回 true 3. x 是数字： 1. x 是 NaN，返回 false 2. y 是 NaN，返回 false 3. x 与 y 相等，返回 true 4. x 是+0，y 是-0，返回 true 5. x 是-0，y 是+0，返回 true 6. 返回 false 4. x 是字符串，完全相等返回 true,否则返回 false 5. x 是布尔值，x 和 y 都是 true 或者 false，返回 true，否则返回 false 6. x 和 y 指向同一个对象，返回 true，否则返回 false2. x 是 null 并且 y 是 undefined，返回 true3. x 是 undefined 并且 y 是 null，返回 true4. x 是数字，y 是字符串，判断 x == ToNumber(y)5. x 是字符串，y 是数字，判断 ToNumber(x) == y6. x 是布尔值，判断 ToNumber(x) == y7. y 是布尔值，判断 x ==ToNumber(y)8. x 不是字符串或者数字，y 是对象，判断 x == ToPrimitive(y)9. x 是对象，y 不是字符串或者数字，判断 ToPrimitive(x) == y10. 返回 false 总结 数字 vs 其他（其他 vs 数字，忽略顺序，下同），其他转化为数字 布尔值 vs 其他，布尔值转数字，数字 vs 其他 字符串 vs 字符串，按 unicode 依次比较(大写字母总是在小写字母之后) 对象 vs 数字，对象 vs 字符串，将对象转化为转换成原始值，再进行比较。 操作数含 NaN，直接返回 false(NaN 和 NaN 是不相等的) null 与 undefined 是好基友（互相相等） 总结起来一句话，先转原始，有数字转数字，布尔值也转数字 NaN === NaN; // falseundefined == \"undefined\" // falsenull == \"null\" // falsenull == 0 // falsenull == false // falseundefined == 0 // falseundefined == false // falsetrue == '2' // falsefalse == [] // true[] == ![] // true// ![]会先执行为false 即比较 ([] == false) =&gt; ([] == 0) =&gt; ('' == 0) =&gt; (0 == 0) 其他情况除了上述情景，if 语句，三元运算符，逻辑与或都会触发隐式转换，这些情况一般简单分析即可 Expression or Statement几个有意思的输出chrome/firefox [] + &#123;&#125; //\"[object Object]\"&#123;&#125; + [] // 0[] + &#123;&#125; === &#123;&#125; + [] // true&#123;&#125; + [] === [] + &#123;&#125; // true&#123;a: 1&#125; // &#123;a: 1&#125;&#123;a: 1&#125;; // 1&#123;'a': 1&#125; // &#123;a: 1&#125;&#123;'a': 1&#125;; // SyntaxError&#123;&#125; + 0 + &#123;&#125;; // \"0[object Object]\"&#123;&#125; + 0 + &#123;&#125; // \"[object Object]0[object Object]\" firefox [] + &#123;&#125; //\"[object Object]\"&#123;&#125; + [] // 0[] + &#123;&#125; === &#123;&#125; + [] // true&#123;&#125; + [] === [] + &#123;&#125; // false&#123;a: 1&#125; // 1&#123;a: 1&#125;; // 1&#123;'a': 1&#125; // SyntaxError&#123;'a': 1&#125;; // SyntaxError&#123;&#125; + 0 + &#123;&#125;; // \"0[object Object]\"&#123;&#125; + 0 + &#123;&#125; // \"0[object Object]\" ASTwikipedia: Abstract_syntax_tree In computer science, an abstract syntax tree (AST), or just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the tree denotes a construct occurring in the source code. The syntax is “abstract” in not representing every detail appearing in the real syntax. For instance, grouping parentheses are implicit in the tree structure, and a syntactic construct like an if-condition-then expression may be denoted by means of a single node with three branches.其实就是将源代码分析成所对应的树状结构，便于之后的语法分析，代码检查等。现在的很多热门工具如 webpack、vue、UglifyJS、Lint 等都会用到这个技术，各个浏览器引擎也会使用自家定义的一套语法书生成树规范，生成相应的语法树。 {}语法解析分析其实由于浏览器厂商众多，每个与解析情况不一致，平常代码中基本不会遇到{}+这种问题，我们也没有精力研究各厂商预解析源码，从 Chrome 和 Firefox 来看，总结出来有下面几点： {…}的前面有运算符号的时候，{…}都会被解析成对象字面量。 {…}前面没有运算符时候但有;结尾的时候，{…}都会被解析成代码块。 {…}前面什么运算符都没有，{…}后面也没有分号(;)结尾 Firefox 会始终如一的解析为代码块 chrome 在这种情况下需要被扒一下历史大概在 chrome 版本 49 之前，Chrome 控制台上面的输出结果基本和 Firefox 一致，之后在 chrome 上有人提出 bug，Issue 499864，大概意思就是说我在控制台输入{a: 4, b: 5}你给我报个错干嘛，我就是想要一个对象而已。Chrome 确实该近几年大火，没过多久就修复了，修复的方式也特别 666，就是凡是语句以{开头，以}结尾，我解析的时候就包裹一层括号在外面。git 记录，里面的关键代码如下: + if (/^\\s*\\&#123;/.test(text) &amp;&amp; /\\&#125;\\s*$/.test(text))+ text = &apos;(&apos; + text + &apos;)&apos;; 也就是说{} + 0 + {}其实是({} + 0 + {}), {a: 1}其实是({a: 1}) 语法树图示以{} + 0 + {}为例来看 Chrome此时，Chrome 将第一个{}解析成对象 firefox此时，firefox 将第一个{}解析成代码块看 AST 的网站分析之后不难得出如上的结果 JSON.stringify处理规则 简单类型处理基本类型时，与使用 toString 基本相同，结果都是字符串，除了 undefined undefined只有 undefined 时返回 undefined，其他地方被忽略 String(undefined) // 'undefined'JSON.stringify(undefined) // undefinedJSON.stringify(&#123; a: undefined &#125;) // '&#123;&#125;' 简单类型包装对象布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值 部分复杂类型任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时） JSON.stringify(&#123; x: undefined, y: Object, z: Symbol('') &#125;)// \"&#123;&#125;\"JSON.stringify([undefined, Object, Symbol('')])// \"[null,null,null]\" 参数该函数接收三个参数，第二、三参数可选 第一参数（待处理对象） 如果第一个参数的某个对象拥有 toJSON 方法，那么结果为该函数返回值的序列化 const skyline = &#123; name: &#123; toJSON: () =&gt; 'skyline', &#125;, age: 18,&#125;JSON.stringify(skyline) // '&#123;\"name\":\"skyline\",\"age\":18&#125;' 第二参数（替换者） MDN The JSON.stringify() method converts a JavaScript object or value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified第二参数可以是数组或函数 数组数组列出要序列化输出的键值 JSON.stringify(foo, ['week', 'month'])// '&#123;\"week\":45,\"month\":7&#125;', only keep \"week\" and \"month\" properties 函数指定序列化的方式，根据返回值输出函数返回 Number, String, Boolean, null 直接输出返回值得序列化undefined Symbol 函数 则忽略输出其他对象则递归对对象调用该函数并输出其返回 function replacer(key, value) &#123; // Filtering out properties if (typeof value === 'string') &#123; return undefined &#125; if (value === undefined) &#123; return '---' &#125; return value&#125;var foo = &#123; foundation: 'Mozilla', model: 'box', week: 45, transport: 'car', month: 7, child: &#123; foundation: undefined, model: 'box', week: 45, transport: 'car', month: 7, &#125;,&#125;JSON.stringify(foo, replacer) // '&#123;\"week\":45,\"month\":7,\"child\":&#123;\"foundation\":\"---\",\"week\":45,\"month\":7&#125;&#125;' 第三参数（缩进字符与长度） 数字若参数为数字，则指定缩进长度，最多为 10 字符若参数为字母，则指定缩进字符，最多为 10 JSON.stringify(&#123; uno: 1, dos: 2 &#125;, null, 100)// '&#123;\\n \"uno\": 1,\\n \"dos\": 2\\n&#125;'JSON.stringify(&#123; uno: 1, dos: 2 &#125;, null, 10)// '&#123;\\n \"uno\": 1,\\n \"dos\": 2\\n&#125;'JSON.stringify(&#123; uno: 1, dos: 2 &#125;, null, 'abcdefghijklmn')// '&#123;\\nabcdefghij\"uno\": 1,\\nabcdefghij\"dos\": 2\\n&#125;' BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://github.com/mqyqingfeng/Blog/issues/164 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"CSS选择器","slug":"CSS选择器","date":"2018-01-25T12:13:37.000Z","updated":"2023-01-24T09:57:07.000Z","comments":true,"path":"CSS选择器.html","link":"","permalink":"http://www.skyline.show/CSS选择器.html","excerpt":"","text":"兄弟选择器 BMW WARNING 兄弟选择器CSS 常见的兄弟选择器包括 + ~其中+ 是相邻兄弟选择器，~ 是通用兄弟选择器。选择器前后的标签有有相同父标签。 相邻兄弟选择器 + 选择的是紧邻在前置标签后的第一个标签。通用兄弟选择器命中的标签必须是(不一定是紧邻)前置标签后面的兄弟标签。 选择器 描述 同父 后置标签要求首个 选中标签 ‘+’ 相邻 是 是 最多一个（非紧邻不选中） ‘~’ 通用 是 否 多个 /* 紧邻 h5 的第一个 p 兄弟标签中招，h5 之后第一个元素不是p，就无命中 */h5 + p &#123; color: red;&#125;/* 比 h5 小（在其后面）的 p 兄弟标签全部中招，h5 之后没有 p，就无命中 */h5 ~ p &#123; color: red;&#125; 示例 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"CSS常见问题汇总","slug":"CSS常见问题汇总","date":"2018-01-24T07:14:56.000Z","updated":"2023-01-24T09:57:07.000Z","comments":true,"path":"CSS常见问题汇总.html","link":"","permalink":"http://www.skyline.show/CSS常见问题汇总.html","excerpt":"CSS 继承与非继承属性 display:none 与 visibility:hidden 区别 媒体查询失效 img 标签是行内还是块级元素 BMW WARNING CSS 继承与非继承属性CSS 属性在不设定取值时，其实际取值分为两种。一种为继承属性，取父级元素该属性对应的值。一种为非继承属性，去该属性的默认值。由于 CSS 属性繁多，不容易死记来区分，一般可通过经验来判断一个属性是否可继承。 常见的不可继承属性如下： display 盒模型相关属性，如宽、高、内外边距、边框 背景相关属性：如背景颜色、图片、位置、大小、重复 定位相关属性：如 float、clear、position 内容相关属性：如 content、counter-reset、counter-increment 其他属性多为可继承属性，例如： 字体相关属性 部分文本相关属性 元素可见属性 visibility 光标属性 cursor display:none 与 visibility:hidden 区别两者虽简单来说都是用于隐藏元素，表现形式大有不同。 display 会被文档流给移除，影响页面布局，导致重排重绘，原本位置会被其他元素占据。 visilibity:hidden 不会被文档流给移除，不会影响布局，页面重绘出一片空白，但不会重新排版。 display 不是继承属性，而 visibility 是继承属性。若祖先设定为 visibility:hidden，后代元素会继承该属性不可见。此时，若重置后代元素的 visibility 为 visible，其后代元素将可见。若祖先设定的 display 属性设为 none 时，其不可继承，后代元素无力通过改变该属性重现。总结如下表格所示： 样式 页面重绘 页面重排 显示效果 对应 css 属性是否继承 display:none 是 是 无显示 否（display） visibility:hidden 是 否 所处区域空白 是（visibility） 媒体查询失效","text":"CSS 继承与非继承属性 display:none 与 visibility:hidden 区别 媒体查询失效 img 标签是行内还是块级元素 BMW WARNING CSS 继承与非继承属性CSS 属性在不设定取值时，其实际取值分为两种。一种为继承属性，取父级元素该属性对应的值。一种为非继承属性，去该属性的默认值。由于 CSS 属性繁多，不容易死记来区分，一般可通过经验来判断一个属性是否可继承。 常见的不可继承属性如下： display 盒模型相关属性，如宽、高、内外边距、边框 背景相关属性：如背景颜色、图片、位置、大小、重复 定位相关属性：如 float、clear、position 内容相关属性：如 content、counter-reset、counter-increment 其他属性多为可继承属性，例如： 字体相关属性 部分文本相关属性 元素可见属性 visibility 光标属性 cursor display:none 与 visibility:hidden 区别两者虽简单来说都是用于隐藏元素，表现形式大有不同。 display 会被文档流给移除，影响页面布局，导致重排重绘，原本位置会被其他元素占据。 visilibity:hidden 不会被文档流给移除，不会影响布局，页面重绘出一片空白，但不会重新排版。 display 不是继承属性，而 visibility 是继承属性。若祖先设定为 visibility:hidden，后代元素会继承该属性不可见。此时，若重置后代元素的 visibility 为 visible，其后代元素将可见。若祖先设定的 display 属性设为 none 时，其不可继承，后代元素无力通过改变该属性重现。总结如下表格所示： 样式 页面重绘 页面重排 显示效果 对应 css 属性是否继承 display:none 是 是 无显示 否（display） visibility:hidden 是 否 所处区域空白 是（visibility） 媒体查询失效 媒体查询的常见用法为 设置屏幕在 300px 到 900px 时的背景 @media screen and (min-width: 300px) and (max-width: 900px) &#123; body &#123; background: #eee; &#125;&#125; 当设置不生效时，检查在 &lt;head&gt; 中是否添加了如下 &lt;meta&gt; 标签 &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\" /&gt; img 标签是行内还是块级元素img 标签是行内元素。打开控制台查看：但是，作为行内元素，img 标签为什么可以设定其宽高属性？img 标签准确来说，是行内可替换元素。所谓的可替换元素，简单来说，就是除了位置和大小，其自己内部的内容不受当前页面获取的样式与内部的填入的标签或文本等内容所影响。img 标签可能不太好理解，另一个常见的行内可替换元素是 iframe 标签，其内部有自己一套样式来决定展现的内容。常见的行内可替换元素有： img video iframe embed 总体来看，行内可替换元素趋向于 display:inline-block 的表现 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"ES数组","slug":"ES数组","date":"2018-01-24T07:14:56.000Z","updated":"2023-02-10T10:20:04.000Z","comments":true,"path":"ES数组.html","link":"","permalink":"http://www.skyline.show/ES数组.html","excerpt":"常见坑点 实例方法 表格概述 方法进阶 部分实战 构造数组 slice 截取 数据结构模拟 BMW WARNING 常见坑点 数组的 length 不是只读的，可以通过修改来设置长度 一般通过 isArray 来判断是否是数组，而不用 instanceof 实例方法表格概述","text":"常见坑点 实例方法 表格概述 方法进阶 部分实战 构造数组 slice 截取 数据结构模拟 BMW WARNING 常见坑点 数组的 length 不是只读的，可以通过修改来设置长度 一般通过 isArray 来判断是否是数组，而不用 instanceof 实例方法表格概述 （-)表示可选参数 方法名 描述 参数 返回 是否修改原数组 push 逐个添加至数组屁股 任意（-） 数组新长度 是 pop 砍掉屁股一项 无 被砍掉的屁股 是 shift 砍掉第一项 无 被砍掉的第一 是 unshift 逐个添加至数组头部 任意（-） 数组新长度 是 reverse 反向重排 无 数组 是 sort 排序 fn（-） 数组 是 concat 联结 任意（-） 新数组 否 slice 截取 开始位置（-），结束位置（-） 新数组 否 splice 删除、插入、替换 开始位置（-），结束位置（-），插入项（-） 包含被删除的项的数组，没有则空数组 是 indexOf 查找位置 查找项（-），开始位置（-） 找到返回位置，否则-1 否 lastIndexOf 反向查找 查找项（-），开始位置（-） 找到返回位置，否则-1 否 every 与迭代 迭代函数，this 指向作用域（-） 布尔值 否 some 或迭代 迭代函数，this 指向作用域（-） 布尔值 否 filter 迭代筛选 迭代函数，this 指向作用域（-） 函数返回值为 true 的项组成的数组 否 map 迭代调整 迭代函数，this 指向作用域（-） 函数返回值组成的数组 否 forEach 迭代循环 迭代函数，this 指向作用域（-） 无 否 reduce 归并 归并函数，初始值（-） 归并终值 否 reduceRight 反向归并 归并函数，初始值（-） 归并终值 否 copyWithin 复制替换 替换开始位置，读取开始位置（-），读取结束位置（-） 数组 是 find 符合条件的第一个成员 条件函数 符合条件的成员否则 undefined 否 findIndex 符合条件的第一个成员位置 条件函数 符合条件的成员位置否则-1 否 fill 给定值填充数组 填充值，开始位置（-），结束位置（-） 数组 是 entries 返回键值的遍历对象 无 键值的遍历对象 否 keys 返回键的遍历对象 无 键值的遍历对象 否 values 返回值的遍历对象 无 键值的遍历对象 否 includes 包含值得判定 给定值 布尔值 否 增删排改（push、pop、shift、unshift、reverse、sort、splice、copyWithin、fill）会修改原数组 涉及遍历的方法（every、some、filter、map、forEach）第二个参数可以指定 this 方法进阶 方法名 描述 sort 无参数时为每一项调用 toString()方法，按返回的字符串首字母升序，有参数 fn 时 fn 接受两个参数，即数组的两项，根据 fn 返回值正负零来确定先后 concat 无参数时返回原数组副本，多个参数中如果有数组，数组每一项添加到新数组（相当于 ES6 中的…），其他类型直接添加 slice 无参数时返回原数组副本，两个参数表示截取开始结束位置，一个参数时表示开始位置截取到最末。参数为负数时，加上数组长度后截取，结束大于开始返回空数组 splice 前两项整数，第一项指定删除与插入的开始位置，第二项指定删除个数，之后项是依次插入的数据 indexOf 参数一到两个，第一项指定查找项，与数组中项对比时要求使用严格相等判定，第二个指定开始位置（可选） every 通过对数组每一项执行函数后全返回 true 则返回 true，否则 false some 通过对每一项执行函数后至少一项返回 true 则返回 true，否则 false filter 返回通过对每一项执行函数后返回 true 的项组成的新数组 map 返回通过对每一项执行函数取返回值组成的新数组 reduce 归并函数接受 4 个参数：前一个值，当前值，项索引，数组对象。归并函数当前返回值作为第一个参数传给下一项 部分实战构造数组构造一个一个长度为 n 的数组 Array(7).fill()//(7) [undefined, undefined, undefined, undefined, undefined, undefined, undefined]Array(7)//(7) [undefined × 7]Array.apply(null, &#123; length: 7 &#125;)//(7) [undefined, undefined, undefined, undefined, undefined, undefined, undefined] 需要注意的是，直接调用构造函数使用 map 填充数据存在问题 Array(7) .fill() .map(() =&gt; 1)// (7) [1, 1, 1, 1, 1, 1, 1]Array(7).map(() =&gt; 1)// (7) [undefined × 7]Array.apply(null, &#123; length: 7 &#125;).map(() =&gt; 1)// (7) [1, 1, 1, 1, 1, 1, 1] slice 截取'skyline'.slice(1, 5) // \"kyli\" ['s', 'k', 'y', 'l', 'i', 'n', 'e'].slice(1, 5) // [\"k\", \"y\", \"l\", \"i\"] 数据结构模拟 模拟栈，push + pop 模拟队列，shift + push 模拟反向队列，unshift + pop BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES 数组.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"Shell中查找相关命令","slug":"Shell中查找相关命令","date":"2018-01-22T07:14:56.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell中查找相关命令.html","link":"","permalink":"http://www.skyline.show/Shell中查找相关命令.html","excerpt":"which/whereis/whatis which whereis whatis find grep 汇总 BMW WARNING which/whereis/whatiswhich搜索某个命令在文件系统中的的位置并展示，若命令为别名，则会展示别名对应的命令。 shows the full path of (shell) commands. 默认使用时，搜索某个系统命令的位置，并且返回第一个搜索结果 which netstat# /usr/sbin/netstatwhich ls# ll: aliased to ls -G -a 选项，搜索某个系统命令的位置，并且返回所有搜索结果 which -a ls# ls: aliased to ls -G# /bin/ls whereis","text":"which/whereis/whatis which whereis whatis find grep 汇总 BMW WARNING which/whereis/whatiswhich搜索某个命令在文件系统中的的位置并展示，若命令为别名，则会展示别名对应的命令。 shows the full path of (shell) commands. 默认使用时，搜索某个系统命令的位置，并且返回第一个搜索结果 which netstat# /usr/sbin/netstatwhich ls# ll: aliased to ls -G -a 选项，搜索某个系统命令的位置，并且返回所有搜索结果 which -a ls# ls: aliased to ls -G# /bin/ls whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s） locate the binary, source, and manual page files for a command whereis ls# ls: /bin/ls /usr/share/man/man1/ls.1whereis -b ls# ls: /bin/lswhereis -m ls# ls: /usr/share/man/man1/ls.1 whatis展示命令手册中对应的的简要介绍 display manual page descriptions whatis shutdown# shutdown (8) - Halt, power-off or reboot the machinewhatis whereis# whereis (1) - locate the binary, source, and manual page files for a commandwhatis which# which (1) - shows the full path of (shell) commands.whatis whatis# whatis (1) - display manual page descriptions find文件搜索命令。 search for files in a directory hierarchy 在项目根目录下执行如下命令。 根据文件名称搜索 find ./ -name 'Nas*'# .//Demos/Tools/OS/Nas# .//Docs/Tools/OS/Nas# .//Docs/Tools/OS/Nas/Nas使用frp内网穿透.md# .//Docs/Tools/OS/Nas/Nas系统选择.md 忽略文件名大小写 find ./ -name 'nas*'#find ./ -iname 'nas*'# .//Demos/Tools/OS/Nas# .//Docs/Tools/OS/Nas# .//Docs/Tools/OS/Nas/Nas使用frp内网穿透.md# .//Docs/Tools/OS/Nas/Nas系统选择.md 根据文件权限搜索 # 查找具有SUID权限的文件find /usr/bin/ -perm /4000 | xargs ls -lh# 查找具有SGID权限的文件find /usr/bin/ -perm /2000 | xargs ls -lh# 查找具有Sticky bit权限的文件find /usr/bin/ -perm /1000 | xargs ls -lh# 查找777权限文件find /usr/bin/ -perm 777 | xargs ls -lh# 查找755权限文件find /usr/bin/ -perm 755 | xargs ls -lh# 查找4755权限文件(具有755与SUID权限)find /usr/bin/ -perm 4755 | xargs ls -lh 根据修改日期搜索 # 列出七天内修改的文件find ./ -name 'nas*' -mtime -7 根据文件类型搜索 find ./ -name 'Nas*' -type d# .//Demos/Tools/OS/Nas# .//Docs/Tools/OS/Nasfind ./ -name 'Git*' -type f# .//Docs/Tools/DEVs/Git/Git常见命令.md# .//Docs/Tools/DEVs/Git/Git常见操作.md# .//Docs/Tools/DEVs/Git/Git常见符号.md# .//Docs/Tools/DEVs/Git/Git常见问题.md 文件类型 - f: 普通文件- d: 文件夹- l: 链接- c: character devices- b: block devices- p: named pipe (FIFO)- s: socket 根据文件大小搜索 find ./ -name 'Git*' -type f | xargs ls -lh# -rw-r--r-- 1 macmini staff 1.7K Jun 9 17:41 .//Docs/Tools/DEVs/Git/Git常见命令.md# -rw-r--r-- 1 macmini staff 6.5K Jun 16 11:50 .//Docs/Tools/DEVs/Git/Git常见操作.md# -rw-r--r-- 1 macmini staff 1.2K Mar 2 16:38 .//Docs/Tools/DEVs/Git/Git常见符号.md# -rw-r--r-- 1 macmini staff 1.2K Jun 9 17:41 .//Docs/Tools/DEVs/Git/Git常见问题.mdfind ./ -name 'Git*' -type f -size +1k -size -2k# .//Docs/Tools/DEVs/Git/Git常见命令.md# .//Docs/Tools/DEVs/Git/Git常见符号.md# .//Docs/Tools/DEVs/Git/Git常见问题.md 多个条件搜索 find ./ -name 'Nas*' -type d -or -name 'Git*' -type f.//Demos/Tools/OS/Nas.//Docs/Tools/DEVs/Git/Git常见命令.md.//Docs/Tools/DEVs/Git/Git常见操作.md.//Docs/Tools/DEVs/Git/Git常见符号.md.//Docs/Tools/DEVs/Git/Git常见问题.md.//Docs/Tools/OS/Nas 对找到的多个文件执行命令操作{}指代文件 find ./ -name 'Git*' -type f -size +1k -size -2k -exec wc -l &#123;&#125; \\;# 54 .//Docs/Tools/DEVs/Git/Git常见命令.md# 41 .//Docs/Tools/DEVs/Git/Git常见符号.md# 56 .//Docs/Tools/DEVs/Git/Git常见问题.md 查找空文件和空目录 touch Git.txt;mkdir Git_test;find ./ -empty -name \"Git*\"# .//Git.txt# .//Git_test 删除搜索结果 find ./ -empty -name \"Git*\" -delete Find files matching a given pattern, excluding specific paths:find rootpath -name ‘.py’ -not -path ‘_/site-packages/*‘ grepgrep 是一个字符搜索命令，使用的基础语法为 grep [options] pattern [files] 具体参考Shell 中 grep 的使用 汇总 命令 描述 which 展示命令在系统路径中的位置。 whereis 用于程序名的搜索 locate 通过数据库显示文件或目录 find 查找硬盘中文件或目录 grep 查找某个文件中匹配项所在行并输出整行 type 用来区分某个命令出处，是由 shell 自带的，或外部的独立二进制文件提供的。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Shell 中查找相关命令.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"力扣题解64-最小路径和","slug":"力扣题解64-最小路径和","date":"2018-01-02T07:14:56.000Z","updated":"2023-02-14T08:49:12.000Z","comments":true,"path":"力扣题解64-最小路径和.html","link":"","permalink":"http://www.skyline.show/力扣题解64-最小路径和.html","excerpt":"题目描述 分析 状态转移方程 备忘录 边界处理 题解 写法一 写法二 BMW WARNING 题目描述 leetcode 64. 最小路径和 给定一个包含非负整数的 $m \\times n$ 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 分析状态转移方程","text":"题目描述 分析 状态转移方程 备忘录 边界处理 题解 写法一 写法二 BMW WARNING 题目描述 leetcode 64. 最小路径和 给定一个包含非负整数的 $m \\times n$ 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 分析状态转移方程 dp[i][j] = min(dp[i-1][j], dp[i][j - 1]) + grid[i][j] 备忘录设定upRets为一个一维数组，这里需要注意，作为备忘录功能，取j值是刚好是其上侧来的值，取其j-1的值为左侧来的值；对于这句话的理解，upRets缓存可上一轮最优路径的值，但是新一轮中，每一次循环，都将用upRets[j] = ret进行更新，使得其保留左侧的值 边界处理本题的关键是第一行和第一列的边界处理，容易出错 第一行第一列置初始置为0 若第一行，则不能由上侧来，只能由左侧 若第一列，则不能由左侧来，只能由上侧 题解写法一参照分析，如下 /** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123; let ret = 0 let upRets = [0] // 第一行第一列特殊边界处理 for (var i = 0; i &lt; grid.length; i++) &#123; for (var j = 0; j &lt; grid[i].length; j++) &#123; let top = isNaN(upRets[j]) ? Number.MAX_SAFE_INTEGER : upRets[j] // 是否为第一行，如果是，则不能由上侧来，只能由左侧 let left = isNaN(upRets[j - 1]) ? top : upRets[j - 1] // 是否为第一列，如果是，则不能由左侧来，只能由上侧 ret = Math.min(top, left) + grid[i][j] upRets[j] = ret &#125; &#125; return ret&#125;; 写法二代码稍作整合，如下 /** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123; let rets = [] let ret = 0 for (let i = 0; i &lt; grid.length; i++) &#123; for (let j = 0; j &lt; grid[i].length; j++) &#123; ret = (rets[j] &lt; rets[j - 1] ? rets[j] : isNaN(rets[j - 1]) ? (rets[j] || 0) : rets[j - 1]) + grid[i][j] // 边界处理包含其中，不如发一明显好理解 rets[j] = ret &#125; &#125; return ret&#125;; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/力扣题解64-最小路径和.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"},{"name":"Leetcode题解","slug":"Leetcode题解","permalink":"http://www.skyline.show/tags/Leetcode题解/"}]},{"title":"Shell中ls的使用","slug":"Shell中ls的使用","date":"2017-12-30T07:14:56.000Z","updated":"2023-02-04T07:45:55.000Z","comments":true,"path":"Shell中ls的使用.html","link":"","permalink":"http://www.skyline.show/Shell中ls的使用.html","excerpt":"基础使用 参数 常见用法 权限 BMW WARNING 基础使用参数ls 即 list，列出目录内容 参数 使用 描述 1 ls -1 换行列出文件 l ls -l 换行列出文件详细信息 a ls -a 列出所有文件，包括隐藏文件 d ls -d 列出当前目录本身，而不是其下内容 h ls -h 文件大小可读化输出，需要与 -l 配合使用 常见用法","text":"基础使用 参数 常见用法 权限 BMW WARNING 基础使用参数ls 即 list，列出目录内容 参数 使用 描述 1 ls -1 换行列出文件 l ls -l 换行列出文件详细信息 a ls -a 列出所有文件，包括隐藏文件 d ls -d 列出当前目录本身，而不是其下内容 h ls -h 文件大小可读化输出，需要与 -l 配合使用 常见用法 列出目录信息 ls -dlh /var/logdrwxr-xr-x 47 root wheel 1.5K Jan 6 09:22 /var/log# . 列出当前目录下的所有目录使用 ls -d */ 详细显示所有文件 ls -la 详细显示当前目录的具体信息 ls -ld# drwxr-xr-x+ 5 skyline staff 170 4 3 12:30 . 权限ls 【选项】【目录/文件】 ls -l# total 8# drwxr-xr-x 5 macmini staff 170B Mar 3 17:06 Demos# drwxr-xr-x+ 7 macmini staff 238B Jun 15 16:39 Docs# -rwxr-xr-x 1 macmini staff 143B Sep 18 2021 README.md 上述倒数第二列drwxr-xr-x+ 7 macmini staff 238B Jun 15 16:39 Docs的含义如下 文件格式 所有者权限 群组权限 其他人权限 ACL 权限 引用计数 所有者 所在组 大小 最后修改日期 文件名 d rwx r-x r-x + 5 macmini staff 238B Jun 15 16:39 Docs 权限由第一列列出，一般有 11 位，即如上drwxr-xr-x+ 第 1 位代表文件类型: - 普通文件 d 目录 l 软链接文件 s socket 文件 b 装置文件里面的可供储存的接口设备(可随机存取装置)； c 装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来中间 9 位，以 3 个为 1 组，且均为『rwx』 的 3 个参数的组合。 [ r ]代表可读(read) [ w ]代表可写(write) [ x ]代表可执行(execute) 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 对目录如果没有 w 权限，即使里面的文件有写权限，也不能对文件进行移动，重命名操作。此时，需要给目录加上 w 权限：chmod +w（注意命令在该目录下执行） BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"Vue项目实现rtmp流视频播放","slug":"Vue项目实现rtmp流视频播放","date":"2017-12-30T07:14:56.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Vue项目实现rtmp流视频播放.html","link":"","permalink":"http://www.skyline.show/Vue项目实现rtmp流视频播放.html","excerpt":"前言 代码实现 常见问题 BMW WARNING 前言rtmp 流需要使用 flash 播放。在 chrome 88 版本及以后的版本，已经移除了 flash 组件。在 2021 年 1 月 12 日，adobe 已宣布不再支持 flash。故本方案当前可能不再具备实用性。成功引入 rtmp 流，效果如下 代码实现实现需求需要运用的包为 videojs-flash、videojs main.js import videojs from 'video.js'import 'video.js/dist/video-js.css'Vue.prototype.$video = videojs player.vue &lt;template&gt; &lt;div class=\"demo1-video\"&gt; &lt;video ref=\"videoPlayer\" id=\"myVideo\" class=\"video-js\" controls preload=\"auto\" style=\"width: 100%\" height=\"220\" data-setup=\"&#123;&#125;\" &gt; &lt;p class=\"vjs-no-js\"&gt; To view this video please enable JavaScript, and consider upgrading to a web browser that &lt;a href=\"https://videojs.com/html5-video-support/\" target=\"_blank\" &gt;supports HTML5 video&lt;/a&gt; &lt;/p&gt; &lt;/video&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import \"videojs-flash\";export default &#123; name: \"VideoPlayer\", props: [\"type\", \"detail\"], inject: [\"gisMap\"], data() &#123; return &#123; player: null, videoOptions: &#123; autoplay: true, // 是否自动播放 muted: false, // 是否静音 controls: false, // fluid: true, // 宽高自适应 // techOrder: [\"flash\"], sources: [ &#123; src: \"//vjs.zencdn.net/v/oceans.mp4\", type: \"video/mp4\" // type: \"rtmp/flv\" &#125; ] &#125; &#125;; &#125;, computed: &#123; map() &#123; return this.gisMap.map.map || &#123;&#125;; &#125;, endType() &#123; if (this.type) &#123; let end = this.type.split(\"_\")[1]; return end; &#125; return \"\"; &#125; &#125;, mounted() &#123; // if (this.gisMap.map &amp;&amp; this.gisMap.map.map) &#123; this.map.on(\"popupclose\", this.clearVideo); this.map.on(\"popupopen\", this.playVideo); // &#125; this.playVideo(); &#125;, destroyed() &#123; this.map.off(\"popupclose\", this.clearVideo); this.map.off(\"popupopen\", this.playVideo); &#125;, methods: &#123; clearVideo() &#123; if (this.player) &#123; this.player.dispose(); this.player = null; &#125; &#125;, playVideo() &#123; this.player = this.$video( this.$refs.videoPlayer, &#123; autoplay: true, techOrder: [\"flash\", \"html5\"] &#125;, function onPlayerReady() &#123; this.src(&#123; src: \"rtmp://58.200.131.2:1935/livetv/hunantv\", type: \"rtmp/flv\" &#125;); this.play(); this.on(\"ended\", function() &#123;&#125;); &#125; ); &#125; &#125;&#125;; 常见问题","text":"前言 代码实现 常见问题 BMW WARNING 前言rtmp 流需要使用 flash 播放。在 chrome 88 版本及以后的版本，已经移除了 flash 组件。在 2021 年 1 月 12 日，adobe 已宣布不再支持 flash。故本方案当前可能不再具备实用性。成功引入 rtmp 流，效果如下 代码实现实现需求需要运用的包为 videojs-flash、videojs main.js import videojs from 'video.js'import 'video.js/dist/video-js.css'Vue.prototype.$video = videojs player.vue &lt;template&gt; &lt;div class=\"demo1-video\"&gt; &lt;video ref=\"videoPlayer\" id=\"myVideo\" class=\"video-js\" controls preload=\"auto\" style=\"width: 100%\" height=\"220\" data-setup=\"&#123;&#125;\" &gt; &lt;p class=\"vjs-no-js\"&gt; To view this video please enable JavaScript, and consider upgrading to a web browser that &lt;a href=\"https://videojs.com/html5-video-support/\" target=\"_blank\" &gt;supports HTML5 video&lt;/a&gt; &lt;/p&gt; &lt;/video&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import \"videojs-flash\";export default &#123; name: \"VideoPlayer\", props: [\"type\", \"detail\"], inject: [\"gisMap\"], data() &#123; return &#123; player: null, videoOptions: &#123; autoplay: true, // 是否自动播放 muted: false, // 是否静音 controls: false, // fluid: true, // 宽高自适应 // techOrder: [\"flash\"], sources: [ &#123; src: \"//vjs.zencdn.net/v/oceans.mp4\", type: \"video/mp4\" // type: \"rtmp/flv\" &#125; ] &#125; &#125;; &#125;, computed: &#123; map() &#123; return this.gisMap.map.map || &#123;&#125;; &#125;, endType() &#123; if (this.type) &#123; let end = this.type.split(\"_\")[1]; return end; &#125; return \"\"; &#125; &#125;, mounted() &#123; // if (this.gisMap.map &amp;&amp; this.gisMap.map.map) &#123; this.map.on(\"popupclose\", this.clearVideo); this.map.on(\"popupopen\", this.playVideo); // &#125; this.playVideo(); &#125;, destroyed() &#123; this.map.off(\"popupclose\", this.clearVideo); this.map.off(\"popupopen\", this.playVideo); &#125;, methods: &#123; clearVideo() &#123; if (this.player) &#123; this.player.dispose(); this.player = null; &#125; &#125;, playVideo() &#123; this.player = this.$video( this.$refs.videoPlayer, &#123; autoplay: true, techOrder: [\"flash\", \"html5\"] &#125;, function onPlayerReady() &#123; this.src(&#123; src: \"rtmp://58.200.131.2:1935/livetv/hunantv\", type: \"rtmp/flv\" &#125;); this.play(); this.on(\"ended\", function() &#123;&#125;); &#125; ); &#125; &#125;&#125;; 常见问题 No compatible source was found for this media. 解决方式：检查浏览器是否允许运行 flash若果 videojs 是版本 6 以上，flash 支持已独立成 videojs-flash，检查是否引入该库检查 option 中 techOrder 的配置是否是 [“flash”, “html5”]，其默认配置是[“html5”]，不配置将不会用 flash The &quot;flash&quot; tech is undefined. Skipped browser support check for that tech 网络解决方案一般是删除库包重新安装或者什么 cnpm 的问题，其实不然，有关讨论#221 方案 1： 配置包优先级 不管是删除 node_module 还是 cnpm 都不是根本的解决方案，根本原因是 videojs 和 videojs-flash 里的各有一个 video.js，如果两个版本不一样可能就会报错了，终极解决方案就是配置第三方模块的查找顺序，优先查找本身安装的 videojs 就可以了 // webpack.config.jsresolve: &#123;modules: [path.resolve('node_modules'), 'node_modules'], ...&#125;// vue.config.jsconfigureWebpack: function (config) &#123;return &#123; resolve: &#123; modules: [path.resolve('node_modules'), 'node_modules'] &#125;&#125;&#125; 按照如上配置仍旧不行的话，根据问题出现原因，尝试 方案 2 在 yarn.lock 或 package-lock.json 查看 videojs-flash 对应的 videojs 版本。也可在 node_modules 中查看。另也可删除 videojs-flash，重新安装，查看其对应的 videojs 版本。 yarn add video.js@7.8.0 重新安装 videojs 指定版本 TypeError: this.el_.vjs_getProperty is not a function 出现此问题多数是由于播放器在 DOM 中进行显示隐藏切换，需要在隐藏时将播放器完全销毁。调用 this.player.dispose() BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Vue 项目实现 rtmp 流视频播放.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/tags/Vue/"}]},{"title":"CSS换行","slug":"CSS换行","date":"2017-12-30T07:14:56.000Z","updated":"2023-01-24T09:57:07.000Z","comments":true,"path":"CSS换行.html","link":"","permalink":"http://www.skyline.show/CSS换行.html","excerpt":"段落换行 overflow-wrap word-break 换行总结 处理文字空白 white-space BMW WARNING 段落换行overflow-wrapoverflow-wrap: normal;overflow-wrap: break-word; word-wrap 原始微软私有，css3 统一规范重命名为 overflow-wrap。 overflow-wrap 常见取值为 normal 和 break-word。normal，默认值，单词保留完整，最后一个单词超出也不换行，直到该单词结束，只在 CJK(汉语系文字) 和空白符换行break-word，尽量保持英文完整，除非一个单词占一行才断开换行，否则从空白或 CJK 换行 word-break","text":"段落换行 overflow-wrap word-break 换行总结 处理文字空白 white-space BMW WARNING 段落换行overflow-wrapoverflow-wrap: normal;overflow-wrap: break-word; word-wrap 原始微软私有，css3 统一规范重命名为 overflow-wrap。 overflow-wrap 常见取值为 normal 和 break-word。normal，默认值，单词保留完整，最后一个单词超出也不换行，直到该单词结束，只在 CJK(汉语系文字) 和空白符换行break-word，尽量保持英文完整，除非一个单词占一行才断开换行，否则从空白或 CJK 换行 word-break word-break: normalword-break: break-allword-break: keep-all normal，默认值，单词保留完整，最后一个单词超出也不换行，直到该单词结束，CJK 换行break-all 超出即换行，不考虑单词完整（适用所有语言），内容把未填充部分的空白填满就换行。keep-all，只有遇到空白才换行（CJK 也不换行），超出不管。break-word，word-break 也可取 break-word 值，但被废弃，不再推荐使用 换行总结 normal 按照默认排版 break-word 保持英文完整 break-all 空白填满换行 keep-all 只在空白换行 注意对应的键值。 处理文字空白white-spacewhite-space 主要用于处理段落中的空白符。其用于处理换行问题时，解决的是换不换行的问题。段落换行章节的 overflow-wrap、word-break 两个属性处理的是什么时候换行（遇到合适的断点如空白基本所有取值都会换行）。常见使用是 white-space: nowrap 让文字直接不换行。 值 换行符 空格和制表符 文字换行 normal 合并 合并 换行 nowrap 合并 合并 不换行 pre 保留 保留 不换行 pre-wrap 保留 保留 换行 pre-line 保留 合并 换行 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/CSS 换行.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"ES中Generator函数","slug":"ES中Generator函数","date":"2017-11-29T12:58:25.000Z","updated":"2023-02-14T08:05:52.000Z","comments":true,"path":"ES中Generator函数.html","link":"","permalink":"http://www.skyline.show/ES中Generator函数.html","excerpt":"*函数语法 基本语法 使用示例 执行过程重点值 围绕 yield 产生的值 yield 语句整体值 next 函数返回对象 自动执行 实战分析 fibonacci 函数 计数器 自定义可迭代对象 BMW WARNING *函数语法基本语法*函数不同于普通函数执行它不会直接返回函数内部的结果（return），返回的是一个 Generator 指针对象。Generator 对象不能通过构造函数直接生产，需要配合*函数。同时 Generator 对象 遵循Iteration 迭代规范。这个规范规定了函数返回的迭代器对象(或其原型链)包含了 next、return 等函数。 Generator 对象通过调用自身的 next 方法，保证游标后移，并且 next 方法返回一个包含了 value 和 done（迭代器是否完成标识）的对象。 使用示例","text":"*函数语法 基本语法 使用示例 执行过程重点值 围绕 yield 产生的值 yield 语句整体值 next 函数返回对象 自动执行 实战分析 fibonacci 函数 计数器 自定义可迭代对象 BMW WARNING *函数语法基本语法*函数不同于普通函数执行它不会直接返回函数内部的结果（return），返回的是一个 Generator 指针对象。Generator 对象不能通过构造函数直接生产，需要配合*函数。同时 Generator 对象 遵循Iteration 迭代规范。这个规范规定了函数返回的迭代器对象(或其原型链)包含了 next、return 等函数。 Generator 对象通过调用自身的 next 方法，保证游标后移，并且 next 方法返回一个包含了 value 和 done（迭代器是否完成标识）的对象。 使用示例 function* generator() &#123; yield 1 yield 2 yield 3&#125;const gen = generator() // \"Generator &#123; &#125;\"console.log(gen.next().value) // 1console.log(gen.next().value) // 2console.log(gen.next().value) // 3 执行过程重点值围绕 yield 产生的值对于执行过程中涉及的值，围绕 yield，需要重点区分 yield 和其之后表达式整体的值， yield 之后表达式值。 const a = yield b + c; 即这段代码中 a 的值，以及 b+c 的值。 yield 语句整体值yield 语句整体值，上述代码示例中 a 的值。第 n 个 yield 语句整体值$a_n$，为第 n+1 次调用 next 时 传入的第一个参数的值，不传参即为 undefined。 function* gen(x) &#123; const y = yield x + 1 console.log(y)&#125;const g = gen(1)g.next()g.next(100)// 100 上述代码打印的值 y 为 100。这样设计的目的是让函数外部（主要是异步）获取的结果进行回传。 next 函数返回对象next 方法返回一个包含了 value 和 done（迭代器是否完成标识）的对象。这里的 value 值与 yield 后的表达式有关，即上述代码示例 b + c 的值。 第 n 次执行 next 函数获取到的对象其 value 值等于第 n 个 yield 后的表达式的值$(a+b)_n$若只有 n 个 yield 语句，第 n+1 次执行 next 函数获取到的对象 value 的值是 Generator 函数的返回值，超过 n+1 次执行得到 value 值是 undefined。 function* gen(x) &#123; const y = yield x + 1 return 100&#125;const g = gen(1)console.log(g.next())//&#123;value: 2, done: false&#125;console.log(g.next())//&#123;value: 100, done: true&#125;console.log(g.next())//&#123;value: undefined, done: true&#125; yield 即生产的意思，yield 后的值不难理解成造出成果（value）。 自动执行可以通过 while 来简单实现 generator 的自动执行。 function* generator() &#123; yield 1 yield 2 yield 3&#125;const gen = generator()while (!gen.next().done) &#123;&#125;console.log(gen)// generator &#123;&lt;closed&gt;&#125; 使用递归实现自动执行。 function autoExec(gen) &#123; if (!gen.next().done) &#123; autoExec(gen) &#125;&#125; 但是在实际开发过程中，往往有结合异步事件传值，获取最终结果等需求。具体推荐这篇文章ES6 系列之 Generator 的自动执行 但是在实际开发过程中，往往有结合异步事件传值，获取最终结果等需求。 实战分析fibonacci 函数function* fibonacci() &#123; let current = 0 let next = 1 while (true) &#123; const reset = yield (current[(current, next)] = [next, next + current]) if (reset) &#123; current = 0 next = 1 &#125; &#125;&#125;const sequence = fibonacci()console.log(sequence.next().value) // 0console.log(sequence.next().value) // 1console.log(sequence.next().value) // 1console.log(sequence.next().value) // 2console.log(sequence.next().value) // 3console.log(sequence.next().value) // 5console.log(sequence.next(true).value) // 0console.log(sequence.next().value) // 1console.log(sequence.next().value) // 1console.log(sequence.next().value) // 2 计数器function* infinite() &#123; let index = 0 while (true) &#123; yield index++ &#125;&#125;const generator = infinite() // \"Generator &#123; &#125;\"console.log(generator.next().value) // 0console.log(generator.next().value) // 1console.log(generator.next().value) // 2 自定义可迭代对象内置的可迭代类有：String，Array，TypedArray，Map 以及 Set 这些类的原型链上都包含 如下为自定义对象实现可迭代 const myIterable = &#123; *[Symbol.iterator]() &#123; yield 1 yield 2 yield 3 &#125;,&#125;for (const value of myIterable) &#123; console.log(value)&#125;// 1// 2// 3;[...myIterable] // [1, 2, 3] 该对象可使用 for…of 遍历，可使用展开运算法展开。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES 中 Generator 函数.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"鹧鸪天（新寒）","slug":"鹧鸪天（新寒）","date":"2017-09-23T06:15:40.000Z","updated":"2023-01-24T09:57:10.000Z","comments":true,"path":"鹧鸪天（新寒）.html","link":"","permalink":"http://www.skyline.show/鹧鸪天（新寒）.html","excerpt":"","text":"&nbsp;&nbsp; 乍起新寒风又嚎，厦间不见杜家茅。落棋柯烂朝兴替，弹指风挥花盛飘。 梦缥缈，路遥迢，随流逐浪几多豪？待心足了即名了，斜雨泥丫印土桥。&nbsp;&nbsp; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Subject","slug":"Subject","permalink":"http://www.skyline.show/categories/Subject/"}],"tags":[{"name":"Literature","slug":"Literature","permalink":"http://www.skyline.show/tags/Literature/"},{"name":"诗词","slug":"诗词","permalink":"http://www.skyline.show/tags/诗词/"},{"name":"随笔","slug":"随笔","permalink":"http://www.skyline.show/tags/随笔/"},{"name":"鹧鸪天","slug":"鹧鸪天","permalink":"http://www.skyline.show/tags/鹧鸪天/"}]},{"title":"鹧鸪天（九月西湖雨入情）","slug":"鹧鸪天（九月西湖雨入情）","date":"2017-09-23T06:15:40.000Z","updated":"2023-01-24T09:57:10.000Z","comments":true,"path":"鹧鸪天（九月西湖雨入情）.html","link":"","permalink":"http://www.skyline.show/鹧鸪天（九月西湖雨入情）.html","excerpt":"","text":"&nbsp;&nbsp; 九月西湖雨入情，一人饮酒廿杯明。形成秋叶怜枝瘦，影化微风惜夜清。 形伴影，叶随风，谢家庭院在西东？危楼伫望空千里，今夜无人入梦中。 &nbsp;&nbsp; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/鹧鸪天·九月西湖雨入情（新韵）.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Subject","slug":"Subject","permalink":"http://www.skyline.show/categories/Subject/"}],"tags":[{"name":"Literature","slug":"Literature","permalink":"http://www.skyline.show/tags/Literature/"},{"name":"诗词","slug":"诗词","permalink":"http://www.skyline.show/tags/诗词/"},{"name":"随笔","slug":"随笔","permalink":"http://www.skyline.show/tags/随笔/"},{"name":"鹧鸪天","slug":"鹧鸪天","permalink":"http://www.skyline.show/tags/鹧鸪天/"}]},{"title":"Python中的字符串","slug":"Python中的字符串","date":"2017-07-30T08:02:42.000Z","updated":"2023-02-15T07:26:30.000Z","comments":true,"path":"Python中的字符串.html","link":"","permalink":"http://www.skyline.show/Python中的字符串.html","excerpt":"内置函数 字符串实例函数 BMW WARNING 内置函数 Name Explanation Usage Out ES Counterpart max python取列表中最长的字符串 max([‘ale’, ‘apple’, ‘plea’], key=len, default=’’) apple ord 获取字符的utf8编码 ord(‘A’) 65 ‘A’.charCodeAt() chr 把编码转换为对应的字符 chr(65) ‘A’ String.fromCharCode(65) 字符串实例函数 Name Explanation Usage Out ES Counterpart count 获取字符串中某个字符的数量 ‘skyline liu’.count(‘l’) 2 isupper 是否大写 ‘A’.isupper() True islower 是否小写 ‘a’.islower() True split 字符串分割 ‘a b c’.split(‘ ‘) [‘a’, ‘b’, ‘c’] upper 转换成大写 lower 转换成小写 BMW WARNING","text":"内置函数 字符串实例函数 BMW WARNING 内置函数 Name Explanation Usage Out ES Counterpart max python取列表中最长的字符串 max([‘ale’, ‘apple’, ‘plea’], key=len, default=’’) apple ord 获取字符的utf8编码 ord(‘A’) 65 ‘A’.charCodeAt() chr 把编码转换为对应的字符 chr(65) ‘A’ String.fromCharCode(65) 字符串实例函数 Name Explanation Usage Out ES Counterpart count 获取字符串中某个字符的数量 ‘skyline liu’.count(‘l’) 2 isupper 是否大写 ‘A’.isupper() True islower 是否小写 ‘a’.islower() True split 字符串分割 ‘a b c’.split(‘ ‘) [‘a’, ‘b’, ‘c’] upper 转换成大写 lower 转换成小写 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Python中的字符串.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"},{"name":"Python","slug":"Python","permalink":"http://www.skyline.show/tags/Python/"}]},{"title":"ES克隆实现","slug":"ES克隆实现","date":"2017-07-30T07:56:13.000Z","updated":"2023-02-14T09:56:15.000Z","comments":true,"path":"ES克隆实现.html","link":"","permalink":"http://www.skyline.show/ES克隆实现.html","excerpt":"浅克隆 常见浅克隆 浅克隆的问题 深克隆 深克隆的方案 JSON.stringify cloneDeep的简单实现 三方库深克隆源码分析 Jquery.extend BMW WARNING 浅克隆常见浅克隆在日常代码中，常用的对象克隆方式较多，多数直接使用的API是浅克隆。 Object.assign const circle = (radius) =&gt; &#123; const proto = &#123; type: \"Circle\", //code &#125;; return Object.assign(Object.create(proto), &#123; radius &#125;);&#125;;const square = (length) =&gt; &#123; const proto = &#123; type: \"Square\", //code &#125;; return Object.assign(Object.create(proto), &#123; length &#125;);&#125;; … const square = &#123; type: \"Square\", borders: [2, 2, 2, 2], perimeter: function() &#123; return this.borders.reduce((p, n) =&gt; &#123; return p + n &#125;, 0); &#125;,&#125;;const rectangel = &#123;...square&#125;rectangel.type = 'Rectangel'rectangel.borders[1] = 4rectangel.borders[3] = 4 浅克隆的问题","text":"浅克隆 常见浅克隆 浅克隆的问题 深克隆 深克隆的方案 JSON.stringify cloneDeep的简单实现 三方库深克隆源码分析 Jquery.extend BMW WARNING 浅克隆常见浅克隆在日常代码中，常用的对象克隆方式较多，多数直接使用的API是浅克隆。 Object.assign const circle = (radius) =&gt; &#123; const proto = &#123; type: \"Circle\", //code &#125;; return Object.assign(Object.create(proto), &#123; radius &#125;);&#125;;const square = (length) =&gt; &#123; const proto = &#123; type: \"Square\", //code &#125;; return Object.assign(Object.create(proto), &#123; length &#125;);&#125;; … const square = &#123; type: \"Square\", borders: [2, 2, 2, 2], perimeter: function() &#123; return this.borders.reduce((p, n) =&gt; &#123; return p + n &#125;, 0); &#125;,&#125;;const rectangel = &#123;...square&#125;rectangel.type = 'Rectangel'rectangel.borders[1] = 4rectangel.borders[3] = 4 浅克隆的问题 由于复杂类型存储方式的不同，如果只是进行简单的赋值，就会造成新对象修改将影响初始对象的相关值。以扩展运算符为例，后续代码的调整导致了正方形的边长被改变。square.borders// [2, 4, 2, 4] 深克隆深克隆的方案现在已有第三方库的成熟实现，例如，可用lodash underscore 等插件提供的类似于cloneDeep的方法。另常见的用法为使用JSON序列化API,当然，也可尝试自写深克隆函数。 JSON.stringifylet newObj = JSON.parse(JSON.stringify(obj)) JSON.stringify存在主要如下问题： 无法复制函数（JSON.stringify()无法序列化函数） 原型链，所属的类等信息丢失 对象循环引用的问题无法解决 var a = function()&#123;&#125;var b = JSON.stringify(a)a //function ()&#123;&#125;b //undefinedvar c = []c //[]var d = JSON.stringify(c)d //\"[]\" cloneDeep的简单实现var cloneDeep= function(source) &#123; let target = &#123;&#125;; // isArray = false; if(typeof source === 'object')&#123; // source[key] instanceof Array &amp;&amp; (isArray = true) target = source[key] instanceof Array ? [] : &#123;&#125; &#125;else&#123; return source; &#125; for (var key in source) &#123; target[key] = typeof source[key] === 'object' ? cloneDeep(source[key]) : source[key]; &#125; return target; &#125; 三方库深克隆源码分析Jquery.extendJquery extend 源码地址Jquery.extend代码使用示例 var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = $.extend(&#123;&#125;, x), //shallow copy z = $.extend(true, &#123;&#125;, x); //deep copyy.b.f === x.b.f // truez.b.f === x.b.f // false 源码分析jQuery.extend = jQuery.fn.extend = function() &#123; var src, //缓存目标对象属性 copyIsArray, //标记被复制对象属性是否是数组 copy, //缓存被复制对象属性 name, options, clone, target = arguments[0] || &#123;&#125;, //目标对象，如果没有传入参数，则默认为空对象 i = 1, //标记参数的位置 length = arguments.length, deep = false; //深浅克隆标志 // 处理深克隆 if (typeof target === \"boolean\") &#123; deep = target; // 如果第一个参数为布尔值，则目标对象顺移值第二个参数 target = arguments[i] || &#123;&#125;; i++; &#125; //处理目标参数是非对象情况（注意第二个判断条件是由于typeof用于function返回的是'Function') // Handle case when target is a string or something (possible in deep copy) if (typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 如果传入参数只有一个（任意）则直接赋值Jquery对象 if (i === length) &#123; target = this; i--; &#125; for (; i &lt; length; i++) &#123; //undefined == null true // 处理非null与undefined值 if ((options = arguments[i]) != null) &#123; for (name in options) &#123; src = target[name]; copy = options[name]; // 如果目标属性与被复制对象属性相等 if (target === copy) &#123; continue; &#125; // 如果是纯粹对象或数组，则递归调用。（通过 \"&#123;&#125;\" 或者 \"new Object\" 创建的是纯粹对象） if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; return target;&#125;; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 深入剖析 JavaScript 的深复制 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES克隆实现.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"Python实现批量文件重命名","slug":"Python实现批量文件重命名","date":"2017-07-30T07:14:56.000Z","updated":"2023-02-15T07:41:12.000Z","comments":true,"path":"Python实现批量文件重命名.html","link":"","permalink":"http://www.skyline.show/Python实现批量文件重命名.html","excerpt":"使用说明 脚本代码 BMW WARNING 使用说明将下面的脚本写入命名为rename.py的文件并，放到要批量修改文件名的文件夹下使用如下命令 python3 rename.py [测试名字]# 或直接输入# python3 rename.py 脚本代码# rename.py# 导入os库import osimport sys# 文件存放的路径path = r\"./\"# 将命令中第二个参数作为输入，多个参数空格隔开if len(sys.argv) &gt;= 2: base = sys.argv[1]else: # 控制台输入 base = input('Please input base name: ') print(\"You inputted \", base)# 遍历更改文件名num = 1for old in os.listdir(path): if old == 'rename.py': print('Skip script!') else: new = base + '_' + str(num) + os.path.splitext(old)[-1] os.rename(os.path.join(path, old), os.path.join(path, new)) print('Rename', old, 'to', new) num = num + 1print('Succeed!!!')# 获取文件名后缀 os.path.splitext(name)[-1] BMW WARNING","text":"使用说明 脚本代码 BMW WARNING 使用说明将下面的脚本写入命名为rename.py的文件并，放到要批量修改文件名的文件夹下使用如下命令 python3 rename.py [测试名字]# 或直接输入# python3 rename.py 脚本代码# rename.py# 导入os库import osimport sys# 文件存放的路径path = r\"./\"# 将命令中第二个参数作为输入，多个参数空格隔开if len(sys.argv) &gt;= 2: base = sys.argv[1]else: # 控制台输入 base = input('Please input base name: ') print(\"You inputted \", base)# 遍历更改文件名num = 1for old in os.listdir(path): if old == 'rename.py': print('Skip script!') else: new = base + '_' + str(num) + os.path.splitext(old)[-1] os.rename(os.path.join(path, old), os.path.join(path, new)) print('Rename', old, 'to', new) num = num + 1print('Succeed!!!')# 获取文件名后缀 os.path.splitext(name)[-1] BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Python实现批量文件重命名.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Python","slug":"Python","permalink":"http://www.skyline.show/tags/Python/"}]},{"title":"H5+微信移动支付配置","slug":"H5+微信移动支付配置","date":"2017-07-30T07:14:56.000Z","updated":"2023-01-24T09:57:09.000Z","comments":true,"path":"H5+微信移动支付配置.html","link":"","permalink":"http://www.skyline.show/H5+微信移动支付配置.html","excerpt":"关键代码 相关问题 BMW WARNING 关键代码本文采用 dcloud 开源的 JSBridge 库 H5+，详情查阅官方文档H5+ API支付插件配置地址支付插件 （框架 vue) data () &#123; return &#123; payType: '2', payTypes: [ &#123; // icon: 'http://dn-placeholder.qbox.me/110x110/FF2D55/000', key: '1', value: '支付宝' &#125;, &#123; // icon: 'http://dn-placeholder.qbox.me/110x110/FF2D55/000', key: '2', value: '微信支付' &#125;], channels: [] &#125; &#125;, methods: &#123; /** * 获取服务 */ getSerivces() &#123; let me = this; plus.payment.getChannels(function(channels)&#123; me.channels=channels; &#125;,function(e)&#123; alert(\"获取支付通道失败：\"+e.message); &#125;); &#125;, /* 支付 */ pay()&#123; let me = this; SelectPayType(&#123;orderNum: this.activeOrderNum, payType: this.payType&#125;).then(res =&gt; &#123; if (res.code == 101) &#123; let channel, data = JSON.parse(res.data); var payType = me.payType == '1' ? 'alipay' : 'wxpay'; me.channels.forEach(function(val) &#123; val.id == payType &amp;&amp; (channel = val) &#125;) plus.payment.request(channel, data, function(result)&#123; me.isShowPayTypes = false; plus.nativeUI.alert(\"支付成功！订单状态将在稍后更新，请不要重复付款\",function()&#123; back(); &#125;); me.jump(&#123;name:'订单详情',query:&#123;orderNum: me.activeOrderNum&#125;&#125;) &#125;,function(error)&#123; plus.nativeUI.alert(\"支付失败：\" + error.code); &#125;); &#125; else &#123; me.$vux.toast.show(&#123; text: res.message, type: 'warn' &#125;) &#125; &#125;) &#125; &#125;, mounted()&#123; if(window.plus)&#123; this.getSerivces() &#125;else&#123; // getSerivces() // document.addEventListener('plusready', this.getSerivces,false) &#125; &#125; //selectPayType是请求支付需要相关字段，需要查看相关平台接口文档，本文为微信，返回的字段如下&#123; \"package\": \"Sign=WXPay\", \"appid\": \"wx7xxxxxx4987f28\", \"sign\": \"51B0ADxxxxx4E480486C70BD64BF44E1D\", \"partnerid\": \"148xxx722\", \"prepayid\": \"wx2017xxxxxx2fc85d2cc3c0205143628\", \"noncestr\": \"k2xxxxx3X2D1O4YCz7Hn4s\", \"timestamp\": \"1503312709\"&#125; 相关问题提示 支付失败：-100 支付失败：[payment 微信：-1] 的问题 微信支付不能真机调试，只能打包安装测试，因为要 app 的真实签名。真机调试用的是 dcloud 的调试基座 app 的 wx0411fa6a39d61297。如果嫌打包麻烦，可以把后端返回的数据 appid 换成 wx0411fa6a39d61297安卓平台下，首先查看微信开放平台配置的参数与提交打包的参数是否一致，主要包括(应用签名、包名)。其中应用签名如果使用的 DCloud 公用证书则必须是“59201CF6589202CB2CDAB26752472112”。开发信息 配置信息 BMW WARNING","text":"关键代码 相关问题 BMW WARNING 关键代码本文采用 dcloud 开源的 JSBridge 库 H5+，详情查阅官方文档H5+ API支付插件配置地址支付插件 （框架 vue) data () &#123; return &#123; payType: '2', payTypes: [ &#123; // icon: 'http://dn-placeholder.qbox.me/110x110/FF2D55/000', key: '1', value: '支付宝' &#125;, &#123; // icon: 'http://dn-placeholder.qbox.me/110x110/FF2D55/000', key: '2', value: '微信支付' &#125;], channels: [] &#125; &#125;, methods: &#123; /** * 获取服务 */ getSerivces() &#123; let me = this; plus.payment.getChannels(function(channels)&#123; me.channels=channels; &#125;,function(e)&#123; alert(\"获取支付通道失败：\"+e.message); &#125;); &#125;, /* 支付 */ pay()&#123; let me = this; SelectPayType(&#123;orderNum: this.activeOrderNum, payType: this.payType&#125;).then(res =&gt; &#123; if (res.code == 101) &#123; let channel, data = JSON.parse(res.data); var payType = me.payType == '1' ? 'alipay' : 'wxpay'; me.channels.forEach(function(val) &#123; val.id == payType &amp;&amp; (channel = val) &#125;) plus.payment.request(channel, data, function(result)&#123; me.isShowPayTypes = false; plus.nativeUI.alert(\"支付成功！订单状态将在稍后更新，请不要重复付款\",function()&#123; back(); &#125;); me.jump(&#123;name:'订单详情',query:&#123;orderNum: me.activeOrderNum&#125;&#125;) &#125;,function(error)&#123; plus.nativeUI.alert(\"支付失败：\" + error.code); &#125;); &#125; else &#123; me.$vux.toast.show(&#123; text: res.message, type: 'warn' &#125;) &#125; &#125;) &#125; &#125;, mounted()&#123; if(window.plus)&#123; this.getSerivces() &#125;else&#123; // getSerivces() // document.addEventListener('plusready', this.getSerivces,false) &#125; &#125; //selectPayType是请求支付需要相关字段，需要查看相关平台接口文档，本文为微信，返回的字段如下&#123; \"package\": \"Sign=WXPay\", \"appid\": \"wx7xxxxxx4987f28\", \"sign\": \"51B0ADxxxxx4E480486C70BD64BF44E1D\", \"partnerid\": \"148xxx722\", \"prepayid\": \"wx2017xxxxxx2fc85d2cc3c0205143628\", \"noncestr\": \"k2xxxxx3X2D1O4YCz7Hn4s\", \"timestamp\": \"1503312709\"&#125; 相关问题提示 支付失败：-100 支付失败：[payment 微信：-1] 的问题 微信支付不能真机调试，只能打包安装测试，因为要 app 的真实签名。真机调试用的是 dcloud 的调试基座 app 的 wx0411fa6a39d61297。如果嫌打包麻烦，可以把后端返回的数据 appid 换成 wx0411fa6a39d61297安卓平台下，首先查看微信开放平台配置的参数与提交打包的参数是否一致，主要包括(应用签名、包名)。其中应用签名如果使用的 DCloud 公用证书则必须是“59201CF6589202CB2CDAB26752472112”。开发信息 配置信息 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/H5+微信移动支付配置.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Mobile","slug":"Mobile","permalink":"http://www.skyline.show/tags/Mobile/"},{"name":"H5+","slug":"H5","permalink":"http://www.skyline.show/tags/H5/"}]},{"title":"H5+开发常见问题","slug":"H5+开发常见问题","date":"2017-07-30T07:14:56.000Z","updated":"2023-01-24T09:57:09.000Z","comments":true,"path":"H5+开发常见问题.html","link":"","permalink":"http://www.skyline.show/H5+开发常见问题.html","excerpt":"H5+ plus 对象找不到 hbuilder 打包 app 点击手机返回键直接退出到桌面 Hbuilder 打 ipa 包安装失败 BMW WARNING H5+本文采用 dcloud 开源的 JSBridge 库 H5+，详情查阅官方文档H5+ API plus 对象找不到h5+ 通过暴露对象 plus 来提供相关 API。开发时，只有移动端才会注入 plus 对象，需要依赖手机模拟器或者真机进行调试，直接网页端调试不会有该对象出现。若 plus 对象找不到，一般来说是由于业务代码执行时，plus 对象尚未初始化完成。通过plusready来保证初始化完成后执行业务代码以 vue 为例，在项目入口文件中添加如下代码 Vue.prototype.$plusExtends = (fn) =&gt; &#123; if (window.plus) &#123; setTimeout(fn, 0) &#125; else &#123; document.addEventListener('plusready', fn, false) &#125;&#125; 业务组件使用 this.$plusExtends(() =&gt; &#123; var cmr = window.plus.xxx&#125;) hbuilder 打包 app 点击手机返回键直接退出到桌面","text":"H5+ plus 对象找不到 hbuilder 打包 app 点击手机返回键直接退出到桌面 Hbuilder 打 ipa 包安装失败 BMW WARNING H5+本文采用 dcloud 开源的 JSBridge 库 H5+，详情查阅官方文档H5+ API plus 对象找不到h5+ 通过暴露对象 plus 来提供相关 API。开发时，只有移动端才会注入 plus 对象，需要依赖手机模拟器或者真机进行调试，直接网页端调试不会有该对象出现。若 plus 对象找不到，一般来说是由于业务代码执行时，plus 对象尚未初始化完成。通过plusready来保证初始化完成后执行业务代码以 vue 为例，在项目入口文件中添加如下代码 Vue.prototype.$plusExtends = (fn) =&gt; &#123; if (window.plus) &#123; setTimeout(fn, 0) &#125; else &#123; document.addEventListener('plusready', fn, false) &#125;&#125; 业务组件使用 this.$plusExtends(() =&gt; &#123; var cmr = window.plus.xxx&#125;) hbuilder 打包 app 点击手机返回键直接退出到桌面 在发布目录下的 index.html 下直接插入如下代码，或直接将这段代码插入入口 main.js document.addEventListener('plusready', function () &#123; var webview = plus.webview.currentWebview() plus.key.addEventListener('backbutton', function () &#123; webview.canBack(function (e) &#123; if (e.canBack) &#123; webview.back() &#125; else &#123; //webview.close(); //hide,quit //plus.runtime.quit(); //首页返回键处理 //处理逻辑：1秒内，连续两次按返回键，则退出应用； var first = null plus.key.addEventListener( 'backbutton', function () &#123; //首次按键，提示‘再按一次退出应用’ if (!first) &#123; first = new Date().getTime() console.log('再按一次退出应用') setTimeout(function () &#123; first = null &#125;, 1000) &#125; else &#123; if (new Date().getTime() - first &lt; 1500) &#123; plus.runtime.quit() &#125; &#125; &#125;, false ) &#125; &#125;) &#125;)&#125;) Hbuilder 打 ipa 包安装失败在用 hbuilder 进行 ipa 打包之前，需要按照官方文档步骤生成证书文件 iOS 证书(.p12)和描述文件(.mobileprovision)申请打包之后 ipa 文件通过 iTunes 安装，开始正常，安装到最后，图标消失，安装失败。 请确保设备在苹果开发者中心被添加，如下图所示 若出现iOS开发者证书信息有误（请重新填写相关信息，iOS profile文件与私钥证书文件不匹配）。如果重新添加了账号，需要重新生成证书相关文件，而不是使用原有的证书文件，则按照官方文档重新生成证书。 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/H5+开发常见问题.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Mobile","slug":"Mobile","permalink":"http://www.skyline.show/tags/Mobile/"},{"name":"H5+","slug":"H5","permalink":"http://www.skyline.show/tags/H5/"}]},{"title":"ES数组去重","slug":"ES数组去重","date":"2017-07-30T07:14:56.000Z","updated":"2023-02-04T08:24:24.000Z","comments":true,"path":"ES数组去重.html","link":"","permalink":"http://www.skyline.show/ES数组去重.html","excerpt":"举个栗子 正常人 我有想法 我会 es6 BMW WARNING 举个栗子var he = &#123; name: 'he', sex: 'male' &#125;, she = &#123; name: 'she', sex: 'female' &#125;, age = [18, 28], family = [ 1, 1, '1', 'skyline', 'skyline', he, he, she, &#123; name: 'she', sex: 'female' &#125;, age, [18, 28], ]family.length //11 正常人使用循环 function removeRepetition1(arr) &#123; let ret = [] for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (ret.indexOf(arr[i]) === -1) &#123; ret.push(arr[i]) &#125; &#125; return ret&#125;function removeRepetition2(arr) &#123; let ret = [] arr.forEach(function (e, i, arr) &#123; if (arr.indexOf(e) === i) &#123; ret.push(e) &#125; &#125;) return ret&#125;removeRepetition1(family)removeRepetition2(family) indexOf 比较参数与数组每一项时候，使用的是严格等于。 我有想法","text":"举个栗子 正常人 我有想法 我会 es6 BMW WARNING 举个栗子var he = &#123; name: 'he', sex: 'male' &#125;, she = &#123; name: 'she', sex: 'female' &#125;, age = [18, 28], family = [ 1, 1, '1', 'skyline', 'skyline', he, he, she, &#123; name: 'she', sex: 'female' &#125;, age, [18, 28], ]family.length //11 正常人使用循环 function removeRepetition1(arr) &#123; let ret = [] for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (ret.indexOf(arr[i]) === -1) &#123; ret.push(arr[i]) &#125; &#125; return ret&#125;function removeRepetition2(arr) &#123; let ret = [] arr.forEach(function (e, i, arr) &#123; if (arr.indexOf(e) === i) &#123; ret.push(e) &#125; &#125;) return ret&#125;removeRepetition1(family)removeRepetition2(family) indexOf 比较参数与数组每一项时候，使用的是严格等于。 我有想法 //使用对象function removeRepetition3(arr) &#123; let tmp = &#123;&#125;, ret = [] for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (!tmp[arr[i]]) &#123; tmp[arr[i]] = 1 ret.push(arr[i]) &#125; &#125; return ret&#125;//先排序function removeRepetition4(arr) &#123; let ret = [], end arr.sort() end = arr[0] ret.push(arr[0]) for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== end) &#123; ret.push(arr[i]) end = arr[i] &#125; &#125; return ret&#125; removeRepetition3 仅适用于简单类型，对象产生的属性相同，是{[object Object]: 1},所以只会保留第一个出现的对象.数组产生的是[xx,xx,xx].toString()作为属性，[1,2]产生的是{1,2: 1}，同时数字型字符串会被干掉，仅适用于纯数字去重.该方法不推荐，只需将 tmp 对象换成 es6 的 map 结构即可。参看 removeRepetition6。 removeRepetition4 采用的是 sort 方法，该方法在不带参数的情况下，默认使用的是 unicode 字符表顺序，该排序容易导致其他问题，不推荐 我会 es6function removeRepetition5(arr) &#123; return [...new Set(arr)] // return Array.from(new Set(array));&#125;function removeRepetition6(arr) &#123; let tmp = new Map(), ret = [] for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (!tmp.has(arr[i])) &#123; tmp.set(arr[i], 1) ret.push(arr[i]) &#125; &#125; return ret&#125;removeRepetition5(family)//(10) [1, \"1\", \"skyline\", &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, Array(2), Array(2), Array(0)]removeRepetition6(family)//(10) [1, \"1\", \"skyline\", &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, Array(2), Array(2), Array(0)] ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。ES6 提供了新的数据结构 Map。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。可进一步参考Set 和 Map 数据结构 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"}]},{"title":"CSS常见效果实现","slug":"CSS常见效果实现","date":"2017-06-30T07:14:56.000Z","updated":"2023-01-24T09:57:06.000Z","comments":true,"path":"CSS常见效果实现.html","link":"","permalink":"http://www.skyline.show/CSS常见效果实现.html","excerpt":"CSS 行溢出省略号 单行溢出省略号 多行溢出省略号 实现矩形对角线 BMW WARNING CSS 行溢出省略号单行溢出省略号div &#123; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 需要设置定长以及超出隐藏。如果要设置隐藏后鼠标悬浮显示的效果，可以为 div 设定 title 属性，也可以用 hover 来达到效果 多行溢出省略号","text":"CSS 行溢出省略号 单行溢出省略号 多行溢出省略号 实现矩形对角线 BMW WARNING CSS 行溢出省略号单行溢出省略号div &#123; width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 需要设置定长以及超出隐藏。如果要设置隐藏后鼠标悬浮显示的效果，可以为 div 设定 title 属性，也可以用 hover 来达到效果 多行溢出省略号 div &#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; // (两行文字) -webkit-box-orient: vertical;&#125; 实现矩形对角线div &#123; background: linear-gradient( to top right, transparent 49.5%, rgb(235, 238, 245) 49.5%, rgb(235, 238, 245) 50.5%, transparent 50.5% );&#125; BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"http://www.skyline.show/tags/HTML-CSS/"},{"name":"CSS","slug":"CSS","permalink":"http://www.skyline.show/tags/CSS/"}]},{"title":"Vue-Router相关使用","slug":"Vue-Router相关使用","date":"2017-05-30T07:14:56.000Z","updated":"2023-02-04T07:45:54.000Z","comments":true,"path":"Vue-Router相关使用.html","link":"","permalink":"http://www.skyline.show/Vue-Router相关使用.html","excerpt":"Vue 路由权限拦截问题描述路由跳转时，部分页面需要进行权限验证，其中最常见的就是登陆验证，如果没有权限，则会跳转到登陆页面。本文进行在 vue-router 的基础上进行权限探讨。 权限验证代码","text":"Vue 路由权限拦截问题描述路由跳转时，部分页面需要进行权限验证，其中最常见的就是登陆验证，如果没有权限，则会跳转到登陆页面。本文进行在 vue-router 的基础上进行权限探讨。 权限验证代码 如下示例将函数加入全局混合的方法中，通常情况下只需在组件中使用。除了登陆验证，也可创建新函数进行其他校验，如角色验证等 // 为自定义的选项 'myOption' 注入一个处理器。Vue.mixin(&#123; methods: &#123; /* 获取多页面的view与route */ $viewUrl() &#123; const href = window.location.href const url = encodeURIComponent(href) //编码转换 return url &#125;, /* 多页面跳转 */ $href(to, query) &#123; const location = window.location const env = process.env.NODE_ENV let url = '' if (env === 'development') &#123; url = location.protocol + '//' + location.host + '/views/' + to &#125; else &#123; url = location.protocol + '//' + location.host + '/dist/views/' + to &#125; url = query ? url + '?' + query : url location.href = url &#125;, /** * 权限验证 * @param &#123;Array&#125; rules eg: [&#123;name: 'isAdmin', redirect: 'index/home'&#125;, &#123;name: 'isLogin', redirect: 'index/login'&#125;] || ['isAdmin', 'islogin'] * @param &#123;Object&#125; status eg: &#123;isActive: false, isLogin: true&#125; * @return &#123;[type]&#125; [description] */ $verifyRules(rules = [], status = &#123;&#125;) &#123; typeof rules[0] == 'string' ? rules.forEach((val) =&gt; &#123; !status[val] &amp;&amp; this.$href('index/index.html#/home') &#125;) : rules.forEach((val) =&gt; &#123; !status[val.name] &amp;&amp; this.$href(val.redirect || 'index/index.html#/home') &#125;) &#125;, /* 登录验证跳转 */ $loginVerify() &#123; const viewUrl = 'lastPath=' + this.$viewUrl this.$href('index/index.html#/login', viewUrl) // 将跳转的路由path作为参数，登录成功后跳转到该路由 &#125;, /* 用户身份验证跳转 */ $roleVerify() &#123; const viewUrl = 'lastPath=' + this.$viewUrl this.$href('index/index.html#/join', viewUrl) // 将跳转的路由path作为参数，登录成功后跳转到该路由 &#125;, &#125;,&#125;) 路由设置const routes = [ //顶层路由 &#123; path: '/userInfo', component: UserInfo, meta: &#123; accessRules: ['isLogin'] //登录验证 &#125;, children: [ &#123; name:'adminSys', path: '/adminSys', component: AdminSys, meta:&#123; accessRules: [&#123;name: 'isAdmin', redirect: 'index/toBeAdmin'&#125;, &#123;name: 'isLogin', redirect: 'index/login'&#125;]//跳转到路由是否需要权限 &#125; ] &#125;&#125;] 路由钩子/** * store.getters.userInfo.accessStatus = &#123;isAdmin: false, isActive: false, isLogin: true&#125; */router.beforeEach((to, from, next) =&gt; &#123; if (store.getters.userInfo.accessStatus.isAdmin) &#123; const status = store.getters.userInfo.accessStatus, accessRules = Object.assign( &#123;&#125;, ...to.matched.map((m) =&gt; m.meta) ).accessRules //父路由accessRules应用于全部路由，当子路由设定有accessRules时，子规则覆盖父路由规则 accessRules &amp;&amp; vue.$verifyRules(accessRules, status) next() &#125; else &#123; vue.$roleVerify() &#125;&#125;) 路由格式子路由前’/‘&#123; path: '/index', component: Index, children: [&#123; path: '/home', name: 'home', component: Home &#125; ]&#125; 访问 Home 页面http://10.10.7.181:8060/#/home 子路由&#123; path: '/index', component: Index, children: [&#123; path: 'home', name: 'home', component: Home &#125; ]&#125; 访问 Home 页面http://10.10.7.181:8060/#/index/home子路由中不建议在 path 前加’/‘绝对路径，容易造成误解（本意可能想要第二种结果）。 路由隐藏 index如果需要在路由中隐藏’index’，改成如下写法 &#123; path: '/', component: Index, children: [&#123; path: 'home', name: 'home', component: Home &#125; ]&#125; 访问 Home 页面http://10.10.7.181:8060/#/home BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️。 I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/Vue-Router 相关使用.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"实战","slug":"实战","permalink":"http://www.skyline.show/tags/实战/"},{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/tags/Vue/"}]},{"title":"计算机常见术语","slug":"计算机常见术语","date":"2017-05-29T06:26:24.000Z","updated":"2023-03-02T10:12:54.000Z","comments":true,"path":"计算机常见术语.html","link":"","permalink":"http://www.skyline.show/计算机常见术语.html","excerpt":"Web领域 前端工程化 大前端 微前端 软件工程领域 鸭子类型 函数重载 函数签名 网络安全领域 沙盒（沙箱） BMW WARNING Web领域前端工程化在前后端未分离时代，前端能做的工作很少，开发基本的展示页面，另外涉及少量的页面交互逻辑，相比后端，只能算整个大的项目工程中的一小部分。随着现代应用的复杂化，前端需要承担的职责和开发工作越来越多，前后端开始分离。 前端工程化是将软件工程中的原理与思路用在前端开发上使前端被单独视作一个工程，从而让前端软件易于迭代，便于维护，高效开发，质量可靠。 前端工程化的前提是前后端分离。在现代前端中，需要做到： 基本展示页面开发页面完整交互逻辑与页面特效基础项目构建（gulp、webpack、rollup）JS预编译(TS、JSX、TSX)CSS预编译（SCSS、Less）代码体积压缩(uglyJS)前端请求代理，接口数据模拟(Mock)代码模块化开发(RequireJS、ES6)代码打包部署(webpack、vue-cli)前端项目版本迭代前端性能监控... 前端需要承担日益增加的职责，也就一步步向工程化演进。这些开发过程职责合起来就是一个较大的工程。这些前端职责随着发展不断演变引入的，后续也会有不同的新职责随着演变不断更新。 大前端","text":"Web领域 前端工程化 大前端 微前端 软件工程领域 鸭子类型 函数重载 函数签名 网络安全领域 沙盒（沙箱） BMW WARNING Web领域前端工程化在前后端未分离时代，前端能做的工作很少，开发基本的展示页面，另外涉及少量的页面交互逻辑，相比后端，只能算整个大的项目工程中的一小部分。随着现代应用的复杂化，前端需要承担的职责和开发工作越来越多，前后端开始分离。 前端工程化是将软件工程中的原理与思路用在前端开发上使前端被单独视作一个工程，从而让前端软件易于迭代，便于维护，高效开发，质量可靠。 前端工程化的前提是前后端分离。在现代前端中，需要做到： 基本展示页面开发页面完整交互逻辑与页面特效基础项目构建（gulp、webpack、rollup）JS预编译(TS、JSX、TSX)CSS预编译（SCSS、Less）代码体积压缩(uglyJS)前端请求代理，接口数据模拟(Mock)代码模块化开发(RequireJS、ES6)代码打包部署(webpack、vue-cli)前端项目版本迭代前端性能监控... 前端需要承担日益增加的职责，也就一步步向工程化演进。这些开发过程职责合起来就是一个较大的工程。这些前端职责随着发展不断演变引入的，后续也会有不同的新职责随着演变不断更新。 大前端 随着前端不断地完善与发展，前端工程师能承担的开发工程向多端发展。越来越多的前端工程师通过Node.js、React Native、Weex、Electron、Flutter、小程序等开发非Web端应用。浏览器作为前端的本职工作地，最初由Node.js打破，向着不拘泥于Web端应用的大前端方向发展。 微前端为了应对愈来愈庞大的巨石应用以及跨团队协助和使用不同技术栈的问题，前端工程引入了后端微服务思想理念，微前端诞生。微前端延续微服务的思路，将庞大的前端项目根据相对独立的功能模块拆解成多个提供不同服务的微项目，这些项目可分别交于擅长不同领域的团队采用不同技术栈开发，开发过程，维护迭代过程互不影响。 微前端各子项目一般有如下特性： 技术无关独立运行独立维护 早期的微前端使用iframe来实现，当存在重新渲染白屏等可感知的影响用户体验问题。现在微前端框架不断发展，已有single-spa、qiankun、micro-app等可选择。 微前端框架需要解决如下问题： 路由系统同步应用集成方式（App Entry）应用隔离 软件工程领域鸭子类型当看到一只鸟包含当前关注的所有鸭子的特征，即走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子类型。以TypeScript类型系统为例：TypeScript 选择了一种基于属性的类型系统（Structural type system）。这种类型系统不再关注一个变量被标称的类型（由哪一个构造器构造），而是 在进行类型检查时，将对象拆开，逐个去比较组成这个对象的每一个属性或方法。如果一个对象有着一个类型所要求的所有属性或方法，那么类型检查通过，实际编程时就可以当作这个类型来使用。 函数重载编程语言支持多个同名函数的定义，只是参数的个数或者类型不同。在调用的时候，解释器会根据参数的个数或者类型，调用对应的函数。 函数重载主要解决实际开发过程中参数类型可变或参数个数可变的问题 函数重载遵循基本的设计原则：仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载。如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。 函数重载这个特性在很多语言中都有实现，如C++、Java 等。但 Python JS 并不支持 def hello(nums2): print(nums2)def hello(nums1, nums2): print(nums1, nums2)hello(1) // TypeErrorhello(1,2) 上述代码后面的hello会覆盖前一个 执行会抛出异常Exception has occurred: TypeError hello() missing 1 required positional argument: &#39;nums2&#39; 不支持函数重载的语言，原因类似，以Python为例。Python不支持原因如下： 类型可变，功能相同 Python 函数可以接受任何类型的参数，功能相同则不需要解决这个问题 个数可变，功能相同 Python提供缺省参数，函数功能相同，内部始终需要对缺少的参数处理 函数签名函数（方法）签名主要由具体的输入输出来定义，可以是以下： 输入参数与类型 输出值与类型 可能抛出或传回的异常 函数的访问性（面向对象编程中的public, static, prototype） 在可以重载函数的语言中，需要参数类型与个数有差异，通常说要求函数签名不同。 网络安全领域沙盒（沙箱）沙盒（英语：sandbox，又译为沙箱）是一种安全机制，为执行中的程式提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。主要用途有测试带病毒程序，测试恶意代码等。​ BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://zh.wikipedia.org/zh-hans/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8)​ Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/计算机常见术语.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"CS","slug":"CS","permalink":"http://www.skyline.show/tags/CS/"},{"name":"Software","slug":"Software","permalink":"http://www.skyline.show/tags/Software/"}]},{"title":"ES基本包装类型","slug":"ES基本包装类型","date":"2017-05-22T12:58:25.000Z","updated":"2023-02-15T08:48:57.000Z","comments":true,"path":"ES基本包装类型.html","link":"","permalink":"http://www.skyline.show/ES基本包装类型.html","excerpt":"常见的基本包装类型 基本包装类型的对象生存期 构造函数与转型函数 BMW WARNING 常见的基本包装类型常见的基本包装类型，包括Boolean、Number、String三种。其创建方式包括转型函数和字面量，不包含构造函数。引用类型与基本包装类型的主要区别就是对象的生存期。 基本包装类型的对象生存期var s = 'skyline's.age = 23console.log(s.age) 以上代码可以想象成如下代码周期，通过使用构造函数来模拟包装： 当最后访问s.age时相当于又包装了一个新的对象，故其age不存在。 构造函数与转型函数","text":"常见的基本包装类型 基本包装类型的对象生存期 构造函数与转型函数 BMW WARNING 常见的基本包装类型常见的基本包装类型，包括Boolean、Number、String三种。其创建方式包括转型函数和字面量，不包含构造函数。引用类型与基本包装类型的主要区别就是对象的生存期。 基本包装类型的对象生存期var s = 'skyline's.age = 23console.log(s.age) 以上代码可以想象成如下代码周期，通过使用构造函数来模拟包装： 当最后访问s.age时相当于又包装了一个新的对象，故其age不存在。 构造函数与转型函数 var str = String('skyline')//转型函数，产生基本包装类型，相当于字面量创建，设置属性无效console.log(typeof str)//stringvar obj = new String('skyline')//构造函数，产生引用类型，可设置属性console.log(typeof obj)//object BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问。文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github仓库点亮⭐️ I am a bucolic migant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant 本文作者： Skyline(lty) 文章链接：http://www.skyline.show/ES基本包装类型.html 授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]},{"title":"ES函数","slug":"ES函数","date":"2017-05-11T12:56:32.000Z","updated":"2023-03-02T06:13:49.000Z","comments":true,"path":"ES函数.html","link":"","permalink":"http://www.skyline.show/ES函数.html","excerpt":"函数的长度 函数参数 参数传递 按值传递 引用传递 ES6 默认参数 默认参数的影响 作用域前后变化 懒执行 TDZ(Temporal Dead Zone) 函数创建 作用域链 箭头函数 BMW WARNING 函数的长度函数的长度等于形参的个数。 function skyline(a, b, c)&#123; console.log(`输入$&#123;arguments.length&#125;个参数`)&#125;console.log(`函数的长度为：$&#123;skyline.length&#125;`)skyline(1)// 函数的长度为：3// 输入1个参数 函数参数函数的参数被放在一个arguments的类数组中。 它的值永远与对应命名参数的值保持同步。设函数第 n 个参数为 a， 当在函数内部修改了 a，那么 arguments[n-1]保持同步也为更改后的值 arguments 的长度是由运行时传入参数个数决定的，而不是定义时 function test(a, b, c) &#123; arguments[0] = &#123; name: 'skyline' &#125; arguments[1] = 2 c = 5 console.log( `a=$&#123;a&#125;, b=$&#123;b&#125;, 第三个参数的值是：$&#123;arguments[2]&#125;, 参数的长度：$&#123; arguments.length &#125;, 第一个参数与a是否相等：$&#123;arguments[0] === a&#125;` )&#125;test(1, &#123; firstName: 'liu' &#125;, '3', 3)// a=[object Object], b=2, 第三个参数的值是：5, 参数的长度：4, 第一个参数与a是否相等：true 对于 ES6 中通过扩展运算符获取参数，示例如下 function createArray6(...args) &#123; console.log(args) console.log(args instanceof Array) return args&#125;createArray6(11, 2, 3)// (3) [11, 2, 3]// true 不同于 ES5 的 arguments 是一种类数组，ES6 拓展运算符获取 args 是一个数组。 arguments 与实参的绑定的绑定情况如下：非严格，传入值共享，没传不共享 function skyline(a, b, c)&#123; console.log(`输入的a:$&#123;a&#125;`) console.log(`输入的第一个参数：$&#123;arguments[0]&#125;`) b = 2 console.log(`b值为$&#123;b&#125;`) console.log(`第而个参数：$&#123;arguments[1]&#125;`)&#125;console.log(`函数的长度为：$&#123;skyline.length&#125;`)skyline(1)// 函数的长度为：3// 2 输入的a:1// 3 输入的第一个参数：1// 5 b值为2// 6 第而个参数：undefined 在严格模式下，实参和 arguments 是不会共享的，也就是都会为上述b的情况。 参数传递","text":"函数的长度 函数参数 参数传递 按值传递 引用传递 ES6 默认参数 默认参数的影响 作用域前后变化 懒执行 TDZ(Temporal Dead Zone) 函数创建 作用域链 箭头函数 BMW WARNING 函数的长度函数的长度等于形参的个数。 function skyline(a, b, c)&#123; console.log(`输入$&#123;arguments.length&#125;个参数`)&#125;console.log(`函数的长度为：$&#123;skyline.length&#125;`)skyline(1)// 函数的长度为：3// 输入1个参数 函数参数函数的参数被放在一个arguments的类数组中。 它的值永远与对应命名参数的值保持同步。设函数第 n 个参数为 a， 当在函数内部修改了 a，那么 arguments[n-1]保持同步也为更改后的值 arguments 的长度是由运行时传入参数个数决定的，而不是定义时 function test(a, b, c) &#123; arguments[0] = &#123; name: 'skyline' &#125; arguments[1] = 2 c = 5 console.log( `a=$&#123;a&#125;, b=$&#123;b&#125;, 第三个参数的值是：$&#123;arguments[2]&#125;, 参数的长度：$&#123; arguments.length &#125;, 第一个参数与a是否相等：$&#123;arguments[0] === a&#125;` )&#125;test(1, &#123; firstName: 'liu' &#125;, '3', 3)// a=[object Object], b=2, 第三个参数的值是：5, 参数的长度：4, 第一个参数与a是否相等：true 对于 ES6 中通过扩展运算符获取参数，示例如下 function createArray6(...args) &#123; console.log(args) console.log(args instanceof Array) return args&#125;createArray6(11, 2, 3)// (3) [11, 2, 3]// true 不同于 ES5 的 arguments 是一种类数组，ES6 拓展运算符获取 args 是一个数组。 arguments 与实参的绑定的绑定情况如下：非严格，传入值共享，没传不共享 function skyline(a, b, c)&#123; console.log(`输入的a:$&#123;a&#125;`) console.log(`输入的第一个参数：$&#123;arguments[0]&#125;`) b = 2 console.log(`b值为$&#123;b&#125;`) console.log(`第而个参数：$&#123;arguments[1]&#125;`)&#125;console.log(`函数的长度为：$&#123;skyline.length&#125;`)skyline(1)// 函数的长度为：3// 2 输入的a:1// 3 输入的第一个参数：1// 5 b值为2// 6 第而个参数：undefined 在严格模式下，实参和 arguments 是不会共享的，也就是都会为上述b的情况。 参数传递 按值传递函数的参数都是按值传递的，当传递引用类型的值时，会把这个值在内存中的地址复制给局部变量。其实质就是把实参在内存中的数据传递给形参，基本类型拷贝了本身，引用类型拷贝的是引用的地址。 示例一 var str1 = 'aaa'var num2 = 2var obj1 = &#123; value: 1,&#125;function skyline(obj2) &#123; obj2.value = 2 console.log(obj2.value) //2&#125;skyline(obj1)console.log(obj1.value) // 2 上述进入函数时，通过值传递，形参 obj2 拷贝了实参 obj1 的内存数据，即拷贝一个引用地址。 在函数执行obj2.value = 2;前后的内存状态（图解与说明仅为了解释参数传递，计算机内存远比此复杂） 示例二 var str1 = 'aaa'var num2 = 2var obj1 = &#123; value: 1,&#125;function skyline(obj2) &#123; obj2 = 2 console.log(obj2) //2&#125;skyline(obj1)console.log(obj1.value) // 2 在函数执行obj2 = 2;前后的内存状态 引用传递ES 函数的参数时按值传递的，部分语言支持参数按引用传递。以上述示例二为例，若函数 skyline 参数按引用传递，则传入是形参 obj2 直接记录实参 obj1 的内存地址。故而后续不管两者谁变化，都将影响另一方。即上述代码执行到最后，obj1 的值将会被变更为数字 2。在 C#中，区分值传递和引用传递是方法参数前加 ref，加 ref 就是引用传递, 不加就是值传递。 ES6 默认参数默认参数的影响ES6 可为函数设定默认值。设定默认值后，函数的 length 和作用域将会发生变化。函数的 length 只计算没有设定默认值得参数个数（默认值应该是尾参数）。对于作用域的变化，函数设定默认参数后，函数参数将会形成一个全新的作用域，这个作用域居于函数内部和外部作用域之间。 作用域前后变化 不带默认参数 var x = 1function fun(x, z) &#123; debugger var x = 2 var y = 3 console.log(x, y)&#125;fun(4, 5) 打开Chrome控制台， 带默认参数 var x = 1function fun(x = 6, z = 7) &#123; debugger var x = 2 var y = 3 console.log(x, y)&#125;fun(4, 5) 由此可见，在 chrome 中，ES5 函数参数只用 LocalScope 作用域；而 ES6 中函数默认值参数会形成单独的作用域，这个作用域占用了之前的 Local Scope 而函数体内声明的变量形成了一个块级作用域 Block Scope，通常情况下，此时的 local 作用域被称为居间作用域（intermediate scope） Babel 转换 默认参数代码 转换后如下 'use strict'var x = 1function fun() &#123; var x = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 6 var z = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 7 return (function (x) &#123; debugger var x = 2 var y = 3 console.log(x, y) &#125;)(x)&#125;fun(4, 5) 是否携带默认参数，作用域前后变化如下： 懒执行默认参数只有在函数每次执行的时候才会调用，而不是在函数定义时。这与其他部分语言是表现是不相同的。如下代码由于默认参数的懒执行(惰性求值)，只要不运行 skyline 函数，控制台执行并不会报错。 var x = 1function skyline(x = z) &#123;&#125; TDZ(Temporal Dead Zone)TDZ 即暂时性死区，简单来说就是 let/const 声明之前（包括声明时）就访问对应的变量与常量，会抛出 ReferenceError 错误。 // 不报错var x = x;// 报错let x = x; 函数默认值传参也会造成暂时性死区。 var x = 1function haha(x = x) &#123;&#125;haha() //Uncaught ReferenceError: Cannot access 'x' before initializationfunction skyline(x = y, y) &#123;&#125;skyline(1, 2)skyline(undefined, 2) //Uncaught ReferenceError: Cannot access 'y' before initialization 函数创建函数创建一般有函数声明与函数表达式两种方式。函数表达式: let fn1 = function() {}函数声明: function fn2() {}Javascript 解析器会率先读取函数声明，在函数代码执行之前，已经将函数声明提升到执行环境，故可以在声明前执行。但是，函数表达式提前执行会导致错误。 作用域链作用域链的作用是保证最执行环境有权访问的所有变量和函数的有序访问。作用域链最前端始终都是当前代码所在环境的变量对象，而后一步一步向外成延伸，直到全局执行环境。标志符解析是沿着作用域链一级一级搜索的过程，直到找到为止，故而位于作用域链最前端的变量作为当前环境的变量。 箭头函数ES6将函数的书写语法简单化，可以直接通过如下方式书写 const skyline = () =&gt; 'skyline' 箭头函数需要注意如下几点： 返回对象包裹 当返回一个对象时，需要写return或用括号包裹 const skyline = () =&gt; (&#123;name: 'skyline'&#125;)// const skyline = () =&gt; &#123;return &#123;name: 'skyline'&#125;&#125; this指向改变 this指向跟定义绑定而不是执行时 const skyline = () =&gt; &#123; console.log(this)&#125;function sky() &#123; console.log(this)&#125;const me = &#123;skyline,sky&#125;me.skyline()// windowme.sky()// &#123;skyline: ƒ, sky: ƒ&#125; 函数参数 函数内部不可使用arguments，可以用剩余参数符获取，并且得到的是一个数组而不是类数组。 不做Generator 不用使用yield命令，不用做Generator函数 BMW WARNING Bulletin 本文首发于 skyline.show 欢迎访问，文章实时更新，如果有什么错误或不严谨之处望请指出，十分感谢。如果你觉得有用，欢迎到Github 仓库点亮 ⭐️。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 《JavaScript 高级程序设计》 Warrant 本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"},{"name":"语法","slug":"语法","permalink":"http://www.skyline.show/tags/语法/"}]}]}