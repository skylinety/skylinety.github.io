{"meta":{"title":"Skyline's blog","subtitle":"大江东去，长安西去，为功名走遍天涯路。 厌舟车，喜琴书，早星星鬓影瓜田暮。 心待足时名便足：高，高处苦；低，低处苦 — 薛昂夫","description":"不瓜，也不怎么爱吃瓜，不好好写字的程序猿不是合格的农民，所以要多爬爬东坡，多亲近方块呀","author":"skyline","url":"http://www.skyline.show"},"pages":[{"title":"","date":"2022-04-22T10:00:30.000Z","updated":"2022-04-22T10:00:30.000Z","comments":true,"path":"404.html","permalink":"http://www.skyline.show/404.html","excerpt":"","text":""},{"title":"About Me","date":"2016-04-20T20:48:33.000Z","updated":"2022-04-22T10:00:30.000Z","comments":false,"path":"about/index.html","permalink":"http://www.skyline.show/about/index.html","excerpt":"","text":"一个漂流在江南的四川人，90后，承认老啦，但求别加入脱发大军就行~ 为什么来杭城？ 西湖？油纸伞？压在雷峰塔下的大白蛇？不造，不造，可能是为了不是为了邂逅丁香花一样的姑娘🤣~ 目前是一颗在前端道路上不断长大的小白菜。电子科技大学毕业，小小的本科生，亚历山大，感觉给学校拖后腿啦拖后腿啦！所以加油中~ 安利一波自己的学校UESTC，妹纸少，很有学习氛围，大家快来啊，真的可以学到东西😶~ 突然不明白当初的自己为毛辣么学渣~ 喜欢的东西有好多。摄影，历史，小说，诗词，爬爬山，玩玩水，当然还有coding~ 说到摄影，买来的相机好久都没开机啦，看了好几本摄影书都不会玩，基本处理懵c状态，大神带啊~ 说到历史，最稀罕大宋啦。不仅仅因为有稀罕的宋词、稀罕的东坡、稀罕的繁荣经济，也因为有国难下捐躯的英雄、想要一口盐汽水喷死的奸佞、烽火下无辜的百姓以及北国大雪纷飞下受难的帝姬~ 说到小说，当然不只是看啊。但想起自己几次尝试都只写了一个开头，好气啊~ 说到诗词，更偏爱词，东坡、二晏、花间、纳兰，简直溜到爆炸~ 说到游山玩水，哪个不喜欢啊，但是钱包时常不允许啊啊啊~ 说到敲代码，额，对了，不说啦，该敲代码啦~ 博客中大多数技术文章都是日常积累的笔记，一个人的笔记，错误当然有好多，发现错误请联系我及时更正~ 欢迎各位大大以居高临下的态度来指正，但是千万嫑出口成脏啊，骂我我不会张时你的（就是不鸟你）~ 邮箱: 626660911@qq.comQQ: 626660911微信: skylinelty"},{"title":"Tags","date":"2022-04-22T10:00:30.000Z","updated":"2022-04-22T10:00:30.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.skyline.show/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-22T10:00:30.000Z","updated":"2022-04-22T10:00:30.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.skyline.show/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Shell中字符串相关操作","date":"2022-06-08T08:34:57.000Z","updated":"2022-06-08T08:48:43.000Z","comments":true,"path":"Shell中字符串相关操作.html","link":"","permalink":"http://www.skyline.show/Shell中字符串相关操作.html","excerpt":"Shell 中字符串相关操作 字符包含判定 == grep 将字符串作为命令执行 获取子串（字符串切割） cut 截取语法 字符串转数组 BMW WARNING Bulletin Material Warrant 字符包含判定==STR='GNU/Linux is an operating system'SUB='Linux'if [[ \"$STR\" == *\"$SUB\"* ]]; then echo \"It's there.\"fi grep使用 grep STR='GNU/Linux is an operating system'SUB='Linux'if grep -q \"$SUB\" &lt;&lt;&lt; \"$STR\"; then echo \"It's there\"fi 将字符串作为命令执行使用 eval 命令 eval 'echo 1' 获取子串（字符串切割）cut使用 cut 命令，基本使用如下 echo \"STRING\" | cut -cN-M echo \"skyline\" | cut -c2-6# kylin 也可以不传 M echo \"skyline\" | cut -c2-# kyline 上述代码实现的效果类似于 JS 中字符串 slice 的效果，但注意字符串截取的索引指代不同。要实现字符串 split 效果，需要添加额外参数可以通过-d 参数指定分割符号（delimiter）分割字符后将同样得到一个数组，需要添加 -f 参数来指定截取的索引 echo \"skyline\" | cut -d'i' -f1# skylecho \"skyline\" | cut -d'i' -f2# neecho \"skyline\" | cut -d'i' -f1-# skyline 截取语法","text":"Shell 中字符串相关操作 字符包含判定 == grep 将字符串作为命令执行 获取子串（字符串切割） cut 截取语法 字符串转数组 BMW WARNING Bulletin Material Warrant 字符包含判定==STR='GNU/Linux is an operating system'SUB='Linux'if [[ \"$STR\" == *\"$SUB\"* ]]; then echo \"It's there.\"fi grep使用 grep STR='GNU/Linux is an operating system'SUB='Linux'if grep -q \"$SUB\" &lt;&lt;&lt; \"$STR\"; then echo \"It's there\"fi 将字符串作为命令执行使用 eval 命令 eval 'echo 1' 获取子串（字符串切割）cut使用 cut 命令，基本使用如下 echo \"STRING\" | cut -cN-M echo \"skyline\" | cut -c2-6# kylin 也可以不传 M echo \"skyline\" | cut -c2-# kyline 上述代码实现的效果类似于 JS 中字符串 slice 的效果，但注意字符串截取的索引指代不同。要实现字符串 split 效果，需要添加额外参数可以通过-d 参数指定分割符号（delimiter）分割字符后将同样得到一个数组，需要添加 -f 参数来指定截取的索引 echo \"skyline\" | cut -d'i' -f1# skylecho \"skyline\" | cut -d'i' -f2# neecho \"skyline\" | cut -d'i' -f1-# skyline 截取语法 基本语法 string='xxx'echo $&#123;string:S&#125;echo $&#123;string:S:E&#125; S 与 E 分别指代开始和结束索引使用 a=skylineecho $&#123;a:1&#125;# kylineecho $&#123;a:2&#125;# ylineecho $&#123;a:2:4&#125;# ylin 字符串转数组 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[],"tags":[]},{"title":"","slug":"Shell条件判定","date":"2022-06-07T09:48:52.000Z","updated":"2022-06-09T06:14:17.000Z","comments":true,"path":"Shell条件判定.html","link":"","permalink":"http://www.skyline.show/Shell条件判定.html","excerpt":"Shell 条件判定 if command [expression] [[expression]] (command) ((expression)) 三元 ifcommand表示验证命令是否成功执行。代码源文件如下对于本文后续所有类似代码，首先执行 read -p \"Enter first string: \" VAR1read -p \"Enter second string: \" VAR2 并进行两次相同输入后。 if \"$VAR1\" == \"$VAR2\"; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# 1: command not found# Strings are not equal. if 后不跟包裹符号时，需要跟可执行命令而不是表达式。若命令执行成功，则执行 then，否则执行 else if echo Skyline; then echo \"echo Skyline.\"else echo \"Something wrong.\"fi# Skyline# echo Skyline [expression]表示验证条件表达式是否成立，进行条件判定。Bash-Conditional-Expressions if [ \"$VAR1\" == \"$VAR2\" ]; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal. [[expression]][]的升级版本， if [[ \"$VAR1\" == \"$VAR2\" ]]; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal. [[]]内部支持更多的表达式语法。 # 检查文件是否为符号链接[[ -L $file &amp;&amp; -f $file ]][ -L \"$file\" ] &amp;&amp; [ -f \"$file\" ] (command)","text":"Shell 条件判定 if command [expression] [[expression]] (command) ((expression)) 三元 ifcommand表示验证命令是否成功执行。代码源文件如下对于本文后续所有类似代码，首先执行 read -p \"Enter first string: \" VAR1read -p \"Enter second string: \" VAR2 并进行两次相同输入后。 if \"$VAR1\" == \"$VAR2\"; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# 1: command not found# Strings are not equal. if 后不跟包裹符号时，需要跟可执行命令而不是表达式。若命令执行成功，则执行 then，否则执行 else if echo Skyline; then echo \"echo Skyline.\"else echo \"Something wrong.\"fi# Skyline# echo Skyline [expression]表示验证条件表达式是否成立，进行条件判定。Bash-Conditional-Expressions if [ \"$VAR1\" == \"$VAR2\" ]; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal. [[expression]][]的升级版本， if [[ \"$VAR1\" == \"$VAR2\" ]]; then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal. [[]]内部支持更多的表达式语法。 # 检查文件是否为符号链接[[ -L $file &amp;&amp; -f $file ]][ -L \"$file\" ] &amp;&amp; [ -f \"$file\" ] (command) 表示验证子命令是否成功执行。()其内部不是表达式而是可执行命令，表示在 subshell 跑 command 命令，可以理解为单开进程执行跟主程序无关的其他命令。 if (\"$VAR1\" == \"$VAR2\"); then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# 依次输入1回车，1回车，结果为：# 1: command not found# Strings are not equal. 上述代码中，()内部内容被当做可执行命令执行，故报错，转到 else 执行。()内部命令执行成功，则才会转到 then 执行。 if (echo Skyline); then echo \"echo Skyline.\"else echo \"Something wrong.\"fi ()内执行的命令结果，不会对父 shell 运行结果 造成影响。 skyline=1; (skyline=2);echo $skyline# 1 当()前面加上$时，表示 Command-Substitution，与command一致，表示其运行结果充当所在命令行的一部分 echo 'skyline'| cut -c`echo 2`-3# kyecho 'skyline'| cut -c$(echo 2)-3# ky ((expression))表示验证算数表达式是否成立。(())内部进行算数表达式的计算。算数表达式包含常见的一元二元运算符，逻辑运算符等。 if ((\"$VAR1\" == \"$VAR2\")); then echo \"Strings are equal.\"else echo \"Strings are not equal.\"fi# Strings are equal. Shell-Arithmetic当(())前面加上$时，表示得到的算数结果充当所在命令行的一部分. echo 'skyline'| cut -c$((1 + 1))-3# ky 上述代码实现的效果可以使用 expr 实现 echo 'skyline'| cut -c$(expr 1 + 1)-3# ky 注意，expr 通常与一起使用，或与$()使用，注意expr中空格的使用，否则报错也可使用 let 来实现计算 start=1let start+=1echo $startecho 'skyline'| cut -c$start-3 三元test \"$VAR1\" == \"$VAR2\" &amp;&amp; echo \"Strings are equal.\" || echo \"Strings are not equal.\"","categories":[],"tags":[]},{"title":"Shell常见操作汇总","slug":"Shell常见操作汇总","date":"2022-05-27T10:06:41.000Z","updated":"2022-05-27T10:06:41.000Z","comments":true,"path":"Shell常见操作汇总.html","link":"","permalink":"http://www.skyline.show/Shell常见操作汇总.html","excerpt":"Shell 常见操作汇总 Shell 常见操作汇总 判定目录或文件存在 算数命令 查看目录下文件夹 创建嵌套文件夹并进入 查看远程服务及端口是否开启 设置别名 临时别名 永久生效 查看端口占用 删除目录下模糊匹配的文件 命令 解析 查找目录下包含指定字符的文件 命令 解析 BMW WARNING Bulletin Material Warrant 判定目录或文件存在if [ -d \"Docs/Major/Shell/Scripts\" ]; then echo \"目录存在\"else echo \"目录不存在\"fi# 目录存在if [ -f \"Docs/Major/Shell/Scripts/Shell常见操作汇总.md\" ]; then echo \"文件存在\"else echo \"文件不存在\"fi# 文件存在 类似的其他判定 标记 描述 -L 文件是否为软连接 -h 文件是否为软连接 -d 目录判定 -w 文件可否写入 -x 文件可否执行 -r 文件可否读取 -s 文件存在且占用空间大于 0 算数命令使用exprmingexpr 1 + 1 plus=`expr 1 + 1`echo $plus# 2minus=$(expr 1 - 1)echo $minus# 0multiply=$((2 * 2))echo $multiply# 4 当()前面加上$时，表示 Command-Substitution，与command一致，表示其运行结果充当所在命令行的一部分. (())内部进行算数表达式的计算。 查看目录下文件夹ls -d src/*/ 查看 src 下包含的文件夹 ls -d1 */ 换行形式查看当前目录下的文件夹 创建嵌套文件夹并进入mkdir /home/foo/123 &amp;&amp; cd $_ 查看远程服务及端口是否开启telnet ip 3306 设置别名临时别名alias m=&quot;tldr&quot;tldr 是一个以示例代替说明的命令使用说明工具，比自带的命令行手册易读。 永久生效vim ~/.bashrc# vim ~/.zshrc 在末尾行加入alias m=&quot;tldr&quot;然后source ~/.bashrc 查看端口占用netstat -apn | grep 8884 lsof -i:8884 删除目录下模糊匹配的文件命令find . -name &quot;*.js&quot; | xargs rm -rf 解析","text":"Shell 常见操作汇总 Shell 常见操作汇总 判定目录或文件存在 算数命令 查看目录下文件夹 创建嵌套文件夹并进入 查看远程服务及端口是否开启 设置别名 临时别名 永久生效 查看端口占用 删除目录下模糊匹配的文件 命令 解析 查找目录下包含指定字符的文件 命令 解析 BMW WARNING Bulletin Material Warrant 判定目录或文件存在if [ -d \"Docs/Major/Shell/Scripts\" ]; then echo \"目录存在\"else echo \"目录不存在\"fi# 目录存在if [ -f \"Docs/Major/Shell/Scripts/Shell常见操作汇总.md\" ]; then echo \"文件存在\"else echo \"文件不存在\"fi# 文件存在 类似的其他判定 标记 描述 -L 文件是否为软连接 -h 文件是否为软连接 -d 目录判定 -w 文件可否写入 -x 文件可否执行 -r 文件可否读取 -s 文件存在且占用空间大于 0 算数命令使用exprmingexpr 1 + 1 plus=`expr 1 + 1`echo $plus# 2minus=$(expr 1 - 1)echo $minus# 0multiply=$((2 * 2))echo $multiply# 4 当()前面加上$时，表示 Command-Substitution，与command一致，表示其运行结果充当所在命令行的一部分. (())内部进行算数表达式的计算。 查看目录下文件夹ls -d src/*/ 查看 src 下包含的文件夹 ls -d1 */ 换行形式查看当前目录下的文件夹 创建嵌套文件夹并进入mkdir /home/foo/123 &amp;&amp; cd $_ 查看远程服务及端口是否开启telnet ip 3306 设置别名临时别名alias m=&quot;tldr&quot;tldr 是一个以示例代替说明的命令使用说明工具，比自带的命令行手册易读。 永久生效vim ~/.bashrc# vim ~/.zshrc 在末尾行加入alias m=&quot;tldr&quot;然后source ~/.bashrc 查看端口占用netstat -apn | grep 8884 lsof -i:8884 删除目录下模糊匹配的文件命令find . -name &quot;*.js&quot; | xargs rm -rf 解析 Shell 中只有部分命令支持标准输入，例如 wc、grep 等，通过管道 | 很容易将前置命令的标准输出传递给这些命令。但是部分命令不支持标准输入，例如 echo rm mkdir 等，这里需要 xargs 来提供xargs 查找目录下包含指定字符的文件命令在 Docs 目录下查找包含 find 字符的文件 ls ./ | xargs grep -rni findfind . -type f | xargs grep -rni findgrep -rni ./ -e find grep -rniw ./ -e user 上述代码不会匹配 users grep -rniw ./ -e user -l -l –files-with-matches只输出匹配的文件名 Only the names of files containing selected lines are written to standard output 解析grep 参数 r 递归查找子目录文件 n 列出行标 i 忽略大小写 e 搜索时启用正则匹配 w 精确指定单词，需要为单词，英文单词前后有字母不匹配 l 只输出匹配的文件名 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"},{"name":"Scripts","slug":"Scripts","permalink":"http://www.skyline.show/tags/Scripts/"}]},{"title":"Shell中sed的使用","slug":"Shell中sed的使用","date":"2022-05-27T08:29:03.000Z","updated":"2022-05-27T08:29:03.000Z","comments":true,"path":"Shell中sed的使用.html","link":"","permalink":"http://www.skyline.show/Shell中sed的使用.html","excerpt":"sed 的使用 sed 的使用 简介 选项参数 -n -e -i 命令参数 i/a d p s/c 常见用法 文末插入 替换字符 行数 字符行号 BMW WARNING Bulletin Material Warrant 简介流编辑器，sed 用于读取指定文件或标准输入。如果没有文件被指定，可由命令列表来指定输入，进行相应修改后写入到标准输出。 选项参数-n默认情况下，在所有的标准输出都会被打印到屏幕上。 -n 选项用于指定输出内容。 # 输出100到200行sed -n '100,200p' skyline.txt# 输出文件行数sed -n '$=' skyline.txt# cat skyline.txt | wc -l 多个地址用逗号隔开 -e-e 是编辑命令，用于执行多个编辑任务。sed -e &#39;1,10d&#39; -e &#39;s/skyline/lty/g&#39; skyline.txtskyline.txt 将依次执行之后的命令，删除一到十行，并且全局替换’skyline’为’lty’ -i-i 指定备份，指定空字符串或不指定内容直接修改源文件(linux 下可以不指定，mac 下需指定空字符)。没有指定该选项将直接标准输出，不进行任何实质修改 # 指定skyline.txt.bak的备份sed -i '.bak' 's/skyline/lty/g' ./skyline.txt skyline.txt 源文件内容将会备份到 skyline.txt.bak 文件中 sed -i '' 's/skyline/lty/g' ./skyline.txt 将不备份直接修改源文件 sed -i 's/skyline/lty/g' ./skyline.txt linux 可以直接执行修改源文件，mac 下需要如上指定空字符方可在 Mac 上，sed 命令直接操作文件的时候，必须指定备份的格式，而在 linux 上，却并没有这个要求 命令参数i/a","text":"sed 的使用 sed 的使用 简介 选项参数 -n -e -i 命令参数 i/a d p s/c 常见用法 文末插入 替换字符 行数 字符行号 BMW WARNING Bulletin Material Warrant 简介流编辑器，sed 用于读取指定文件或标准输入。如果没有文件被指定，可由命令列表来指定输入，进行相应修改后写入到标准输出。 选项参数-n默认情况下，在所有的标准输出都会被打印到屏幕上。 -n 选项用于指定输出内容。 # 输出100到200行sed -n '100,200p' skyline.txt# 输出文件行数sed -n '$=' skyline.txt# cat skyline.txt | wc -l 多个地址用逗号隔开 -e-e 是编辑命令，用于执行多个编辑任务。sed -e &#39;1,10d&#39; -e &#39;s/skyline/lty/g&#39; skyline.txtskyline.txt 将依次执行之后的命令，删除一到十行，并且全局替换’skyline’为’lty’ -i-i 指定备份，指定空字符串或不指定内容直接修改源文件(linux 下可以不指定，mac 下需指定空字符)。没有指定该选项将直接标准输出，不进行任何实质修改 # 指定skyline.txt.bak的备份sed -i '.bak' 's/skyline/lty/g' ./skyline.txt skyline.txt 源文件内容将会备份到 skyline.txt.bak 文件中 sed -i '' 's/skyline/lty/g' ./skyline.txt 将不备份直接修改源文件 sed -i 's/skyline/lty/g' ./skyline.txt linux 可以直接执行修改源文件，mac 下需要如上指定空字符方可在 Mac 上，sed 命令直接操作文件的时候，必须指定备份的格式，而在 linux 上，却并没有这个要求 命令参数i/a i 与 a 都是插入参数，后面可以接字串，用 a 插入的字串会在行的下一行行首出现，用 i 插入的字串会在当前行的行首，出现单独一行需要在字符后加上\\n # Mac/Linuxsed -i '' '9i\\6666666' skyline.txt# Linuxsed -i '' '9a\\6666666' skyline.txt 注意 mac 下\\后需要换行 d删除，之后不接内容sed -i &#39;&#39; &#39;1,2d&#39; skyline.txt p标准输出内容 sed -n &#39;3p&#39; skyline s/c替换部分内容，s 来替换，通常这个 s 搭配正则表达式。 c 替换通常指定行，之后用这些字串取代 n1,n2 之间的行内容 # 替换1到5行的内容为lalalased -i '' '1,5c\\lalala' skyline.txt# 替换sed -i '' 's/666/222/g' skyline.txt 常见用法文末插入注意 mac 下\\后需要换行 sed -i '' '$a\\skyline' skyline.txt 替换字符替换第 n 个匹配的字符 echo sksksksksksk | sed 's/sk/SK/3' 行数输出文件行数 sed -n '$=' skyline.txt 字符行号输出文件第 n 个匹配字符所在行号 sed -n /skyline/= skyline.txt | sed -n 2p #匹配第二个skyline，打印其所在行号 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"},{"name":"Commands","slug":"Commands","permalink":"http://www.skyline.show/tags/Commands/"}]},{"title":"Shell中xargs使用","slug":"Shell中xargs使用","date":"2022-05-27T08:06:40.000Z","updated":"2022-05-27T08:06:40.000Z","comments":true,"path":"Shell中xargs使用.html","link":"","permalink":"http://www.skyline.show/Shell中xargs使用.html","excerpt":"Shell 中 xargs 使用 Shell 中 xargs 使用 概述 基础使用示例 echo wc mkdir 参数 -0 -I -L -n -d -t -p BMW WARNING Bulletin Material Warrant 概述Shell 中只有部分命令支持标准输入，例如 wc、grep、xargs 等，通过管道 | 很容易将前置命令的标准输出传递给这些命令。但是部分命令不支持标准输入，不能通过管道 | 直接操作，例如 echo rm mkdir 等。这需要 xargs 为那些不支持标准输入的命令提供管道操作。通过 xargs 将标准输入转换成参数来完成后续命令。如果转换成的参数有多个（通过标准输入空符分割），后续命令重复执行。 The xargs command in UNIX is a command line utility for building an execution pipeline from standard input. Whilst tools like grep can accept standard input as a parameter, many other tools cannot. Using xargs allows tools like echo and rm and mkdir to accept standard input as arguments. 基础使用示例echo# inputecho skyline | echo#output # inputecho skyline | xargs echo# outputskyline 在未指定后续操作的情况下，xargs 默认执行 echo 操作 # inputecho skyline | xargs# outputskyline 通常 xargs 与管道符一起使用，但其也可以从其他方式指定标准输入。通过键盘指定标准输入 # inputxargs # 输入 xargs 输入 ⏎skyline # 输入 skyline 输入 ⏎ 输入 ^ + D# outputskyline # 输出 与如下命令等价 # inputxargs echo # 输入 xargs echo 输入 ⏎skyline # 输入 skyline 输入 ⏎ 输入 ^ + D# outputskyline # 输出 wc# inputfind . -name &quot;*.md&quot;# output./Major/Mobile/Flutter/Flutter基础使用汇总.md./Major/Mobile/Flutter/Flutter基础控件使用.md./Major/Shell/Shell中xargs使用.md./Major/Shell/Shell中的符号.md./Major/Shell/Shell常见操作汇总.md./README.md./Tools/DEVs/VSCode/Extensions/PicGo.md./Tools/OS/ipadOS使用.md # inputfind . -name &quot;*.md&quot; | wc -l# output 8 # inputfind . -name &quot;*.md&quot; | xargs wc -l# output 84 ./Major/Mobile/Flutter/Flutter基础使用汇总.md 109 ./Major/Mobile/Flutter/Flutter基础控件使用.md 0 ./Major/Shell/Shell中xargs使用.md 131 ./Major/Shell/Shell中的符号.md 13 ./Major/Shell/Shell常见操作汇总.md 4 ./README.md 44 ./Tools/DEVs/VSCode/Extensions/PicGo.md 5 ./Tools/OS/ipadOS使用.md 390 total mkdir# inputecho 1 2 3 | xargs mkdirls# output1 2 3 参数-0","text":"Shell 中 xargs 使用 Shell 中 xargs 使用 概述 基础使用示例 echo wc mkdir 参数 -0 -I -L -n -d -t -p BMW WARNING Bulletin Material Warrant 概述Shell 中只有部分命令支持标准输入，例如 wc、grep、xargs 等，通过管道 | 很容易将前置命令的标准输出传递给这些命令。但是部分命令不支持标准输入，不能通过管道 | 直接操作，例如 echo rm mkdir 等。这需要 xargs 为那些不支持标准输入的命令提供管道操作。通过 xargs 将标准输入转换成参数来完成后续命令。如果转换成的参数有多个（通过标准输入空符分割），后续命令重复执行。 The xargs command in UNIX is a command line utility for building an execution pipeline from standard input. Whilst tools like grep can accept standard input as a parameter, many other tools cannot. Using xargs allows tools like echo and rm and mkdir to accept standard input as arguments. 基础使用示例echo# inputecho skyline | echo#output # inputecho skyline | xargs echo# outputskyline 在未指定后续操作的情况下，xargs 默认执行 echo 操作 # inputecho skyline | xargs# outputskyline 通常 xargs 与管道符一起使用，但其也可以从其他方式指定标准输入。通过键盘指定标准输入 # inputxargs # 输入 xargs 输入 ⏎skyline # 输入 skyline 输入 ⏎ 输入 ^ + D# outputskyline # 输出 与如下命令等价 # inputxargs echo # 输入 xargs echo 输入 ⏎skyline # 输入 skyline 输入 ⏎ 输入 ^ + D# outputskyline # 输出 wc# inputfind . -name &quot;*.md&quot;# output./Major/Mobile/Flutter/Flutter基础使用汇总.md./Major/Mobile/Flutter/Flutter基础控件使用.md./Major/Shell/Shell中xargs使用.md./Major/Shell/Shell中的符号.md./Major/Shell/Shell常见操作汇总.md./README.md./Tools/DEVs/VSCode/Extensions/PicGo.md./Tools/OS/ipadOS使用.md # inputfind . -name &quot;*.md&quot; | wc -l# output 8 # inputfind . -name &quot;*.md&quot; | xargs wc -l# output 84 ./Major/Mobile/Flutter/Flutter基础使用汇总.md 109 ./Major/Mobile/Flutter/Flutter基础控件使用.md 0 ./Major/Shell/Shell中xargs使用.md 131 ./Major/Shell/Shell中的符号.md 13 ./Major/Shell/Shell常见操作汇总.md 4 ./README.md 44 ./Tools/DEVs/VSCode/Extensions/PicGo.md 5 ./Tools/OS/ipadOS使用.md 390 total mkdir# inputecho 1 2 3 | xargs mkdirls# output1 2 3 参数-0 用 null 作为分隔符，与 find 中 -print0 意义一致，且需一起使用 -I将标准输入以指定字符缓存，方便后续使用。类似于正则中()的作用。 将当前目录下文件统一加后缀 # inputls# output# one two three# inputfind . -type f -name '*' -print0 | xargs -0 -I&#123;&#125; mv &#123;&#125; &#123;&#125;.txt &amp;&amp; ls# one.txt two.txt three.txt# inputls | xargs -I_ mv _ _.bak &amp;&amp; ls# output# one.txt.bak three.txt.bak two.txt.bak -Lnumber 类型，解决多行输入问题，将标准输入按照该数字指定的行数进行分隔，假设为 -L 2，则每次执行取两行作为标准输入，执行多次，直到多行执行结束。多数命令不支持多行参数，通常直接指定 -L1 # inputecho -e \"She*\\nFlu*\" | xargs -L 1 find . -name# output# ./Major/Shell# ./Major/Shell/Shell中xargs使用.md# ./Major/Shell/Shell中的符号.md# ./Major/Shell/Shell常见操作汇总.md# ./Major/Mobile/Flutter# ./Major/Mobile/Flutter/Flutter基础使用汇总.md# ./Major/Mobile/Flutter/Flutter基础控件使用.md -nnumber 类型，解决同行多项参数问题。与-L 参数互斥，同时指定选后指定的选项。 # inputecho -e \"She* Flu*\" | xargs -n 1 find . -name# output# ./Major/Shell# ./Major/Shell/Shell中xargs使用.md# ./Major/Shell/Shell中的符号.md# ./Major/Shell/Shell常见操作汇总.md# ./Major/Mobile/Flutter# ./Major/Mobile/Flutter/Flutter基础使用汇总.md# ./Major/Mobile/Flutter/Flutter基础控件使用.md -d指定分隔符这在处理有空格等特殊符号的输入中很有用 -t打印执行日志 # inputecho skyline | xargs -t echo# outputecho skylineskyline -p打印实际操作并让用户选择是否执行 # inputls# outputone three two# inputecho &apos;one two three&apos; | xargs -p rm -rf# input &amp; outputrm -rf one two three?...y# inputls# output 上述确认操作中除了输入 y，其他任何输入都不会进行删除操作 BMW WARNINGBulletinI am a bucolic migrant worker but I never walk backwards. Material Linux and Unix xargs command tutorial with examples &gt; 8 Practical Examples of Linux Xargs Command for Beginners Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"},{"name":"Commands","slug":"Commands","permalink":"http://www.skyline.show/tags/Commands/"}]},{"title":"Git常见操作","slug":"Git常见操作","date":"2022-05-27T07:41:03.000Z","updated":"2022-06-01T07:38:26.000Z","comments":true,"path":"Git常见操作.html","link":"","permalink":"http://www.skyline.show/Git常见操作.html","excerpt":"Git 常见操作 Git 常见操作 git 单列已添加到暂存区的文件 Git 本地分支有提交，单独查看并运行远程该分支 新建仓库时关联远程与本地 git 同时推送多个仓库 git remote add git remote set-url https 方式访问 git 免输密码 Git 用户配置 查看配置 修改全局配置 GIT SSH 免密 同步 Github fork 仓库 git 单列已添加到暂存区的文件通过git status命令可以列出所有增删改的文件，并做了是否添加跟踪，是否加入暂存区的区分。若只看加入暂存区的文件，使用 git diff --name-only --cached 如上图所示为某次git status后展示的信息。git diff –name-only –cached展示的信息如下git diff --cached只会展示暂存区文件的变更。 Git 本地分支有提交，单独查看并运行远程该分支本地 dev 分支有自己 commit 的版本，想要获取远端最新代码并运行（不包括本地新 commit 代码） git fetchgit checkout -b test origin/dev test 分支即是最新的远程 dev 副本 git fetch 将本地仓库的所有远程副本更新，但不会更新到工作空间 新建仓库时关联远程与本地首先执行git init法 1： git remote set-url origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;//或者先删除后增加//git remote rm origin//git remote add origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;git branch --set-upstream-to=origin/master master//与远程关联git pull origin master --allow-unrelated-histories //后面参数防止出现fatal: refusing to merge unrelated histories 法 2： git remote set-url origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;//或者先删除后增加//git remote rm origin//git remote add origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;git add -Agit commit -m\"init\"git push -u origin master git 同时推送多个仓库当前仓库正常开发，中途需要添加另一个推送仓库当前仓库只关联一个远程仓库，查看远端仓库信息：git remote -v结果如下 新增关联仓库常用如下两个方案： git remote addgit remote add origingit &lt;https://git.citycloud.com.cn:3000/hcsg_code/xxxx.git&gt; 查看远端仓库信息：git remote -v结果如下 这个地方只能是其他命名而不能是 origin 否则报错 本方案存在一个弊端，需要向远端仓库分别提交代码 git push origin master:mastergit push origingit master:master git remote set-urlgit remote set-url --add origin &lt;https://git.citycloud.com.cn:3000/hcsg_code/xxxx.git git remote -v结果如下 本方案提交时，所有仓库都会同步接收，推荐使用。 https 方式访问 git 免输密码在 git 早期版本中，https 方式每次都要输入密码，按照如下设置即可免去烦恼 设置记住密码（默认 15 分钟）：git config --global credential.helper cache 设置时间，可以这样做：git config credential.helper &#39;cache --timeout=3600&#39; 长期存储密码： linuxgit config --global credential.helper store macgit config --global credential.helper osxkeychain Git 用户配置查看配置# 查看全部配置git config --list#查看指定配置git config user.namegit config user.email 修改全局配置","text":"Git 常见操作 Git 常见操作 git 单列已添加到暂存区的文件 Git 本地分支有提交，单独查看并运行远程该分支 新建仓库时关联远程与本地 git 同时推送多个仓库 git remote add git remote set-url https 方式访问 git 免输密码 Git 用户配置 查看配置 修改全局配置 GIT SSH 免密 同步 Github fork 仓库 git 单列已添加到暂存区的文件通过git status命令可以列出所有增删改的文件，并做了是否添加跟踪，是否加入暂存区的区分。若只看加入暂存区的文件，使用 git diff --name-only --cached 如上图所示为某次git status后展示的信息。git diff –name-only –cached展示的信息如下git diff --cached只会展示暂存区文件的变更。 Git 本地分支有提交，单独查看并运行远程该分支本地 dev 分支有自己 commit 的版本，想要获取远端最新代码并运行（不包括本地新 commit 代码） git fetchgit checkout -b test origin/dev test 分支即是最新的远程 dev 副本 git fetch 将本地仓库的所有远程副本更新，但不会更新到工作空间 新建仓库时关联远程与本地首先执行git init法 1： git remote set-url origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;//或者先删除后增加//git remote rm origin//git remote add origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;git branch --set-upstream-to=origin/master master//与远程关联git pull origin master --allow-unrelated-histories //后面参数防止出现fatal: refusing to merge unrelated histories 法 2： git remote set-url origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;//或者先删除后增加//git remote rm origin//git remote add origin &lt;https://git.oschina.net/skylinelty/skyline-blog.git&gt;git add -Agit commit -m\"init\"git push -u origin master git 同时推送多个仓库当前仓库正常开发，中途需要添加另一个推送仓库当前仓库只关联一个远程仓库，查看远端仓库信息：git remote -v结果如下 新增关联仓库常用如下两个方案： git remote addgit remote add origingit &lt;https://git.citycloud.com.cn:3000/hcsg_code/xxxx.git&gt; 查看远端仓库信息：git remote -v结果如下 这个地方只能是其他命名而不能是 origin 否则报错 本方案存在一个弊端，需要向远端仓库分别提交代码 git push origin master:mastergit push origingit master:master git remote set-urlgit remote set-url --add origin &lt;https://git.citycloud.com.cn:3000/hcsg_code/xxxx.git git remote -v结果如下 本方案提交时，所有仓库都会同步接收，推荐使用。 https 方式访问 git 免输密码在 git 早期版本中，https 方式每次都要输入密码，按照如下设置即可免去烦恼 设置记住密码（默认 15 分钟）：git config --global credential.helper cache 设置时间，可以这样做：git config credential.helper &#39;cache --timeout=3600&#39; 长期存储密码： linuxgit config --global credential.helper store macgit config --global credential.helper osxkeychain Git 用户配置查看配置# 查看全部配置git config --list#查看指定配置git config user.namegit config user.email 修改全局配置 git config --global user.name \"username\"git config --global user.email \"email\" GIT SSH 免密查看本地 SSH 密钥 cd ~/.sshlsid_rsa 是私钥，id_rsa.pub 是公钥。 创建 SSH 密钥 如果没有相关密钥文件，需要生成 ssh-keygen 输入命令，生成相关文件 复制公钥 cat ~/.ssh/id_rsa.pub复制对应内容 远程仓库设置 在 github 等远程仓库设置页面对应的 SSH keys 粘贴公钥内容 同步 Github fork 仓库配置 remote，指向原始仓库 git remote add upstream https://github.com/skyline.git 获取上游仓库分支 获取到上游仓库分支，及相关的提交信息，它们将被保存在本地的 upstream/master，upstream/hotfix 等分支 git fetch upstream 切换到本地的 master 分支 git checkout master 合并上游分支 将 upstream/master 分支合并到本地的 master 分支，本地的 master 分支将与上游仓库保持同步，且不会丢失本地修改。 git merge upstream/master 上传代码 将上游仓库的代码更新到自己的远程仓库中 git push","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"DEVs","slug":"DEVs","permalink":"http://www.skyline.show/tags/DEVs/"},{"name":"Git","slug":"Git","permalink":"http://www.skyline.show/tags/Git/"}]},{"title":"浏览器回流与重绘","slug":"浏览器回流与重绘","date":"2022-05-27T07:41:03.000Z","updated":"2022-06-01T07:36:14.000Z","comments":true,"path":"浏览器回流与重绘.html","link":"","permalink":"http://www.skyline.show/浏览器回流与重绘.html","excerpt":"浏览器回流与重绘 浏览器回流与重绘 页面渲染 渲染流程 Layout Paint 回流与重绘触发 回流触发 重绘触发 回流与重绘优化 浏览器优化 代码优化 HTML CSS JS 总结 BMW WARNING Bulletin Material Warrant 页面渲染渲染流程浏览器使用流式布局模型 (Flow Based Layout)，浏览器从拿到代码到渲染页面，主要流程 解析 HTML 节点，创建 DOM 树 解析 CSS 创建 CSSOM 树 合并 CSSOM 与 DOM 为 渲染树（renderTree） 由 DOM 树 Root 节点开始遍历获取可视节点 对于 DOM 的可视节点，获取其对应 CSSOM 树规则 根据两棵树上获取的节点与样式，合成 renderTree Layout，计算出 renderTree 每个节点的大小和位置 Paint， 绘制 renderTree 到页面上 合并的 renderTree 的过程只获取可视节点，将会忽略不可视节点 (meta, script, link 等节点及 display:none 的节点)。图片源文件 Layout布局（排列）阶段，包括初始的布局 Layout 以及后续出现的回流 Reflow。主要（重新）计算节点的位置与几何形状，可以看做给节点画框架。通常情况下，当前节点回流，会同时触发其关联节点（祖先、后代节点以及兄弟节点）回流。多数回流本质都会造成页面重新渲染。 Paint绘制阶段，主要绘制节点的样式，可以看做给节点加个皮肤。包括初始的绘制 Paint 与后续的重绘 Repaint。 回流与重绘触发回流触发","text":"浏览器回流与重绘 浏览器回流与重绘 页面渲染 渲染流程 Layout Paint 回流与重绘触发 回流触发 重绘触发 回流与重绘优化 浏览器优化 代码优化 HTML CSS JS 总结 BMW WARNING Bulletin Material Warrant 页面渲染渲染流程浏览器使用流式布局模型 (Flow Based Layout)，浏览器从拿到代码到渲染页面，主要流程 解析 HTML 节点，创建 DOM 树 解析 CSS 创建 CSSOM 树 合并 CSSOM 与 DOM 为 渲染树（renderTree） 由 DOM 树 Root 节点开始遍历获取可视节点 对于 DOM 的可视节点，获取其对应 CSSOM 树规则 根据两棵树上获取的节点与样式，合成 renderTree Layout，计算出 renderTree 每个节点的大小和位置 Paint， 绘制 renderTree 到页面上 合并的 renderTree 的过程只获取可视节点，将会忽略不可视节点 (meta, script, link 等节点及 display:none 的节点)。图片源文件 Layout布局（排列）阶段，包括初始的布局 Layout 以及后续出现的回流 Reflow。主要（重新）计算节点的位置与几何形状，可以看做给节点画框架。通常情况下，当前节点回流，会同时触发其关联节点（祖先、后代节点以及兄弟节点）回流。多数回流本质都会造成页面重新渲染。 Paint绘制阶段，主要绘制节点的样式，可以看做给节点加个皮肤。包括初始的绘制 Paint 与后续的重绘 Repaint。 回流与重绘触发回流触发 窗口调整 字体变更 增删样式 操作节点 style 操作节点 class 内容变更 用户输入（input 等表单） 增删 dom 节点 节点尺寸变化 伪类激活 节点动画 读写 offsetWidth 等 基本上回流都会触发重绘 重绘触发如下仅讨论只触发重绘的情况 visibility 变化 backgroud 背景颜色变化 color 字体颜色 opacity 调整 不影响节点的位置和形状的改变一般不触发回流 回流与重绘优化浏览器优化 队列机制 在现代浏览器中，由于回流重绘会有较大的性能损耗，多数浏览器会将回流重绘放入队列。当一定时间或操作到指定阀值，浏览器在将队列中的一次性进行处理，减少回流重绘次数。在上文回流触发中，读取 offsetWidth 等的值也会触发回流重绘，其根本原因就是由于这个优化。当代码在读取这些值时，为了获取准确的信息，浏览器不得不将队列清空强制执行回流重绘来得到这些值得最新信息。涉及的相关属性和方法包括： Getting box metricselem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParentelem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeightelem.getClientRects(), elem.getBoundingClientRect()Scroll stuffelem.scrollBy(), elem.scrollTo()elem.scrollIntoView(), elem.scrollIntoViewIfNeeded()elem.scrollWidth, elem.scrollHeightelem.scrollLeft, elem.scrollTop also, setting them 参见 What forces layout / reflow CSS3 硬件加速（GPU）部分 CSS3 属性的设定会触发 GPU 加速，从而不会产生回流重绘。常见的属性有 transform、opacity、filters、will-change 代码优化在实际业务中，页面变化不可避免。回流与重绘优化的主要思路与浏览器优化思路基本一致，减少回流重绘次数。技术层面上，优化从 HTML、 CSS 与 JS 大方向入手。 HTML 精简节点嵌套层级避免出现无意义层级 CSS 将动画应用于文档流外的节点可能的话，将动画添加到 absolute 或 fixed 定位的节点上。 避免表达式属性类似于 calc 的 css 属性设置方法会在其他节点或回流触发时进行重新计算，从而使得对应节点也触发回流。 JS class 变更选用更底层节点选用样式变更的节点来替换或变更类属性而不是在其包裹或祖先节点上。 调整类而不是样式对于多条样式调整的节点，集中更改样式或添加修改类而不是分散修改样式 捆绑 DOM 调整对于 DOM 节点的调整，涉及到多次调整，可以捆绑最后再进行一次插入或替换 DOM 操作，具体方法有 documentFragment通过 documentFragment 新建文档流外的子树，将所有变更应用到子树，最后一次插入或替换到 DOM 中 display:none隐藏节点（display:none）脱离文档流，多次修改该节点，显示节点 集中读写样式代码 缓存引起强制重绘的属性或函数结果对于 clientWith 等引起强制重绘的属性或函数，多次使用时，缓存其值。 调整类而不是样式 // badvar left = 10, top = 10el.style.left = left + 'px'el.style.top = top + 'px'// betterel.className += ' theclassname'// betterel.style.cssText += '; left: ' + left + 'px; top: ' + top + 'px;' 捆绑 DOM 调整 function appendDataToElement(appendToElement, data) &#123; let li for (let i = 0; i &lt; data.length; i++) &#123; li = document.createElement('li') li.textContent = 'text' appendToElement.appendChild(li) &#125;&#125;const ul = document.getElementById('list')//badappendDataToElement(ul, data)// betterul.style.display = 'none'appendDataToElement(ul, data)ul.style.display = 'block'// betterconst fragment = document.createDocumentFragment()appendDataToElement(fragment, data)ul.appendChild(fragment) 集中读写样式代码 // badvar rh = document.getElementById('rect').clientHeightdocument.getElementById('rect').style.height = rh + 10 + 'px'var ch = document.getElementById('circle').clientHeightdocument.getElementById('circle').style.height = ch + 10 + 'px'//bettervar rh = document.getElementById('rect').clientHeightvar ch = document.getElementById('circle').clientHeightdocument.getElementById('rect').style.height = rh + 10 + 'px'document.getElementById('circle').style.height = ch + 10 + 'px' 缓存引起强制重绘的属性或函数结果 // badfunction initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + 'px' &#125;&#125;//betterconst width = box.offsetWidthfunction initP() &#123; for (let i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = width + 'px' &#125;&#125; 总结回流基本都会会引起重绘，重绘不一定回流。一般来说，引起位置变化的都会回流并重绘，不引起位置变化的重绘即可。不管是浏览器底层还是业务代码层面，优化回流和重绘的基本思路都是减少其次数。 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://dev.to/gopal1996/understanding-reflow-and-repaint-in-the-browser-1jbg &gt; https://juejin.cn/post/6844903779700047885 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Refactor&Optimization","slug":"Refactor-Optimization","permalink":"http://www.skyline.show/tags/Refactor-Optimization/"}]},{"title":"Shell中的符号","slug":"Shell中的符号","date":"2022-05-27T07:41:03.000Z","updated":"2022-05-27T07:41:03.000Z","comments":true,"path":"Shell中的符号.html","link":"","permalink":"http://www.skyline.show/Shell中的符号.html","excerpt":"","text":"Shell 中的符号 Shell 中的符号 路径符 重定向符 命令执行符 符号标记 BMW WARNING Bulletin Material Warrant 路径符Shell 中路径相关的符号，如下表所示 符号 使用 说明 ~ cd ~ 用户主页目录 . ls . 当前目录 .. cd .. 上级目录 / cd / 根目录或路径分隔符 重定向符 重定向符表 Shell 中包含输入与输出重定向相关的符号，如下表所示 符号 使用 说明 &gt; command &gt; file 将 command 输出重定向到 file。 &gt; n &gt; file 将文件描述符为 n 的文件重定向到 file。 &gt;&gt; command &gt;&gt; file 将 command 输出以追加的方式重定向到 file。 &gt;&gt; n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 &gt;&amp; n &gt;&amp; m 将输出文件 m 和 n 合并。 &lt; command &lt; file 将 command 输入重定向到 file。 &lt;&amp; n &lt;&amp; m 将输入文件 m 和 n 合并。 > 定义输出重定向command &gt; file 将 command 的输出重定向到 file常见用法 echo Hello &gt; test.txt 上述命令控制台不会有任何输出，Hello 文本将直接覆盖写入 test.txt 2&gt;&amp;1 将标准错误重定向到标准输出将错误的信息重新定向到输出，即”2&gt;1”，按照上面的写法，系统会将错误的信息重定向到一个名字为 1 的文件中，会有歧义，因此加&amp;进行区分，这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出 ​ &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃，会起到&quot;禁止输出&quot;的效果 >&gt; 表示追加到文件末尾，而不是一个&gt;时的覆盖 &lt; 输入重定向 command &lt; file 将输入重定向到 file，即将 file 中的内容作为 command 的参数 命令执行符 | 管道，管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入管道命令只处理前一个命令正确输出，不处理错误输出。管道右边的命令，必须能够接收标准输入的数据流命令，否则，管道后的命令将会抛弃之前的产生的结果管道符可以连接多个命令，多个管道时，控制台输出最后一个命令的内容 ! shell 中!叫做事件提示符，可以方便的引用历史命令，当! 后面跟随的字母不是“空格、换行、回车、=和(”时，可以做命令替换 !n 替换命令历史中第 n 个命令 !-n 替换命令历史中倒数第 n 个命令 !! 即!-1 !string 引用最近的以 string 开始的命令注意一定是开始的位置,这条命令在你运行一个命令之后忘记了这个命令的参数是什么，直接!命令既可 ​​ !?string? 指向包含这个字符串 string 的命令，包含字符即可 &amp; 所有命令同时进行 command1 &amp; command2 &amp; command3 &amp;&amp; 命令依次执行只有前面命令执行成功，后面命令才继续执行 command1 &amp;&amp; command2 ; 命令依次执行前面命令执行不管成功否，后面命令继续执行 command1; command2; command3 符号标记 符号标记表 符号 使用 说明 &lt;&lt; &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 # #sth 作为注释或字符剔除操作符 ? ls ?.js 单字符通配符 * ls *.js 多字符通配符 [] ls [abc].js 限定范围单字符通配符 _ mkdir -p ~/123/456 &amp;&amp; cd $_ _指定上个指令的输入参数，有其他用法不常用 ? ls ?.js# 会列出a.js,b.js，不会列出ab.js * ls *.js# 会列出当前目录下所有.js后缀文件 &lt;&lt; 将开始标记 tag 和结束标记 tag 之间的内容作为输入。标记常指定为 EOF 即（End Of File)，也可指定其他字符。此符号常与 cat 一起使用 cat &lt;&lt;EOF &gt;&gt; b.js 将后续输入的内容追加到 b.js 中，后续输入回车可换行，直到遇到 EOF 后退出文本编辑。 # #常用于注释，其他用法包括为剔除字符中的由头部开始指定字符 skyline='Skyline Liu!';echo How-To $&#123;skyline#Skyline&#125;# echo How-To $&#123;skyline#Liu&#125; 不会剔除Liu字符，不生效 指定的字符非变量开始字符为首字符（本例需要 S 开头），不起任何作用 获取字符或数组的长度 dir='/a/b/c'echo $&#123;#dir&#125;# 6arr=(1 2 3)echo $&#123;#arr&#125;# 3 BMW WARNINGBulletinI am a bucolic migrant worker but I never walk backwards. Material Shell 输入/输出重定向 Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.skyline.show/tags/Shell/"}]},{"title":"ES_Module&CommonJS","slug":"ES_Module&CommonJS","date":"2022-05-27T07:41:02.000Z","updated":"2022-05-27T10:09:13.000Z","comments":true,"path":"ES_Module&CommonJS.html","link":"","permalink":"http://www.skyline.show/ES_Module&CommonJS.html","excerpt":"ES Module vs CommonJS ES Module vs CommonJS 模块系统 ESM VS CJS ESM VS CJS 要点解析 模块输出 模块加载 tree shaking BMW WARNING Bulletin Material Warrant 模块系统早期 JS 出现只是作为脚本语言来进行简单的表单验证与控制简单动画，所有操作与变量都在全局进行，设计之初，不需要考虑模块系统。随着 JS 的发展，其应用越来越复杂，逐渐进入多 JS 脚本通过 script 标签引入的年代。多脚本需要解决脚本引入的顺序，脚本互相引入，脚本循环引入，全局命名污染，命名冲突等诸多问题，同时后期维护特别困难。对于复杂 JS 程序，需要解决的主要问题如下 模块隔离（私有代码权限访问控制） 模块间依赖 代码传递到执行环境 早期解决方案如下： 命名空间 立即执行匿名函数 + 闭包 ES5 时代，模块化的标准与方案有很多，亟需统一，ES6 的模块系统应运而生。由于影响力较大的 NodeJS 大方向参照了 CommonJS 标准，并在其上做了取舍，故本文主要对比 ES6 与 CommonJS 两种方案。其他规范 AMD（Asynchronous Module Definiton）如 requireJS,CMD(Common Module Definition)如 SeaJS 皆支持异步模块定义，在 ES6 模块系统后使用频率降低，如下简单对比。 AMD 典型示例 //依赖前置require(['a', 'b'], function (a, b) &#123; a.someFn() b.someFn()&#125;) CMD 典型示例 define('main', function (require, exports, module) &#123; var a = require('a') //依赖就近 a.someFn() var b = require('b') b.someFn()&#125;) 上述代码可以看到，AMD 规范在于依赖前置、提前执行，CMD 在于依赖就近、延迟执行。为了兼容各种模块系统，UMD(Universal Module Definition) 通用模块规范进行了兼容处理。常用的开源库打包后会生成 xxx.umd.jswebpack 打包后 UMD 兼容模块代码的如下： ;(function webpackUniversalModuleDefinition(root, factory) &#123; if (typeof exports === 'object' &amp;&amp; typeof module === 'object') //Node.js (拓展CommonJS),ES6 module.exports = factory() else if (typeof define === 'function' &amp;&amp; define.amd) //amd cmd define([], factory) else if (typeof exports === 'object') // CommonJS标准方案 exports['skyline-ui'] = factory() else root['skyline-ui'] = factory() // 未引入规范模块，全局申明&#125;)(typeof self !== 'undefined' ? self : this, function () &#123; // ...some code&#125;) ES6 兼容 Node.js 模块方案 ESM VS CJS 标准 输出 加载时机 加载方式 ES6 模块 值引用（只读） 编译 import 异步 CommonJS 值浅拷贝 运行 require 同步 ESM VS CJS 要点解析模块输出 ES6 ES6 模块输出的是对值的引用，即便是简单类型，模块内值的改变也会引起之后值得改变JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值（对象存在于导出模块的文件）。ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 例 1 // lib.jsexport let counter = 3export function incCounter() &#123; counter++&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib'console.log(counter) // 3incCounter()console.log(counter) // 4 例 2 // mod.jsfunction C() &#123; this.sum = 0 this.add = function () &#123; this.sum += 1 &#125; this.show = function () &#123; console.log(this.sum) &#125;&#125;export let c = new C()// x.jsimport &#123; c &#125; from './mod'c.add()// y.jsimport &#123; c &#125; from './mod'c.show()// main.jsimport './x'import './y'//输出1 引用只读 // lib.jsexport let obj = &#123;&#125;// main.jsimport &#123; obj &#125; from './lib'obj.prop = 123 // OKobj = &#123;&#125; // TypeError main.js 从 lib.js 输入变量 obj，可以对 obj 添加属性，但是重新赋值就会报错。因为变量 obj 指向的地址是只读的，不能重新赋值，这就好比 main.js 创造了一个名为 obj 的 const 变量 CommonJS 对应 CommonJS 规范中，导出的是一个对象，引入时采用的是对象的浅拷贝（在导出和导入时各有一个对象生成）。该对象的属性如果是简单类型，模块内部值得改变则不会对之后引用产生影响 // lib.jsvar counter = 3function incCounter() &#123; counter++&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;// main.jsvar mod = require('./lib')console.log(mod.counter) // 3mod.incCounter() // 引起lib.js中counter 值改变为4console.log(mod.counter) // 3 模块加载 加载时机 CommonJS 导出的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 加载方式 commonJS 规范用同步的方式加载模块.例如实现该规范的 nodeJS，因为在服务端，模块文件都存在本地磁盘，可以进行快速度读取，等待模块加载不会耗费过多的时间，所以这样做不会有问题。但是在浏览器端，限于网络等各种原因，需要使用异步加载获取更好的体验。 tree shaking由于 ES6 的模块暴露的是引用而不是生成一个对象.从加载时机来看，ES6 的 import 命令会被 JavaScript 引擎静态分析编译时就分析是否被引用，而不是在代码运行时加载。编译时加载使得对 ES6 静态分析并进行无用代码删除成为可能。这就是为什么 ES6 出来之后，tree shaking 才成为可能，这也是为什么要使用 tree shaking，必须使用 ES6 模块。 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material","text":"ES Module vs CommonJS ES Module vs CommonJS 模块系统 ESM VS CJS ESM VS CJS 要点解析 模块输出 模块加载 tree shaking BMW WARNING Bulletin Material Warrant 模块系统早期 JS 出现只是作为脚本语言来进行简单的表单验证与控制简单动画，所有操作与变量都在全局进行，设计之初，不需要考虑模块系统。随着 JS 的发展，其应用越来越复杂，逐渐进入多 JS 脚本通过 script 标签引入的年代。多脚本需要解决脚本引入的顺序，脚本互相引入，脚本循环引入，全局命名污染，命名冲突等诸多问题，同时后期维护特别困难。对于复杂 JS 程序，需要解决的主要问题如下 模块隔离（私有代码权限访问控制） 模块间依赖 代码传递到执行环境 早期解决方案如下： 命名空间 立即执行匿名函数 + 闭包 ES5 时代，模块化的标准与方案有很多，亟需统一，ES6 的模块系统应运而生。由于影响力较大的 NodeJS 大方向参照了 CommonJS 标准，并在其上做了取舍，故本文主要对比 ES6 与 CommonJS 两种方案。其他规范 AMD（Asynchronous Module Definiton）如 requireJS,CMD(Common Module Definition)如 SeaJS 皆支持异步模块定义，在 ES6 模块系统后使用频率降低，如下简单对比。 AMD 典型示例 //依赖前置require(['a', 'b'], function (a, b) &#123; a.someFn() b.someFn()&#125;) CMD 典型示例 define('main', function (require, exports, module) &#123; var a = require('a') //依赖就近 a.someFn() var b = require('b') b.someFn()&#125;) 上述代码可以看到，AMD 规范在于依赖前置、提前执行，CMD 在于依赖就近、延迟执行。为了兼容各种模块系统，UMD(Universal Module Definition) 通用模块规范进行了兼容处理。常用的开源库打包后会生成 xxx.umd.jswebpack 打包后 UMD 兼容模块代码的如下： ;(function webpackUniversalModuleDefinition(root, factory) &#123; if (typeof exports === 'object' &amp;&amp; typeof module === 'object') //Node.js (拓展CommonJS),ES6 module.exports = factory() else if (typeof define === 'function' &amp;&amp; define.amd) //amd cmd define([], factory) else if (typeof exports === 'object') // CommonJS标准方案 exports['skyline-ui'] = factory() else root['skyline-ui'] = factory() // 未引入规范模块，全局申明&#125;)(typeof self !== 'undefined' ? self : this, function () &#123; // ...some code&#125;) ES6 兼容 Node.js 模块方案 ESM VS CJS 标准 输出 加载时机 加载方式 ES6 模块 值引用（只读） 编译 import 异步 CommonJS 值浅拷贝 运行 require 同步 ESM VS CJS 要点解析模块输出 ES6 ES6 模块输出的是对值的引用，即便是简单类型，模块内值的改变也会引起之后值得改变JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值（对象存在于导出模块的文件）。ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 例 1 // lib.jsexport let counter = 3export function incCounter() &#123; counter++&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib'console.log(counter) // 3incCounter()console.log(counter) // 4 例 2 // mod.jsfunction C() &#123; this.sum = 0 this.add = function () &#123; this.sum += 1 &#125; this.show = function () &#123; console.log(this.sum) &#125;&#125;export let c = new C()// x.jsimport &#123; c &#125; from './mod'c.add()// y.jsimport &#123; c &#125; from './mod'c.show()// main.jsimport './x'import './y'//输出1 引用只读 // lib.jsexport let obj = &#123;&#125;// main.jsimport &#123; obj &#125; from './lib'obj.prop = 123 // OKobj = &#123;&#125; // TypeError main.js 从 lib.js 输入变量 obj，可以对 obj 添加属性，但是重新赋值就会报错。因为变量 obj 指向的地址是只读的，不能重新赋值，这就好比 main.js 创造了一个名为 obj 的 const 变量 CommonJS 对应 CommonJS 规范中，导出的是一个对象，引入时采用的是对象的浅拷贝（在导出和导入时各有一个对象生成）。该对象的属性如果是简单类型，模块内部值得改变则不会对之后引用产生影响 // lib.jsvar counter = 3function incCounter() &#123; counter++&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;// main.jsvar mod = require('./lib')console.log(mod.counter) // 3mod.incCounter() // 引起lib.js中counter 值改变为4console.log(mod.counter) // 3 模块加载 加载时机 CommonJS 导出的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 加载方式 commonJS 规范用同步的方式加载模块.例如实现该规范的 nodeJS，因为在服务端，模块文件都存在本地磁盘，可以进行快速度读取，等待模块加载不会耗费过多的时间，所以这样做不会有问题。但是在浏览器端，限于网络等各种原因，需要使用异步加载获取更好的体验。 tree shaking由于 ES6 的模块暴露的是引用而不是生成一个对象.从加载时机来看，ES6 的 import 命令会被 JavaScript 引擎静态分析编译时就分析是否被引用，而不是在代码运行时加载。编译时加载使得对 ES6 静态分析并进行无用代码删除成为可能。这就是为什么 ES6 出来之后，tree shaking 才成为可能，这也是为什么要使用 tree shaking，必须使用 ES6 模块。 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://es6.ruanyifeng.com/#docs/module-loader Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"ES","slug":"ES","permalink":"http://www.skyline.show/tags/ES/"}]},{"title":"排序算法","slug":"排序算法","date":"2022-05-27T07:41:02.000Z","updated":"2022-06-01T07:20:31.000Z","comments":true,"path":"排序算法.html","link":"","permalink":"http://www.skyline.show/排序算法.html","excerpt":"排序算法 排序算法 选择排序 选排的思想 时间复杂度 冒泡排序 基本思路 时间复杂度 交换判定优化 插入排序 插排的思想 时间复杂度分析 哨兵优化 折半优化 归并排序（Merge Sort） 归并排序思路 合并 时间复杂度分析 快速排序 快排思路 选值优化 多路快排 希尔排序（缩小增量排序） 关键思路 时间复杂度 计数排序 关键思路 时间复杂度分析 堆排序 完全二叉树 堆 构造堆 排序 BMW WARNING Bulletin Material Warrant 选择排序选排的思想找出每一轮的最值并放在该轮次位置处核心思想是每轮选最值外层循环确定轮次，内层循环确定最值。 def selectionSort(nums): for i in range(len(nums)): pos = i for j in range(i + 1, len(nums)): if nums[pos] &gt; nums[j]: pos = j nums[i], nums[pos] = nums[pos], nums[i] return nums 时间复杂度选择排序的比较次数 = (n - 1) + (n - 2) + … + 2 + 1 = n * (n - 1) / 2，因此时间复杂度为：O(n²)。 冒泡排序基本思路每一轮通过不断对比交换位置来将该轮最大（小）值上浮（下沉）到对应轮位置核心思想是每轮换位置外层循环确定轮次，内层循环交换位置。 def bubbleSort(nums): for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] return nums 每一轮都进行了多次交换，故相较于选择排序耗时 时间复杂度","text":"排序算法 排序算法 选择排序 选排的思想 时间复杂度 冒泡排序 基本思路 时间复杂度 交换判定优化 插入排序 插排的思想 时间复杂度分析 哨兵优化 折半优化 归并排序（Merge Sort） 归并排序思路 合并 时间复杂度分析 快速排序 快排思路 选值优化 多路快排 希尔排序（缩小增量排序） 关键思路 时间复杂度 计数排序 关键思路 时间复杂度分析 堆排序 完全二叉树 堆 构造堆 排序 BMW WARNING Bulletin Material Warrant 选择排序选排的思想找出每一轮的最值并放在该轮次位置处核心思想是每轮选最值外层循环确定轮次，内层循环确定最值。 def selectionSort(nums): for i in range(len(nums)): pos = i for j in range(i + 1, len(nums)): if nums[pos] &gt; nums[j]: pos = j nums[i], nums[pos] = nums[pos], nums[i] return nums 时间复杂度选择排序的比较次数 = (n - 1) + (n - 2) + … + 2 + 1 = n * (n - 1) / 2，因此时间复杂度为：O(n²)。 冒泡排序基本思路每一轮通过不断对比交换位置来将该轮最大（小）值上浮（下沉）到对应轮位置核心思想是每轮换位置外层循环确定轮次，内层循环交换位置。 def bubbleSort(nums): for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] return nums 每一轮都进行了多次交换，故相较于选择排序耗时 时间复杂度 冒泡排序的比较次数 = (n - 1) + (n - 2) + … + 2 + 1，即：n * (n - 1) / 2，所以冒泡排序的时间复杂度为：O(n²)冒泡排序最优情况的时间复杂度是：O(n) 要达到这个复杂度，上述代码需要进一步优化 交换判定优化对于已经有序的数列，进行了冗余的循环操作，通过在每轮进行交换标记来进行优化 # 冒泡交换判定优化def optimizeBubbleSort(nums): for i in range(len(nums)): swap = False for j in range(i + 1, len(nums)): if nums[i] &gt; nums[j]: nums[i], nums[j] = nums[j], nums[i] swap = True if not swap: return nums return nums 插入排序插排的思想将 list 分为两部分，前部分作为已排序部分并向其中插入值，注意插入值之后值的移动外层循环确定插入值，内层循环确定插入位置 # 插入排序# 外层循环确定插入值，内层循环确定插入位置# 将list分为两部分，前部分作为已排序部分并向其中插入值，注意值的移动def insertionSort(nums): for i in range(1, len(nums)): if nums[i] &lt; nums[i - 1]: j = i - 1 aim = nums[i] while aim &lt; nums[j] and j &gt; -1: nums[j + 1] = nums[j] j -= 1 nums[j + 1] = aim return nums 时间复杂度分析最坏的情况下，即整个数组是倒序的，比较次数 = 1 + 2 + 3 + … + (n - 2) + (n - 1) = n * (n - 1) / 2，此时的时间复杂度为：O(n²)。在最好的情况下，即整个数组是正序的，比较次数 = n - 1，此时的时间复杂度为：O(n) 哨兵优化在插入排序循环判定中，aim &lt; nums[j] and j &gt; -1，即既要保证不越界又要判断数据是否符合条件，用哨兵代替上述两个条件，每次循环只需一次比较，可以减少一半的比较次数。 哨兵的作用 暂时存放待插入的元素 监视数组下标越界 def sentryInsertionSort(nums): nums.append(nums[0]) for i in range(1, len(nums)): if nums[i] &lt; nums[i - 1]: j = i - 1 nums[0] = nums[i] while nums[0] &lt; nums[j]: nums[j + 1] = nums[j] j -= 1 nums[j + 1] = nums[0] return nums[1:] 折半优化前半部分由于已经排序，故可通过二分查找找出插入位置 # 插入排序折半优化def binaryInsertionSort(nums): for i in range(1, len(nums)): if nums[i] &lt; nums[i - 1]: aim = nums[i] s,m,e = 0, 0, i - 1 while s &lt; e: m = s + e &gt;&gt; 1 if aim &gt; nums[m]: s = m + 1 else: e = m j = i while j &gt; e: nums[j] = nums[j - 1] j -= 1 nums[e] = aim return nums 归并排序（Merge Sort）归并排序思路归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个元素，接着将小数组归并成有序的较大的数组，最后变成一个排序完成的大数组。归并排序中，归是指递归，并即合并递归进行拆分，合并进行排序（两个有序数组合为新的有序数组）归并排序与快排最大的不同在于重合并不重划分，归并需要合并两个有序数列，在划分时，无脑取中位即可。 # 归并排序# 归并排序的主要思想是分治# 将n个元素从中间切开，分成两部分。（左右可能长度差1）# 递归分解，直到所有部分的元素个数都为1# 从最底层开始逐步向上合并两个排好序的数列# 并# 合并两个有序数组为新的有序数组def mergeSorted(nums1, nums2): nums = [] i, j = 0, 0 l = len(nums2) while i &lt; len(nums1): if nums1[i] &lt;= nums2[j]: #判定条件为 nums1[i] &lt; nums2[j]时不稳定 nums.append(nums1[i]) i += 1 else: nums.append(nums2[j]) j += 1 if (j == l): break return nums + nums1[i:] + nums2[j:]# 归def recursionMergeSort(nums): l = len(nums) if l &lt; 2: return nums else: # 整除 m = l // 2 return mergeSorted(recursionMergeSort(nums[:m]), recursionMergeSort(nums[m:])) mergeSorted 方法里面的 nums1[i] &lt;= nums2[j] ，保证了值相同的元素，在合并前后的先后顺序不变。归并排序是一种稳定的排序方法 合并如何将两个有序数组合并成一个新的有序数组?轮番比较两个数列的最低位，直到一方全部比较完毕 def mergeSorted(nums1, nums2): nums = [] i, j = 0, 0 l = len(nums2) while i &lt; len(nums1): if nums1[i] &lt; nums2[j]: nums.append(nums1[i]) i += 1 else: nums.append(nums2[j]) j += 1 if (j == l): break return nums + nums1[i:] + nums2[j:] 由于合并函数需要另开内存空间存储新的数组，归并排序不是原地排序算法。 时间复杂度分析递归中的时间复杂度为 logn，合并数组最多循环 n 次归并排序的时间复杂度为 O(nlogn) 快速排序快排思路采用分治的思想，选取一个值为基准值，假设其放在正确顺序位置 pos，将比其小的放在其前面，比其大的放在其后面，从 pos 处将数列砍成两半，对子序列递归执行前述操作递归进行拆分，双指针进行排序快排重划分，不需要合并，在划分时，可以随意选择一个值，但选值得大小将影响排序的效率通过双指针找到选择值在数列中的正确位置 取中位 取中位，在将中位交换到对应位置时，对比取边界，需要做比较多的处理，容易出错 def quickSort(nums, start, end): if end - start &lt; 1: return # m可取数列中任意数，此处取中位 s, m, e = start, start + end &gt;&gt; 1, end # 通过双指针找到nums[m]正确位置 while s &lt;= e: # 取值判定加等号，防止nums[m]值被交换 while s &lt;= e and nums[s] &lt;= nums[m]: s += 1 # 取值判定加等号，防止nums[m]值被交换，针对中位取值 while s &lt;= e and nums[e] &gt;= nums[m]: e -= 1 if s &lt; e: nums[s], nums[e] = nums[e], nums[s] # 通过交换将nums[m]放在正确的位置 if m &gt; s: nums[s], nums[m] = nums[m], nums[s] # 移动位置，缩减nums[m]位置，防止某些情况死循环（如所有值一致） s += 1 else: nums[e], nums[m] = nums[m], nums[e] e -= 1 if start &lt; e: quickSort(nums, start, e) if s &lt; end: quickSort(nums, s, end) 取边界 def quickSort(nums, start, end): if end - start &lt; 1: return s, m, e = start + 1, start, end # 选取第一个值为基准值 while s &lt;= e: while s &lt;= e and nums[s] &lt; nums[m]: # 找出左边以一个比基准大的数的位置 s += 1 while s &lt;= e and nums[e] &gt;= nums[m]: # 找出右边以一个比基准小的数的位置 e -= 1 if s &lt; e: # 交换双方位置，并进入中间尚未比较位置继续对比交换 nums[s], nums[e] = nums[e], nums[s] nums[e], nums[m] = nums[m], nums[e] if start &lt; e: quickSort(nums, start, e - 1) if s &lt; end: quickSort(nums, s, end) 选值优化 随机选值基准值随机地选取，而不是每次都取第一个数。这样就不会受正序或逆序的数组的干扰 三数取中前中后选三个值选取三数的中位数，以降低取到最大或最小值的概率。三数取中时，比较的同时应将三个元素按中间，小，大的顺序重新排好位置 多路快排在遍历数列时选用指针的数量 单路基准值 base 左边的都比 base 小，而 base 右边的都大于等于 base。等于 base 的这些会聚集到右侧(或者稍微改改大小关系就会聚集到左侧)。总之就会聚集到一边。这样在数组中重复数字很多的时候，就又会导致两边子递归规模差距悬殊的情况 双路上述代码采用的就是双路 三路对于大于小于等于分别选用一个指针在当前值小于目标值时，s 与 c 齐头并进，直到等于出现时，s 停留在第一个相等的位置，c 开始往后移动，通过 c 做中介来交换 s 与 e 位置的值 def quickSort(nums, start, end): if end - start &lt; 1: return s, c, m, e = start + 1, start + 1, start, end while c &lt;= e: if nums[c] == nums[m]: c += 1 elif nums[c] &lt; nums[m]: nums[s], nums[c] = nums[c], nums[s] s += 1 c += 1 else: nums[e], nums[c] = nums[c], nums[e] e -= 1 nums[e], nums[m] = nums[m], nums[e] if start &lt; e: quickSort(nums, start, e - 1) if s &lt; end: quickSort(nums, s, end) 时间复杂度分析待排序为正序或逆序，取值也为最值，这样每次分割后的子序列一个之比上一次序列少一个元素,最终 O(n²)平均为 O(nlogn) 希尔排序（缩小增量排序）关键思路希尔排序又叫缩小增量排序希尔排序是插入排序的优化版本，在插入排序中，将数列分为有序与无序部分，若无序部分的头部每次都需要插入到有序部分的头部，那么最终的总复杂度会到 n²希尔排序将数列每一轮分为多个子数列，对每个子数列进行插入排序，直至整体基本有序时（增量为 1 前），再对全体记录进行插入排序（增量为 1）起来就容易了(由于最后一次基本有序无须多次移位或交换) def shellSort(nums): span = len(nums) while span &gt; 1: span //= 2 # span取数跨度，先将整个待排序的记录序列分割成为若干子序列，每轮缩小取数跨度，子数列长度 insertionSort(nums, span) return numsdef insertionSort(nums, span): for pos in range(span, len(nums), 1): # 由span位置开始，到len(nums) - 1位置结束， 循环步长为1 if nums[pos] &lt; nums[pos - span]: pre = pos - span aim = nums[pos] while aim &lt; nums[pre] and pre &gt; -1: nums[pos] = nums[pre] # 数后移 pre -= span nums[pre + span] = aim 时间复杂度希尔排序的时间复杂度最佳情况：O(n logn)。 最差情况：O(n (log(n))²)。 平均情况：取决于间隙序列 计数排序关键思路对于一个自然数数组 A，选取数组中的最大值 m，然后初始化一个长度为 m + 1 的备用数组 B。对于数组 BB 的索引对应数组 A 的值B 的值对应数组 A 中相应值的个数C 的值记录 A 顺序后前面出现值的个数例如 A = [3, 3, 9, 2, 2, 2, 0]# B = [1, 0, 3, 2, 0, 0, 0, 0, 0, 1]# C = [1, 1, 4, 6, 6, 6, 6, 6, 6, 7]# 以3为例# B: 3有两个# C: 如果有3，最后一个3位于第6位，即索引为5def countingSort(nums): counts = [0] * (max(nums) + 1) for i in nums: counts[i] += 1 accumulation = 0 for index, value in enumerate(counts): accumulation += value counts[index] = accumulation rets = [0] * len(nums) for v in nums: rets[counts[v] - 1] = v counts[v] -= 1 # 下一个相同值索引减1 return rets 时间复杂度分析计数排序利用了空间换时间，对于不同的实现（比如最大值判定循环等），其内部始终是遍历两个定长的数组。O(max)+O(len)+… = O(max+len)即其时间复杂度为 O(n + k) 堆排序完全二叉树二叉树是指最多只存在两个子节点的树形数据结构。完全二叉树是指除了最后一层的叶子节点，每一层节点都存在，且最后一层的叶子节点由左起依次排列不能留空。 数组可以表示一个典型的完全二叉树。i（索引） 为 0 的节点为根节点。所有左子节点的索引为 2i+1，右子节点的索引为 2i+2。同时，可以通过(i-1)/2 获取其父节点的值 堆堆是一颗完全二叉树，且对于所有节点，都要满足父节点的值大于等于（或小于等于）子节点的值。父节点大于等于子节点时，称为大顶堆父节点小于等于子节点时，称为小顶堆 构造堆当跟节点的左子树和右子树已经为堆时，加入父节点构造堆。 # 当跟节点的左子树和右子树已经为堆时，加入父节点构造堆def heapify(nums, pos): length = len(nums) mark = pos left = 2 * pos + 1 right = 2 * pos + 2 if(left &lt; length and nums[pos] &lt; nums[left]): pos = left if(right &lt; length and nums[pos] &lt; nums[right]): pos = right if(mark != pos): nums[mark], nums[pos] = nums[pos], nums[mark] heapify(nums, pos) # 交换位置后，子树需要重新构造堆 return nums 对于任意完全二叉树（数组）构造堆 # 对于任意完全二叉树（数组）构造堆def heapifyArr(nums): start = (len(nums) - 1) // 2 # 大于此索引的其他节点是叶子节点 while (start &gt; -1): heapify(nums, start) #所有非叶子节点，由下到上，从右到左依次遍历构造堆 start -= 1 return nums 排序对于任意数组，当调用上述方法构造堆后，可得其最值位于根节点（索引为 0）利用该特性，堆排序思路如下 将数组构造成堆 交换堆的首节点与尾节点，移除此时处于最后的根节点（或记录偏移位置）。 对于剩下的完全二叉树，根节点的左右子树仍为堆，采用 heapify 来将剩下的完全二叉树构造成堆。 重复 2、3 步，直到移除完所有节点 # 堆排序def heapSort(nums): pos = len(nums) - 1 heapifyArr(nums) ret = [] arr = nums while pos &gt; -1: arr = heapify(arr[:pos + 1], 0) ret.append(arr[0]) arr[0], arr[pos] = arr[pos], arr[0] pos -= 1 return ret 上述排序引入了多余的数组来最后存储与中间存储相关结果，通过对偏移量的记录，所有操作可以源数组进行（原地排序）进一步优化 # 当跟节点的左子树和右子树已经为堆时，加入父节点构造堆def heapify(nums, offset, pos): # length = len(nums) mark = pos left = 2 * pos + 1 right = 2 * pos + 2 if(left &lt; offset and nums[pos] &lt; nums[left]): pos = left if(right &lt; offset and nums[pos] &lt; nums[right]): pos = right if(mark != pos): nums[mark], nums[pos] = nums[pos], nums[mark] heapify(nums, offset, pos) # 交换位置后，子树需要重新构造堆 # return nums# 对于任意完全二叉树（数组）构造堆def heapifyArr(nums): start = (len(nums) - 1) // 2 # 大于此索引的其他节点是叶子节点 while (start &gt; -1): heapify(nums, len(nums), start) # 所有非叶子节点，由下到上，从右到左依次遍历构造堆 start -= 1 # return nums# 堆排序def heapSort(nums): offset = len(nums) - 1 heapifyArr(nums) # ret = [] # arr = nums while offset &gt; -1: heapify(nums, offset, 0) nums[0], nums[offset] = nums[offset], nums[0] offset -= 1 return numsnums = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]# nums = [1, 12, 9, 5, 6, 10]heapSort(nums)print(nums) BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://zhuanlan.zhihu.com/p/36075856 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"DataStructure&Algorithm","slug":"DataStructure-Algorithm","permalink":"http://www.skyline.show/tags/DataStructure-Algorithm/"}]},{"title":"Webpack中DllPlugin使用","slug":"Webpack中DllPlugin使用","date":"2022-05-27T07:41:02.000Z","updated":"2022-06-02T02:55:08.000Z","comments":true,"path":"Webpack中DllPlugin使用.html","link":"","permalink":"http://www.skyline.show/Webpack中DllPlugin使用.html","excerpt":"Webpack 中 DllPlugin 使用 Webpack 中 DllPlugin 使用 DllPlugin 概述 实质 DllPlugin 配置 引入 dll 库 手动引入 dll 文件（不推荐） 手动引入注意 自动引入(推荐) 自动引入常见问题 成果分析 优化前 优化后： BMW WARNING Bulletin Material Warrant DllPlugin 概述实质DLL即动态链接库(Dynamic Link Library)。是指包含可由多个程序同时使用的代码库。在前端领域里可简单看做缓存，其实质是把项目中引入的较大模块先行分离出来，打包为DLL文件并存到硬盘里。再次打包时动态链接清单（manifest文件）中的文件就无需再次打包，从而优化打包速度，减少打包时间，其同时兼具分离模块的作用。 webpack v2 时已存在，在 v4+已不推荐使用该配置，新其版本迭代带来的性能提升足以忽略 DllPlugin 所带来的打包优化效益 DllPlugin 配置webpack.dll.config.js 配置 新建单独的配置文件 webpack.dll.config.js var path = require('path')var webpack = require('webpack')module.exports = &#123; // 你想要打包的模块的数组 entry: &#123; vendor: [ 'vue/dist/vue.esm.js', 'vuex', 'axios', 'vue-router', 'element-ui', ], &#125;, output: &#123; path: path.join(__dirname, '../static/js'), // 打包后文件输出的位置 filename: '[name].dll.js', library: '[name]_library', // vendor.dll.js中暴露出的全局变量名。 // 主要是给DllPlugin中的name使用， // 故这里需要和webpack.DllPlugin中的`name: '[name]_library',`保持一致。 &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, '../', '[name]-manifest.json'), name: '[name]_library', context: __dirname, &#125;), // 压缩打包的文件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, &#125;, &#125;), ],&#125; 配置说明 path：manifest.json 生成的文件夹及名字，该项目让它生成在了根目录下。name：和 output. library 保持一致即可。context：选填，manifest 文件中请求的上下文，默认为该 webpack 文件上下文。 在 package.json 中添加执行脚本 \"dll\": \"webpack --config build/webpack.dll.conf.js\", 执行 yarn dll生成 dll 文件和 manifest.json 文件manifest.json 文件包含了引用模块的 id 映射，为 DllReferencePlugin 引用做准备 引入 dll 库手动引入 dll 文件（不推荐）在根目录的 index.html 里引入所生成的 dll 库 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\" /&gt; &lt;title&gt;xx市城市综合管理基础&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"/static/js/vendor.dll.js\"&gt;&lt;/script&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 手动引入注意","text":"Webpack 中 DllPlugin 使用 Webpack 中 DllPlugin 使用 DllPlugin 概述 实质 DllPlugin 配置 引入 dll 库 手动引入 dll 文件（不推荐） 手动引入注意 自动引入(推荐) 自动引入常见问题 成果分析 优化前 优化后： BMW WARNING Bulletin Material Warrant DllPlugin 概述实质DLL即动态链接库(Dynamic Link Library)。是指包含可由多个程序同时使用的代码库。在前端领域里可简单看做缓存，其实质是把项目中引入的较大模块先行分离出来，打包为DLL文件并存到硬盘里。再次打包时动态链接清单（manifest文件）中的文件就无需再次打包，从而优化打包速度，减少打包时间，其同时兼具分离模块的作用。 webpack v2 时已存在，在 v4+已不推荐使用该配置，新其版本迭代带来的性能提升足以忽略 DllPlugin 所带来的打包优化效益 DllPlugin 配置webpack.dll.config.js 配置 新建单独的配置文件 webpack.dll.config.js var path = require('path')var webpack = require('webpack')module.exports = &#123; // 你想要打包的模块的数组 entry: &#123; vendor: [ 'vue/dist/vue.esm.js', 'vuex', 'axios', 'vue-router', 'element-ui', ], &#125;, output: &#123; path: path.join(__dirname, '../static/js'), // 打包后文件输出的位置 filename: '[name].dll.js', library: '[name]_library', // vendor.dll.js中暴露出的全局变量名。 // 主要是给DllPlugin中的name使用， // 故这里需要和webpack.DllPlugin中的`name: '[name]_library',`保持一致。 &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, '../', '[name]-manifest.json'), name: '[name]_library', context: __dirname, &#125;), // 压缩打包的文件 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, &#125;, &#125;), ],&#125; 配置说明 path：manifest.json 生成的文件夹及名字，该项目让它生成在了根目录下。name：和 output. library 保持一致即可。context：选填，manifest 文件中请求的上下文，默认为该 webpack 文件上下文。 在 package.json 中添加执行脚本 \"dll\": \"webpack --config build/webpack.dll.conf.js\", 执行 yarn dll生成 dll 文件和 manifest.json 文件manifest.json 文件包含了引用模块的 id 映射，为 DllReferencePlugin 引用做准备 引入 dll 库手动引入 dll 文件（不推荐）在根目录的 index.html 里引入所生成的 dll 库 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\" /&gt; &lt;title&gt;xx市城市综合管理基础&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"/static/js/vendor.dll.js\"&gt;&lt;/script&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 手动引入注意 如果前后端约定了项目访问 url 前缀，如’skyline’,则前端可以在 output.publicPath 指定值为’/skyline/‘同时手动引入是需为如下配置。 同时在测试环境 webpack.dev.conf.js 中，需要设定代理 proxyTable: &#123; '/skyline': &#123; target: 'http://localhost:8080/', // 本地地址，开发环境一旦端口变更就要更改，非常麻烦 pathRewrite: &#123; '^/skyline/static': '/static' &#125;,&#125; 自动引入(推荐)html-webpack-tags-plugin 插件 html-webpack-tags-plugin 插件默认会把 publicPath 加入文件地址前缀，当 output.publicPath = ‘skyline’ 时，插入代码为 html-webpack-tags-plugin 配置代码 new HtmlWebpackTagsPlugin(&#123; tags: ['static/js/vendor.dll.js'], append: false // 默认true&#125;), 自动引入常见问题append 使用默认 true 将会有以下错误这里是由于插入的代码位置不对设定为 false 之后，插入位置如下 Uncaught ReferenceError: \\_dll_vendor is not defined 造成这个错误主要有 4 个可能的原因： context 上下文不一致(DllPlugin context 与 DllReferencePlugin context 一致)library 和 name 不一致（output.library 需要和 DllPlugin option.name 一致）生成的 dll 文件没加入到 html 文件中生成的 dll 文件没加入到 html 文件中位置不对，如本文所示 DllReferencePlugin 配置 plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, //这个上下文对应DllPlugin manifest: require('./vendor-manifest.json'), &#125;),] 成果分析优化前 优化后： BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 DllPlugin &gt; webpack 进阶——DllPlugin 优化打包性能（基于 vue-cli） Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ [CC BY - NC - SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh","categories":[{"name":"Major","slug":"Major","permalink":"http://www.skyline.show/categories/Major/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://www.skyline.show/tags/JS/"},{"name":"Packages","slug":"Packages","permalink":"http://www.skyline.show/tags/Packages/"},{"name":"Webpack","slug":"Webpack","permalink":"http://www.skyline.show/tags/Webpack/"}]},{"title":"","slug":"HTTPS加密方式","date":"2022-04-22T10:00:30.000Z","updated":"2022-06-08T03:09:13.000Z","comments":true,"path":"HTTPS加密方式.html","link":"","permalink":"http://www.skyline.show/HTTPS加密方式.html","excerpt":"--- title: HTTPS加密方式 updated: 2022-02-03 14:21:52 --- &gt;作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比","text":"--- title: HTTPS加密方式 updated: 2022-02-03 14:21:52 --- &gt;作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比 端口：HTTPS 443，HTTP 80 传输： HTTPS密文， HTTP 明文 证书：HTTPS需要，HTTP 不需要 （图源：https://juejin.im/post/6844903604868874247） 加密方式常见的加密方式中，是选择对称加密，非对称加密还是算不上加密的摘要算法？以下进行加密方式选择的讨论 摘要算法摘要算法无法逆向获取原文内容，没有可行性。 对称加密（共享密钥加密算法）对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密 可行性存在密钥传输问题如何保证密钥传输给众多客户端过程中不被泄露？网络存在通信实体庞大，不是单单的一对一的问题，往往一台服务器对应众多的访问客户，如何把密钥传递给庞大的客户群并在传输过程不被泄露，是关键问题。 非对称加密公钥加密，私钥解密 可行性单组非对称加密密钥只能保证单边通信可靠性使用一组非对称加密密钥，存在如下问题。客户端公钥加密，服务器私钥解密，客户端到服务器的通信是可靠的，但是反之，服务器向客户端传递信息，如果用私钥加密，则公开的公钥都能解密 两组公钥私钥客户端服务器分别保留一把公钥，一把私钥，公钥加密，私钥解密可行性差的主要原因是非对称加密非常耗时 对称 + 非对称本质采用用非对称算法传递对称密钥，采用对称加密算法加密传输数据 过程 客户端发起请求 服务器明文发送公钥A，客户端获取公钥A 客户端生成密钥X，用公钥A加密密钥X得到密文XXXA后传给服务器 服务器私钥A’解密密文XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 中间人攻击概述非对称加密算法在传递公钥过程中存在公钥被中间人截取篡改的风险。只要是采用了非对称加密算法，都会存在中间人攻击的风险。 非对称加密中间人攻击 中间人获取服务器的公钥A拦截 中间人把自己生产的公钥B返给客户端 客户端用公钥B加密明文”QQ:123 密码：123”成密文XXXB 中间人用私钥B’解密获取明文 中间人用公钥A加密明文为XXXA并传给服务器 上述过程中，客户端与服务器正常通信，难以发觉信息已经被泄露。 信息抵赖由于存在中间人的已知风险，如果不解决非对称中的这个漏洞，即便不存在中间人攻击，对于错误的消息，服务器可以不承认。（中间过程传递的是密文，为了便于理解直接明文展示） 非对称与对称方案中的中间人攻击上述非对称与对称方案并没有解决针对非对称加密算法的此项漏洞，中间人可以在上述非对称与对称方案中进行攻击。具体过程如下 客户端发起请求 服务器发送公钥A，被拦截，中间人获取公钥A 中间人生成公钥B，私钥B’ 中间人发送公钥B，客户端获取公钥B 客户端生成密钥X，用公钥B加密密钥X得到密文XXXB 客户端发送密文XXXB，中间人截取密文 中间人用私钥B’解密获取密钥X 中间人用公钥A加密密钥X得到XXXA，并发送给服务器 服务器私钥A’解密XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 最终中间人成功的获取了客户端与服务器此次通信的密钥X，此次通行中所用信息都可被中间人解密获取 根本原因中间人成功攻击的根本原因是浏览器无法确认获取的公钥真实性 数字证书与签名数字证书为了保证公钥的正确真实性，需要权威CA机构(证书授权中心/Certificate Authority )来颁发数字证书，数字证书里有证书持有者（持有网站）、持有者公钥等信息。在传输过程中，服务器传输公钥A改为传输数字证书，客户端从证书里获取取公钥A 数字签名如何保证数字证书文件的真实性？数字证书既然通过网络传输，那么中间人也可以直接拦截后篡改内容之后再返回。同样，中间人也可以向同一家机构申请证书然后换成自己的证书。如何避免这些问题？世界没有完全相同的一片叶子，也没有完全相同的一个人。人有指纹，有虹膜，还可以用签名来标识身份信息，在这个场景中，有没有可以借鉴的地方？通过数字签名 签发证书CA机构用非对称加密算法拥有一对公私钥，用摘要算法对证书明文信息获取摘要，然后用私钥对摘要进行加密形成签名，最后将签名与使用的摘要算法置入证书当中。这里，不直接用私钥加密明文主要是因为非对称加密算法存在性能问题，加密内容不宜过长，加密摘要显然优于加密明文。 验证签名 客户端用CA机构公钥解密数字签名得到摘要A（由于是客户端（浏览器等）信任的机构，所以其保有对应证书签发机构的公钥） 客户端用证书中的摘要算法对明文进行摘要得到摘要B 对比摘要A与摘要B是否一致 如果摘要对比一致，则验证成功。 不可篡改为什么数字签名可以保证证书不被篡改？中间人即便篡改明文信息并按照摘要算法重新生成摘要，但是由于没有CA机构的私钥，无法对摘要加密形成有效签名。在客户端验证签名过程中（上节步骤1中），无法正确获取摘要A，验证失败！ 证书掉包既然签名不可伪造，证书内容不可篡改，那么，是否可以将证书整体掉包？证书是可以被掉包的，但是由于证书里包含了申请者的信息比如域名，浏览器等客户端会把证书里的域名与请求时的域名进行比对，掉包随即就被发现。证书被掉包时，浏览器会有如下警告 签名本质采用摘要算法获取明文摘要，采用非对称加密算法私钥加密摘要 证书实例证书通常包含以下信息： 申请者公钥 申请者的组织信息和个人信息 签发机构CA的信息 有效时间、证书序列号等信息明文 签名与签名算法 证书申请 （出自：http://yunlaiwu.github.io/） 本地CA机构公钥加入数字证书是为了让客户端准确获取服务器的公钥。但是要想解开证书中的签名，必须有签发机构的公钥，这些公钥从何而来？事实上，操作系统、浏览器等会在安装时附带其认为安全的 CA机构的根证书列表。例如，在HTTPS通信中使用的服务端证书是CA机构W签发的，如果在浏览器中存在W的根证书，那么就可以直接拿到其公钥。在实际过程中根证书往往不直接颁发服务端证书，而是授权给中间证书。 证书链完整的证书链一般有三级 服务端证书（end-user certificates） 中间证书（intermediates Certificates） 根证书（root Certificates） 点击chrome上这个锁图标，可以看一个https网站经过了几级证书认证，并可以查看每一级证书详细信息 不管存在多少级证书，其最终的目的都是为了验证服务端证书未篡改。中间证书可以存在多级，中间证书不会影响验证结果，证书的签发与验证原理不变，最终只要通过证书链最终被CA根证书验证通过即可中间证书的优势： 分级管理，减少根证书管理量，高效签发与管理证书 根证书内置与客户端中，一旦根证书对应的私钥泄露，吊销根证书非常困难，而中间证书私钥泄露，可先在线吊销 常见证书链如下所示 不被信任证书当证书不是由受信任的机构颁发的，浏览器也会警告，用户可以根据网站提示安装证书或进行其他进一步操作。 服务端如何找到正确的密钥X？一台服务器一般情况是与多个客户端保持连接的，每一个连接都有自己的密钥，如何对对应的客户端用正确的密钥X呢？真正的数据传输前，需要进行SSL/TSL握手，密钥X的传递包含其中。当连接建立后，服务器会为每个客户端维护一个session ID，客户端的每一个请求都会携带该sessionID，而服务器正是通过sessionID找到正确的密钥来解密内容 HTTPS请求流程图解HTTPS请求的大致流程如下所示 拓展SSH常用的SSH协议中(Secure Shell安全外壳协议，简称SSH)，采用的就是非对称加密。SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证，都是自己签发的，那么远程登录使用SSH时是如何防止中间人攻击的？SSH登录有两种方式： 口令登录 公钥登录 口令登录第一次登录时服务器会返回公钥并会给出公钥指纹（摘要算法获取公钥的摘要），用户可以拿到指纹与服务器提供商提供的指纹做对比，验证是否一致 $ ssh user@host The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 如果一致，用户确认之后，公钥将会加密用户输入的密码给服务器，让后建立连接 公钥登录使用口令登录，每次都要输入用户名密码，非常繁琐。在公钥登录方式中，用户自己生成一堆非对称密钥。私钥存于本地，公钥拷贝到服务器，建立连接即可。 参考资料 彻底搞懂HTTPS的加密机制HTTPS安全性原理以及其对前端的影响","categories":[],"tags":[]},{"title":"","slug":"HTTPS加密方式1","date":"2022-04-22T10:00:30.000Z","updated":"2022-06-08T03:09:13.000Z","comments":true,"path":"HTTPS加密方式1.html","link":"","permalink":"http://www.skyline.show/HTTPS加密方式1.html","excerpt":"--- title: HTTPS加密方式1 updated: 2022-01-21 17:56:00 date: 2022-01-20 15:50:45 tags: [] categories: [] --- &gt;作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比","text":"--- title: HTTPS加密方式1 updated: 2022-01-21 17:56:00 date: 2022-01-20 15:50:45 tags: [] categories: [] --- &gt;作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比 端口：HTTPS 443，HTTP 80 传输： HTTPS密文， HTTP 明文 证书：HTTPS需要，HTTP 不需要 （图源：https://juejin.im/post/6844903604868874247） 加密方式常见的加密方式中，是选择对称加密，非对称加密还是算不上加密的摘要算法？以下进行加密方式选择的讨论 摘要算法摘要算法无法逆向获取原文内容，没有可行性。 对称加密（共享密钥加密算法）对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密 可行性存在密钥传输问题如何保证密钥传输给众多客户端过程中不被泄露？网络存在通信实体庞大，不是单单的一对一的问题，往往一台服务器对应众多的访问客户，如何把密钥传递给庞大的客户群并在传输过程不被泄露，是关键问题。 非对称加密公钥加密，私钥解密 可行性单组非对称加密密钥只能保证单边通信可靠性使用一组非对称加密密钥，存在如下问题。客户端公钥加密，服务器私钥解密，客户端到服务器的通信是可靠的，但是反之，服务器向客户端传递信息，如果用私钥加密，则公开的公钥都能解密 两组公钥私钥客户端服务器分别保留一把公钥，一把私钥，公钥加密，私钥解密可行性差的主要原因是非对称加密非常耗时 对称 + 非对称本质采用用非对称算法传递对称密钥，采用对称加密算法加密传输数据 过程 客户端发起请求 服务器明文发送公钥A，客户端获取公钥A 客户端生成密钥X，用公钥A加密密钥X得到密文XXXA后传给服务器 服务器私钥A’解密密文XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 中间人攻击概述非对称加密算法在传递公钥过程中存在公钥被中间人截取篡改的风险。只要是采用了非对称加密算法，都会存在中间人攻击的风险。 非对称加密中间人攻击 中间人获取服务器的公钥A拦截 中间人把自己生产的公钥B返给客户端 客户端用公钥B加密明文”QQ:123 密码：123”成密文XXXB 中间人用私钥B’解密获取明文 中间人用公钥A加密明文为XXXA并传给服务器 上述过程中，客户端与服务器正常通信，难以发觉信息已经被泄露。 信息抵赖由于存在中间人的已知风险，如果不解决非对称中的这个漏洞，即便不存在中间人攻击，对于错误的消息，服务器可以不承认。（中间过程传递的是密文，为了便于理解直接明文展示） 非对称与对称方案中的中间人攻击上述非对称与对称方案并没有解决针对非对称加密算法的此项漏洞，中间人可以在上述非对称与对称方案中进行攻击。具体过程如下 客户端发起请求 服务器发送公钥A，被拦截，中间人获取公钥A 中间人生成公钥B，私钥B’ 中间人发送公钥B，客户端获取公钥B 客户端生成密钥X，用公钥B加密密钥X得到密文XXXB 客户端发送密文XXXB，中间人截取密文 中间人用私钥B’解密获取密钥X 中间人用公钥A加密密钥X得到XXXA，并发送给服务器 服务器私钥A’解密XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 最终中间人成功的获取了客户端与服务器此次通信的密钥X，此次通行中所用信息都可被中间人解密获取 根本原因中间人成功攻击的根本原因是浏览器无法确认获取的公钥真实性 数字证书与签名数字证书为了保证公钥的正确真实性，需要权威CA机构(证书授权中心/Certificate Authority )来颁发数字证书，数字证书里有证书持有者（持有网站）、持有者公钥等信息。在传输过程中，服务器传输公钥A改为传输数字证书，客户端从证书里获取取公钥A 数字签名如何保证数字证书文件的真实性？数字证书既然通过网络传输，那么中间人也可以直接拦截后篡改内容之后再返回。同样，中间人也可以向同一家机构申请证书然后换成自己的证书。如何避免这些问题？世界没有完全相同的一片叶子，也没有完全相同的一个人。人有指纹，有虹膜，还可以用签名来标识身份信息，在这个场景中，有没有可以借鉴的地方？通过数字签名 签发证书CA机构用非对称加密算法拥有一对公私钥，用摘要算法对证书明文信息获取摘要，然后用私钥对摘要进行加密形成签名，最后将签名与使用的摘要算法置入证书当中。这里，不直接用私钥加密明文主要是因为非对称加密算法存在性能问题，加密内容不宜过长，加密摘要显然优于加密明文。 验证签名 客户端用CA机构公钥解密数字签名得到摘要A（由于是客户端（浏览器等）信任的机构，所以其保有对应证书签发机构的公钥） 客户端用证书中的摘要算法对明文进行摘要得到摘要B 对比摘要A与摘要B是否一致 如果摘要对比一致，则验证成功。 不可篡改为什么数字签名可以保证证书不被篡改？中间人即便篡改明文信息并按照摘要算法重新生成摘要，但是由于没有CA机构的私钥，无法对摘要加密形成有效签名。在客户端验证签名过程中（上节步骤1中），无法正确获取摘要A，验证失败！ 证书掉包既然签名不可伪造，证书内容不可篡改，那么，是否可以将证书整体掉包？证书是可以被掉包的，但是由于证书里包含了申请者的信息比如域名，浏览器等客户端会把证书里的域名与请求时的域名进行比对，掉包随即就被发现。证书被掉包时，浏览器会有如下警告 签名本质采用摘要算法获取明文摘要，采用非对称加密算法私钥加密摘要 证书实例证书通常包含以下信息： 申请者公钥 申请者的组织信息和个人信息 签发机构CA的信息 有效时间、证书序列号等信息明文 签名与签名算法 证书申请 （出自：http://yunlaiwu.github.io/） 本地CA机构公钥加入数字证书是为了让客户端准确获取服务器的公钥。但是要想解开证书中的签名，必须有签发机构的公钥，这些公钥从何而来？事实上，操作系统、浏览器等会在安装时附带其认为安全的 CA机构的根证书列表。例如，在HTTPS通信中使用的服务端证书是CA机构W签发的，如果在浏览器中存在W的根证书，那么就可以直接拿到其公钥。在实际过程中根证书往往不直接颁发服务端证书，而是授权给中间证书。 证书链完整的证书链一般有三级 服务端证书（end-user certificates） 中间证书（intermediates Certificates） 根证书（root Certificates） 点击chrome上这个锁图标，可以看一个https网站经过了几级证书认证，并可以查看每一级证书详细信息 不管存在多少级证书，其最终的目的都是为了验证服务端证书未篡改。中间证书可以存在多级，中间证书不会影响验证结果，证书的签发与验证原理不变，最终只要通过证书链最终被CA根证书验证通过即可中间证书的优势： 分级管理，减少根证书管理量，高效签发与管理证书 根证书内置与客户端中，一旦根证书对应的私钥泄露，吊销根证书非常困难，而中间证书私钥泄露，可先在线吊销 常见证书链如下所示 不被信任证书当证书不是由受信任的机构颁发的，浏览器也会警告，用户可以根据网站提示安装证书或进行其他进一步操作。 服务端如何找到正确的密钥X？一台服务器一般情况是与多个客户端保持连接的，每一个连接都有自己的密钥，如何对对应的客户端用正确的密钥X呢？真正的数据传输前，需要进行SSL/TSL握手，密钥X的传递包含其中。当连接建立后，服务器会为每个客户端维护一个session ID，客户端的每一个请求都会携带该sessionID，而服务器正是通过sessionID找到正确的密钥来解密内容 HTTPS请求流程图解HTTPS请求的大致流程如下所示 拓展SSH常用的SSH协议中(Secure Shell安全外壳协议，简称SSH)，采用的就是非对称加密。SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证，都是自己签发的，那么远程登录使用SSH时是如何防止中间人攻击的？SSH登录有两种方式： 口令登录 公钥登录 口令登录第一次登录时服务器会返回公钥并会给出公钥指纹（摘要算法获取公钥的摘要），用户可以拿到指纹与服务器提供商提供的指纹做对比，验证是否一致 $ ssh user@host The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 如果一致，用户确认之后，公钥将会加密用户输入的密码给服务器，让后建立连接 公钥登录使用口令登录，每次都要输入用户名密码，非常繁琐。在公钥登录方式中，用户自己生成一堆非对称密钥。私钥存于本地，公钥拷贝到服务器，建立连接即可。 参考资料 彻底搞懂HTTPS的加密机制HTTPS安全性原理以及其对前端的影响","categories":[],"tags":[]},{"title":"HTTPS加密方式$","slug":"HTTPS加密方式$","date":"2022-01-20T07:48:23.000Z","updated":"2022-01-20T07:49:34.000Z","comments":true,"path":"HTTPS加密方式$.html","link":"","permalink":"http://www.skyline.show/HTTPS加密方式$.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 HTTPS概述加密缘由明文传输的数据在经过wifi热点、路由、通信服务运营商等物理节点时信息容易被劫持暴露而不被发觉容易被中间人攻击，存在以下风险 窃听 篡改 冒充 HTTPS超文本传输安全协议（（HyperText Transfer Protocol Secure）也被称为HTTP over TLS，HTTP over SSL）HTTPS开发是为了解决上述风险，提供对网络服务器的认证，保证交换信息的机密性和完整性，在HTTP的基础上，我们需要进一步做信息传输加密，数据完整校验，身份认证等工作。 与HTTP对比 端口：HTTPS 443，HTTP 80 传输： HTTPS密文， HTTP 明文 证书：HTTPS需要，HTTP 不需要 （图源：https://juejin.im/post/6844903604868874247） 加密方式常见的加密方式中，是选择对称加密，非对称加密还是算不上加密的摘要算法？以下进行加密方式选择的讨论 摘要算法摘要算法无法逆向获取原文内容，没有可行性。 对称加密（共享密钥加密算法）对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密 可行性存在密钥传输问题如何保证密钥传输给众多客户端过程中不被泄露？网络存在通信实体庞大，不是单单的一对一的问题，往往一台服务器对应众多的访问客户，如何把密钥传递给庞大的客户群并在传输过程不被泄露，是关键问题。 非对称加密公钥加密，私钥解密 可行性单组非对称加密密钥只能保证单边通信可靠性使用一组非对称加密密钥，存在如下问题。客户端公钥加密，服务器私钥解密，客户端到服务器的通信是可靠的，但是反之，服务器向客户端传递信息，如果用私钥加密，则公开的公钥都能解密 两组公钥私钥客户端服务器分别保留一把公钥，一把私钥，公钥加密，私钥解密可行性差的主要原因是非对称加密非常耗时 对称 + 非对称本质采用用非对称算法传递对称密钥，采用对称加密算法加密传输数据 过程 客户端发起请求 服务器明文发送公钥A，客户端获取公钥A 客户端生成密钥X，用公钥A加密密钥X得到密文XXXA后传给服务器 服务器私钥A’解密密文XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 中间人攻击概述非对称加密算法在传递公钥过程中存在公钥被中间人截取篡改的风险。只要是采用了非对称加密算法，都会存在中间人攻击的风险。 非对称加密中间人攻击 中间人获取服务器的公钥A拦截 中间人把自己生产的公钥B返给客户端 客户端用公钥B加密明文”QQ:123 密码：123”成密文XXXB 中间人用私钥B’解密获取明文 中间人用公钥A加密明文为XXXA并传给服务器 上述过程中，客户端与服务器正常通信，难以发觉信息已经被泄露。 信息抵赖由于存在中间人的已知风险，如果不解决非对称中的这个漏洞，即便不存在中间人攻击，对于错误的消息，服务器可以不承认。（中间过程传递的是密文，为了便于理解直接明文展示） 非对称与对称方案中的中间人攻击上述非对称与对称方案并没有解决针对非对称加密算法的此项漏洞，中间人可以在上述非对称与对称方案中进行攻击。具体过程如下 客户端发起请求 服务器发送公钥A，被拦截，中间人获取公钥A 中间人生成公钥B，私钥B’ 中间人发送公钥B，客户端获取公钥B 客户端生成密钥X，用公钥B加密密钥X得到密文XXXB 客户端发送密文XXXB，中间人截取密文 中间人用私钥B’解密获取密钥X 中间人用公钥A加密密钥X得到XXXA，并发送给服务器 服务器私钥A’解密XXXA获取密钥X 双方用密钥X对称加解密进行通信 过程图示 最终中间人成功的获取了客户端与服务器此次通信的密钥X，此次通行中所用信息都可被中间人解密获取 根本原因中间人成功攻击的根本原因是浏览器无法确认获取的公钥真实性 数字证书与签名数字证书为了保证公钥的正确真实性，需要权威CA机构(证书授权中心/Certificate Authority )来颁发数字证书，数字证书里有证书持有者（持有网站）、持有者公钥等信息。在传输过程中，服务器传输公钥A改为传输数字证书，客户端从证书里获取取公钥A 数字签名如何保证数字证书文件的真实性？数字证书既然通过网络传输，那么中间人也可以直接拦截后篡改内容之后再返回。同样，中间人也可以向同一家机构申请证书然后换成自己的证书。如何避免这些问题？世界没有完全相同的一片叶子，也没有完全相同的一个人。人有指纹，有虹膜，还可以用签名来标识身份信息，在这个场景中，有没有可以借鉴的地方？通过数字签名 签发证书CA机构用非对称加密算法拥有一对公私钥，用摘要算法对证书明文信息获取摘要，然后用私钥对摘要进行加密形成签名，最后将签名与使用的摘要算法置入证书当中。这里，不直接用私钥加密明文主要是因为非对称加密算法存在性能问题，加密内容不宜过长，加密摘要显然优于加密明文。 验证签名 客户端用CA机构公钥解密数字签名得到摘要A（由于是客户端（浏览器等）信任的机构，所以其保有对应证书签发机构的公钥） 客户端用证书中的摘要算法对明文进行摘要得到摘要B 对比摘要A与摘要B是否一致 如果摘要对比一致，则验证成功。 不可篡改为什么数字签名可以保证证书不被篡改？中间人即便篡改明文信息并按照摘要算法重新生成摘要，但是由于没有CA机构的私钥，无法对摘要加密形成有效签名。在客户端验证签名过程中（上节步骤1中），无法正确获取摘要A，验证失败！ 证书掉包既然签名不可伪造，证书内容不可篡改，那么，是否可以将证书整体掉包？证书是可以被掉包的，但是由于证书里包含了申请者的信息比如域名，浏览器等客户端会把证书里的域名与请求时的域名进行比对，掉包随即就被发现。证书被掉包时，浏览器会有如下警告 签名本质采用摘要算法获取明文摘要，采用非对称加密算法私钥加密摘要 证书实例证书通常包含以下信息： 申请者公钥 申请者的组织信息和个人信息 签发机构CA的信息 有效时间、证书序列号等信息明文 签名与签名算法 证书申请 （出自：http://yunlaiwu.github.io/） 本地CA机构公钥加入数字证书是为了让客户端准确获取服务器的公钥。但是要想解开证书中的签名，必须有签发机构的公钥，这些公钥从何而来？事实上，操作系统、浏览器等会在安装时附带其认为安全的 CA机构的根证书列表。例如，在HTTPS通信中使用的服务端证书是CA机构W签发的，如果在浏览器中存在W的根证书，那么就可以直接拿到其公钥。在实际过程中根证书往往不直接颁发服务端证书，而是授权给中间证书。 证书链完整的证书链一般有三级 服务端证书（end-user certificates） 中间证书（intermediates Certificates） 根证书（root Certificates） 点击chrome上这个锁图标，可以看一个https网站经过了几级证书认证，并可以查看每一级证书详细信息 不管存在多少级证书，其最终的目的都是为了验证服务端证书未篡改。中间证书可以存在多级，中间证书不会影响验证结果，证书的签发与验证原理不变，最终只要通过证书链最终被CA根证书验证通过即可中间证书的优势： 分级管理，减少根证书管理量，高效签发与管理证书 根证书内置与客户端中，一旦根证书对应的私钥泄露，吊销根证书非常困难，而中间证书私钥泄露，可先在线吊销 常见证书链如下所示 不被信任证书当证书不是由受信任的机构颁发的，浏览器也会警告，用户可以根据网站提示安装证书或进行其他进一步操作。 服务端如何找到正确的密钥X？一台服务器一般情况是与多个客户端保持连接的，每一个连接都有自己的密钥，如何对对应的客户端用正确的密钥X呢？真正的数据传输前，需要进行SSL/TSL握手，密钥X的传递包含其中。当连接建立后，服务器会为每个客户端维护一个session ID，客户端的每一个请求都会携带该sessionID，而服务器正是通过sessionID找到正确的密钥来解密内容 HTTPS请求流程图解HTTPS请求的大致流程如下所示 拓展SSH常用的SSH协议中(Secure Shell安全外壳协议，简称SSH)，采用的就是非对称加密。SSH不像https协议，SSH协议的公钥是没有证书中心（CA）公证，都是自己签发的，那么远程登录使用SSH时是如何防止中间人攻击的？SSH登录有两种方式： 口令登录 公钥登录 口令登录第一次登录时服务器会返回公钥并会给出公钥指纹（摘要算法获取公钥的摘要），用户可以拿到指纹与服务器提供商提供的指纹做对比，验证是否一致 $ ssh user@host The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 如果一致，用户确认之后，公钥将会加密用户输入的密码给服务器，让后建立连接 公钥登录使用口令登录，每次都要输入用户名密码，非常繁琐。在公钥登录方式中，用户自己生成一堆非对称密钥。私钥存于本地，公钥拷贝到服务器，建立连接即可。 参考资料 彻底搞懂HTTPS的加密机制HTTPS安全性原理以及其对前端的影响","categories":[],"tags":[]},{"title":"ES类的使用","slug":"ES类的使用","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"ES类的使用.html","link":"","permalink":"http://www.skyline.show/ES类的使用.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 ES 类的使用 ES 类的使用 静态（类）、实例、原型属性与方法 ES5 ES6 属性访问结论 Class 原型方法语法糖 Class 中属性与方法的枚举性质 BMW WARNING Bulletin Material Warrant 静态（类）、实例、原型属性与方法ES5Baby 类 //对象构造函数function Baby(name) &#123; var className = \"Baby\"; //实例属性，每个实例私有，在对象实例化后调用，实例属性在对象实力化后创建 this.name = name; this.weight = \"3kg\"; this.hello = function () &#123; console.log(this.name); console.log(this.msg()); //使用原型方法扩充的方法可以在类内部使用 console.log(this.sex); //使用原型方法扩充的属性可以在类内部使用 console.log(Baby.age, this.age); //静态属性调用时格式为[对象.静态属性] &#125;; //对象方法&#125;//类方法 (实际是静态方法直接调用)，只有类才能访问类方法，实例不能访问 ，在类方法中通过this只能访问类属性不能访问其他属性，即在本例中，Run方法只能访问到this.ageBaby.Run = function () &#123; console.log(\"跑起来！！！\");&#125;;//原型方法，如果原型方法当作静态方法直接调用时，this.name无法被调用Baby.prototype.msg = function () &#123; console.log(\"我叫：\" + this.name);&#125;;//类属性 在类的外部。公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用，只有类才能访问类属性，实例不能访问Baby.age = 20;//原型属性，所有实例共有，【this.属性】这种写法访问时，先会访问实例对象属性，没有实例对象属性就会访问原型属性 ，也可以当成公有静态属性使用【对象.prototype.原型属性。Baby.prototype.sex = \"男娃娃\"; 使用 //实例方法和原型方法需要实例化对象后才可以使var bob = new Baby(\"bob\");Baby.name;//\"Baby\" :每一个类都有一个基本的name属性bob.name;//\"bob\"Baby.weight;//undefinedbob.weight;//\"3kg\"Baby.hello();//Uncaught TypeError: Baby.hello is not a functionbob.hello();// bob// 我叫：bob// undefined :this.msg没有返回所以undefined// 男娃娃// 20 undefinedBaby.Run(); //跑起来！！！//类方法也是静态方法，可以直接使用 【对象.静态方法()】bob.run(); // TypeError: bob.run is not a functionBaby.msg();// Uncaught TypeError: Baby.msg is not a functionBaby.prototype.msg();// 我叫：undefined//原型方法当成静态方法使用时【对象.prototype.方法()】bob.msg();// 我叫：bob//原型方法必须实例化对象bob.age;// undefined//错误，公有静态属性只能使用 【对象.属性】调用Baby.age;// 20Baby.prototype.sex;// 男娃娃//原型属性当作静态属性使用时【对象.prototype.方法()】Baby.sex;// undefinedbob.sex;// 男娃娃 ES6Baby 类 class Baby &#123; //实例属性、方法 eat = \"meat\"; constructor(x, y) &#123; //实例属性、方法 this.firstName = x; this.lastName = y; this.say = function () &#123; return \"skyline\"; &#125;; &#125; //原型属性，使用存取器 get prop() &#123; return \"skyline getter\"; &#125; set prop(value) &#123; console.log(\"skyline setter: \" + value); &#125; //原型方法 toString() &#123; return \"(\" + this.firstName + \", \" + this.lastName + \")\"; &#125; //类方法 static hello() &#123; return \"hello skyline\"; &#125; static hi() &#123; return this.hello; //如果静态方法包含this关键字，这个this指的是类，而不是实例 &#125;&#125;//类属性，ES6 在当前阶段，Class 内部只有静态方法，没有静态属性，可以直接指定类（静态）属性Baby.age = 1; 属性访问结论不论是那种方式建立，遵循以下结论 静态属性方法，可以直接通过类进行访问的 实例属性方法是需要创建实例对象进行访问的 静态与实例之间的属性与方法不能互访 Class原型方法语法糖","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 ES 类的使用 ES 类的使用 静态（类）、实例、原型属性与方法 ES5 ES6 属性访问结论 Class 原型方法语法糖 Class 中属性与方法的枚举性质 BMW WARNING Bulletin Material Warrant 静态（类）、实例、原型属性与方法ES5Baby 类 //对象构造函数function Baby(name) &#123; var className = \"Baby\"; //实例属性，每个实例私有，在对象实例化后调用，实例属性在对象实力化后创建 this.name = name; this.weight = \"3kg\"; this.hello = function () &#123; console.log(this.name); console.log(this.msg()); //使用原型方法扩充的方法可以在类内部使用 console.log(this.sex); //使用原型方法扩充的属性可以在类内部使用 console.log(Baby.age, this.age); //静态属性调用时格式为[对象.静态属性] &#125;; //对象方法&#125;//类方法 (实际是静态方法直接调用)，只有类才能访问类方法，实例不能访问 ，在类方法中通过this只能访问类属性不能访问其他属性，即在本例中，Run方法只能访问到this.ageBaby.Run = function () &#123; console.log(\"跑起来！！！\");&#125;;//原型方法，如果原型方法当作静态方法直接调用时，this.name无法被调用Baby.prototype.msg = function () &#123; console.log(\"我叫：\" + this.name);&#125;;//类属性 在类的外部。公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用，只有类才能访问类属性，实例不能访问Baby.age = 20;//原型属性，所有实例共有，【this.属性】这种写法访问时，先会访问实例对象属性，没有实例对象属性就会访问原型属性 ，也可以当成公有静态属性使用【对象.prototype.原型属性。Baby.prototype.sex = \"男娃娃\"; 使用 //实例方法和原型方法需要实例化对象后才可以使var bob = new Baby(\"bob\");Baby.name;//\"Baby\" :每一个类都有一个基本的name属性bob.name;//\"bob\"Baby.weight;//undefinedbob.weight;//\"3kg\"Baby.hello();//Uncaught TypeError: Baby.hello is not a functionbob.hello();// bob// 我叫：bob// undefined :this.msg没有返回所以undefined// 男娃娃// 20 undefinedBaby.Run(); //跑起来！！！//类方法也是静态方法，可以直接使用 【对象.静态方法()】bob.run(); // TypeError: bob.run is not a functionBaby.msg();// Uncaught TypeError: Baby.msg is not a functionBaby.prototype.msg();// 我叫：undefined//原型方法当成静态方法使用时【对象.prototype.方法()】bob.msg();// 我叫：bob//原型方法必须实例化对象bob.age;// undefined//错误，公有静态属性只能使用 【对象.属性】调用Baby.age;// 20Baby.prototype.sex;// 男娃娃//原型属性当作静态属性使用时【对象.prototype.方法()】Baby.sex;// undefinedbob.sex;// 男娃娃 ES6Baby 类 class Baby &#123; //实例属性、方法 eat = \"meat\"; constructor(x, y) &#123; //实例属性、方法 this.firstName = x; this.lastName = y; this.say = function () &#123; return \"skyline\"; &#125;; &#125; //原型属性，使用存取器 get prop() &#123; return \"skyline getter\"; &#125; set prop(value) &#123; console.log(\"skyline setter: \" + value); &#125; //原型方法 toString() &#123; return \"(\" + this.firstName + \", \" + this.lastName + \")\"; &#125; //类方法 static hello() &#123; return \"hello skyline\"; &#125; static hi() &#123; return this.hello; //如果静态方法包含this关键字，这个this指的是类，而不是实例 &#125;&#125;//类属性，ES6 在当前阶段，Class 内部只有静态方法，没有静态属性，可以直接指定类（静态）属性Baby.age = 1; 属性访问结论不论是那种方式建立，遵循以下结论 静态属性方法，可以直接通过类进行访问的 实例属性方法是需要创建实例对象进行访问的 静态与实例之间的属性与方法不能互访 Class原型方法语法糖 对于 ES6 的 Baby 类的 toString toString() &#123; return '(' + this.firstName + ', ' + this.lastName + ')';&#125; ES5 中可以看做是如下代码的语法糖 Point.prototype.toString = function () &#123; return \"(\" + this.firstName + \", \" + this.lastName + \")\";&#125;; Class 中属性与方法的枚举性质Reflect.ownKeys 可列出所有自有属性，不管枚举与否。Object.keys 可列出可枚举的自有属性。 实例属性可枚举 const skyline = new Baby(1, 1);Reflect.ownKeys(skyline);// (4) ['eat', 'firstName', 'lastName', 'say']Object.keys(skyline);// (4) ['eat', 'firstName', 'lastName', 'say'] 原型属性与方法不可枚举，这与 ES5 中原型属性方法不同，其是可枚举的。 Reflect.ownKeys(skyline.__proto__);// (3) ['constructor', 'prop', 'toString']Object.keys(skyline.__proto__);//[] BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"ES对象创建","slug":"ES对象创建","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"ES对象创建.html","link":"","permalink":"http://www.skyline.show/ES对象创建.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 JS 对象的创建 JS 对象的创建 工厂模式 构造函数模式 实现 优化 原型模式 实现 原型判定 原型重写 原型模式问题 组合构造与原型 动态原型 实现 重写原型 寄生构造函数 稳妥构造函数 BMW WARNING Bulletin Material Warrant 工厂模式工厂模式解决了创建多个对象的问题，但是没有解决对象识别问题（创建对象后其父对象？） function person(name) &#123; var p = new Object(); p.name = name; return p;&#125;var me = person(\"skyline\");me.name; // 'skyline' 构造函数模式实现解决了对象识别问题 构造函数首字母都要大写，非构造函数小写字母开头 构造函数主要问题是方法会在实例中各自创建，me.say === you.say 说明了这个问题 function Person(name) &#123; this.name = name; this.say = function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;;&#125;var me = new Person(\"skyline\");var you = new Person(\"hahaha\");me.say(); // My name is skylineyou.say(); // My name is hahahame.say === you.say; // false 优化优化方案解决了方法不能复用的问题，但破坏了封装 function sayName() &#123; console.log(`My name is $&#123;this.name&#125;`);&#125;function Person(name) &#123; this.name = name; this.say = sayName;&#125;var me = new Person(\"skyline\");var you = new Person(\"hahaha\");me.say(); // My name is skylineyou.say(); // My name is hahahame.say === you.say; // true 原型模式实现ES 中，无论何时创建的新函数，都会根据一组特定的规则来为函数添加一个指向原型对象名为 prototype 的指针属性，该原型对象自动获得一个 constructor 属性，属性指向该函数，而后基于原型对象添置实例共享的属性和方法 function Person() &#123;&#125;Person.prototype.name = \"skyline\";Person.prototype.age = 27;Person.prototype.sayName = function () &#123; alert(this.name);&#125;;var skyline = new Person();skyline.sayName(); // My name is skylineskyline instanceof Person; // true 原型判定","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 JS 对象的创建 JS 对象的创建 工厂模式 构造函数模式 实现 优化 原型模式 实现 原型判定 原型重写 原型模式问题 组合构造与原型 动态原型 实现 重写原型 寄生构造函数 稳妥构造函数 BMW WARNING Bulletin Material Warrant 工厂模式工厂模式解决了创建多个对象的问题，但是没有解决对象识别问题（创建对象后其父对象？） function person(name) &#123; var p = new Object(); p.name = name; return p;&#125;var me = person(\"skyline\");me.name; // 'skyline' 构造函数模式实现解决了对象识别问题 构造函数首字母都要大写，非构造函数小写字母开头 构造函数主要问题是方法会在实例中各自创建，me.say === you.say 说明了这个问题 function Person(name) &#123; this.name = name; this.say = function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;;&#125;var me = new Person(\"skyline\");var you = new Person(\"hahaha\");me.say(); // My name is skylineyou.say(); // My name is hahahame.say === you.say; // false 优化优化方案解决了方法不能复用的问题，但破坏了封装 function sayName() &#123; console.log(`My name is $&#123;this.name&#125;`);&#125;function Person(name) &#123; this.name = name; this.say = sayName;&#125;var me = new Person(\"skyline\");var you = new Person(\"hahaha\");me.say(); // My name is skylineyou.say(); // My name is hahahame.say === you.say; // true 原型模式实现ES 中，无论何时创建的新函数，都会根据一组特定的规则来为函数添加一个指向原型对象名为 prototype 的指针属性，该原型对象自动获得一个 constructor 属性，属性指向该函数，而后基于原型对象添置实例共享的属性和方法 function Person() &#123;&#125;Person.prototype.name = \"skyline\";Person.prototype.age = 27;Person.prototype.sayName = function () &#123; alert(this.name);&#125;;var skyline = new Person();skyline.sayName(); // My name is skylineskyline instanceof Person; // true 原型判定 调用构造函数创建一个新的实例之后，该实例内部包含一个指向构造函数原型对象的指针[[Prototype]]（内部属性）。多数浏览器实现了__proto__来获取[[Prototype]]内部属性 可以通过 isPrototypeOf()与 getPrototypeOf()来确定与获取关系 skyline.__proto__ == Person.prototype; // trueObject.getPrototypeOf(skyline) == Person.prototype; // truePerson.prototype.isPrototypeOf(skyline); // true 原型重写为了更好的封装性，有时会进行原型重写。 重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系，故重写需谨慎，最好在新建函数的时候重写 通过直接重写 prototype 时，注意将构造函数属性加上 constructor 属性来指定构造函数，此时重新设定的 constructor 属性是可枚举的，es 原生的是不可枚举的，可通过 Object.defineProperty()来定义 constructor Person.prototype = &#123; // constructor: Person, // 不指定构造函数 say: function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;,&#125;;skyline.constructor === Person; // false 原型模式问题 属性和方法都共享，多个实例之间会相互影响 无法动态传递参数 组合构造与原型组合使用两者，构造函数模式用于实例属性，原型模式用于定义方法和共享属性 应用最广泛的模式，没有在一个地方使用构造函数与原型，对于封装性而言，不算最佳 动态原型实现动态原型模式是将原型与自有的信息都封装在构造函数中，通过在必要情况下初始化原型，实现组合使用构造函数与原型的优点。 实质就是通过检查某个应该存在的方法是否有效来决定是否初始化原型方法，if 语句检查初始化后应该存在的任何属性或方法，检查其中一个即可 function Person() &#123; this.name = \"skyline\"; if (typeof this.say != \"function\") &#123; Person.prototype.say = function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;; Person.prototype.sayHi = function () &#123; console.log(`Hi!$&#123;this.name&#125;`); &#125;; &#125;&#125;var skyline = new Person();skyline.say(); // My name is skyline 重写原型在构造函数中通过对象字面量重写原型 function Person() &#123; this.name = \"skyline\"; if (typeof this.say != \"function\") &#123; // 不能再构造函数中直接用对象字面量重写原型，重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系 Person.prototype = &#123; constructor: Person, // 指定构造函数 say: function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;, &#125;; &#125;&#125;var skyline = new Person();// 首次使用时，skyline的__proto__是指向默认产生的原型对象// 而不是由字面量创建的新原型对象，调用say将会找不到skyline.say(); // VM846:1 Uncaught TypeError: skyline.say is not a function 可以通过如下方式解决上述问题 function Person() &#123; this.name = \"skyline\"; if (typeof this.say != \"function\") &#123; // 不能再构造函数中直接用对象字面量重写原型，重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系 Person.prototype = &#123; constructor: Person, // 指定构造函数 say: function () &#123; console.log(`My name is $&#123;this.name&#125;`); &#125;, &#125;; return new Person(); &#125;&#125; 寄生构造函数new 操作符并把使用的包装函数叫做构造函数之外，此模式与工厂模式并没有区别 创建的对象与构造函数之间毫无关系 function Person(name) &#123; var p = new Object(); p.name = name; return p;&#125;var me = new Person(\"skyline\");me.name; // 'skyline'me instanceof Person; // false 稳妥构造函数 稳妥对象是指没有公共属性，其方法不使用 this 的对象稳妥构造函数模式与寄生构造函数类似，有两点不同一是实例方法不引用 this，二是构造函数不使用 new。 如下代码中创建了一个稳妥对象，除了 say 没有其他方式可以访问传入构造函数的原始数据。保证了数据的安全性。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型 function Person(name) &#123; var p = new Object(); var age = 27; p.say = function () &#123; console.log(`My name is $&#123;name&#125; and I am $&#123;age&#125;`); &#125;; return p;&#125;var me = Person(\"skyline\"); BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 《JavaScript 高级程序设计》 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"systemd开启后台进程","slug":"systemd开启后台进程","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"systemd开启后台进程.html","link":"","permalink":"http://www.skyline.show/systemd开启后台进程.html","excerpt":"","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 利用 Systemd 开启后台进程 利用 Systemd 开启后台进程 简介 创建新服务 开启服务 systemd服务操作汇总 简介systemd 是 Linux 中系统与服务管的系列套件，其中 d 沿用传统指代 daemon。systemd 提供多个命令行工具，最基本的为 systemctlsystemd 体系庞大，提供繁杂的功能，其中一个常用的功能就是开启后台服务。 创建新服务创建服务文件并打开 vi /etc/systemd/system/foo.service 输入以下内容 [Unit]Description=My custom serviceAfter=network.target[Service]Type=simpleExecStart=/usr/bin/brook server --listen :992 --password xxxxRestart=alwaysUser=root[Install]WantedBy=multi-user.target [Unit] 提供服务基础信息 Description 为描述信息 After 服务启动的前置条件 [Service] 提供启动服务的相关信息 [Install] WantedBy 定义服务被谁触发 Defines which service triggers the custom service if enabled with systemctl enable. This is mostly used for starting the custom service on boot. In this example, foo.service uses multi-user.target, which starts foo.service when systemd loads multi-user.target on boot. 开启服务创建该服务后，需要重载 systemd 服务文件 systemctl daemon-reload 开启该服务 systemctl start foo 查看该服务运行状态 systemctl status foo systemd服务操作汇总开启服务 systemctl start foo 关闭服务 systemctl stop foo 重启服务 systemctl restart foo 服务状态 systemctl status foo 开机自启动服务 systemctl enable foo 禁止开机启动 systemctl disable foo 查看是否允许开机启动 systemctl is-enabled foo","categories":[],"tags":[]},{"title":"Vue基础使用","slug":"Vue基础使用","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"Vue基础使用.html","link":"","permalink":"http://www.skyline.show/Vue基础使用.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Vue 基础使用 Vue 基础使用 Vue Router model img 图片错误默认处理 extend 获取.vue 组件的构造函数 使用示例 无法挂载错误 mixin 混入规则 组件挂载顺序 简述 总结 computed 简单说明 setter $watch 用法 注意 返回值 深度监听 资源引用 refs 使用 动态组件 \\$attrs 与\\$listeners 生命周期函数 监听 Vue.observable BMW WARNING Bulletin Material Warrant Vue Router modelVue 有两种路由模式: Hash History 默认情况下使用 Hash 模式。哈希模式利用 URL Hash 保证单页系统不进行页面重载。但是，传统 URL 的 Hash 中即常见的site#thing是来定位页面内容的，使用site/thing来跳转页面Hash 模式虽然保证了页面不跳转，但是’#’的出现破坏了传统规则。在一些项目中，会使用 History 模式。 const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) History 模式通过 history.pushState 防止路由重载。由于单页问题，History 在对应路由在服务器中位置并没有 HTML 入口文件，这需要我们进行额外的服务配置。若不进行配置，刷新页面会报错。Nginx 配置如下 location / &#123; try_files $uri $uri/ /index.html;&#125; 其余服务端配置参考https://router.vuejs.org/guide/essentials/history-mode.html#example-server-configurations img 图片错误默认处理&lt;img width=\"98\" height=\"112\" :src=\"m.imgAddr || '~@img/suspect.png'\" @error=\"slotimg\" alt/&gt;let defaultImg = require(\"@img/suspect.png\");methods: &#123; slotimg(event) &#123; console.log(\"HotFocus.vue第211行:::err img\"); let img = event.srcElement; img.src = defaultImg; img.onerror = null; //防止闪图 &#125;,&#125; html 原生是 οnerrοr 来监听图片渲染错误事件 extend获取.vue 组件的构造函数使用示例Vue.extend var button = Vue.extend(FullScreenButton)var b = new button()b.$mount() 无法挂载错误 出现这种错误是由于首字母大写导致，具体缘由待查，如下图中注释所示 mixin混入规则","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Vue 基础使用 Vue 基础使用 Vue Router model img 图片错误默认处理 extend 获取.vue 组件的构造函数 使用示例 无法挂载错误 mixin 混入规则 组件挂载顺序 简述 总结 computed 简单说明 setter $watch 用法 注意 返回值 深度监听 资源引用 refs 使用 动态组件 \\$attrs 与\\$listeners 生命周期函数 监听 Vue.observable BMW WARNING Bulletin Material Warrant Vue Router modelVue 有两种路由模式: Hash History 默认情况下使用 Hash 模式。哈希模式利用 URL Hash 保证单页系统不进行页面重载。但是，传统 URL 的 Hash 中即常见的site#thing是来定位页面内容的，使用site/thing来跳转页面Hash 模式虽然保证了页面不跳转，但是’#’的出现破坏了传统规则。在一些项目中，会使用 History 模式。 const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) History 模式通过 history.pushState 防止路由重载。由于单页问题，History 在对应路由在服务器中位置并没有 HTML 入口文件，这需要我们进行额外的服务配置。若不进行配置，刷新页面会报错。Nginx 配置如下 location / &#123; try_files $uri $uri/ /index.html;&#125; 其余服务端配置参考https://router.vuejs.org/guide/essentials/history-mode.html#example-server-configurations img 图片错误默认处理&lt;img width=\"98\" height=\"112\" :src=\"m.imgAddr || '~@img/suspect.png'\" @error=\"slotimg\" alt/&gt;let defaultImg = require(\"@img/suspect.png\");methods: &#123; slotimg(event) &#123; console.log(\"HotFocus.vue第211行:::err img\"); let img = event.srcElement; img.src = defaultImg; img.onerror = null; //防止闪图 &#125;,&#125; html 原生是 οnerrοr 来监听图片渲染错误事件 extend获取.vue 组件的构造函数使用示例Vue.extend var button = Vue.extend(FullScreenButton)var b = new button()b.$mount() 无法挂载错误 出现这种错误是由于首字母大写导致，具体缘由待查，如下图中注释所示 mixin混入规则 data 在混入时会进行递归合并，如果两个属性发生冲突，则以组件自身为主 生命周期钩子函数 混入时会将同名钩子函数加入到一个数组中，会先按照数组顺序依次执行执行混入对象的同名钩子函数，再执行本组件的。 组件挂载顺序简述 vue 子组件与父组件之间，父组件首先加载完成（beforeCreate-&gt;beforeMount 率先执行）之后是子组件加载，最后由子向父组件挂载 要在所有组件生命周期完成后执行某个函数，只需要在父组件加入 nextTick 即可 vue 代码结构如下 &lt;template&gt; &lt;div class=&apos;papa&apos;&gt; &lt;c1&gt;&lt;/c1&gt; &lt;c2&gt;&lt;/c2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;PaPa&apos;, components: &#123; c1, c2 &#125;, beforeCreate() &#123; console.log(&apos;papa beforeCreate&apos;) &#125;, created() &#123; console.log(&apos;papa created&apos;) &#125;, beforeMount() &#123; console.log(&apos;papa beforeMount&apos;) &#125;, mounted()&#123; console.log(&apos;papa mounted&apos;) this.$nextTick(() =&gt; &#123; console.log(&apos;papa nextTick&apos;) &#125;) setTimeout(() =&gt; &#123; console.log(&apos;papa setTimeout&apos;) &#125;) &#125;&#125;&lt;/script&gt; 打印结果如下： 其中 nextTick 与 setTimeout 在生命周期的位置无关 总结加载渲染过程 父 beforeCreate=&gt;父 created=&gt;父 beforeMount=&gt;子 beforeCreate=&gt;子 created=&gt;子 beforeMount=&gt;子 mounted=&gt;父 mounted 子组件更新过程 父 beforeUpdate=&gt;子 beforeUpdate=&gt;子 updated=&gt;父 updated 父组件更新过程 父 beforeUpdate=&gt;父 updated 销毁过程 父 beforeDestroy=&gt;子 beforeDestroy=&gt;子 destoryed=&gt;父 destoryed computed简单说明计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要依赖还没有发生改变，多次访问计算属性会立即返回之前的计算结果，这一定程度上节约了开销。 settersetter 需要注意的是，如果需要书写 set 函数，一般需要变更计算属性相关依赖 computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; $watch用法观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代，或写在 computed 中，监听 computed 注意第一参数 $watch 函数接受的第一个参数是属性名的字符串，一定要用引号，不能用变量来获取 data() &#123; return &#123; itemList: [] &#125; &#125;, mounted() &#123; this.$nextTick(() =&gt; &#123; this.$watch('itemList', function(n, v) &#123;//不能写成this.itemList或直接写itemList this.mainPostList = _.takeWhile(n,function(o) &#123; return o.id == 18 &#125;) &#125;) &#125;) &#125; 返回值$watch 返回一个取消观察函数，用来停止触发回调 var unwatch = vm.$watch('a', cb) // 之后取消观察unwatch() 深度监听为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 vm.$watch(&apos;someObject&apos;, callback, &#123; deep: true&#125;) 在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 资源引用vue-html-loader 和 css-loader 认为没带根的路径为相对路径。官方为了让其看起来像模块路径, 加上了~前缀标志，表示让其从 webpack 配置中 alias 的相应项目取值，不加将找不到相应模块。 //webpackresolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), '@assets': resolve('src/assets'), 'static': resolve('static'), &#125;&#125;//less使用&lt;style lang=\"less\"&gt; @import '~vux/src/styles/reset.less';&lt;/style&gt;//dom使用&lt;img class=\"logo\" src=\"~assets/logo.png\"&gt; refs 使用 $refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。 各生命周期中，只有 updated 阶段则是完成了数据更新到 DOM 的阶段,但当页面 DOM 频繁更新，需考虑放在此处的合法性 动态组件当 v-if/v-else-if 存在较多情况且其内部渲染的组件较大时，考虑使用动态组件，例如 tab 标签下的内容 示例 1 &lt;component v-bind:is='currentTabComponent'&gt;&lt;/component&gt; 示例 2 export const menus = [ &#123; name: \"业务管理\", icon: \"el-icon-document-copy\", id: \"form\", children: [&#123; name: \"业务注册\", icon: \"el-icon-document\", id: \"formList\", to: \"formList\" &#125; ] &#125;, &#123; name: \"数据源注册\", icon: \"el-icon-finance\", id: \"dataSource\", to: \"dataSource\" &#125;,]&lt;el-menu ref=\"elMenu\" class=\"el-menu-vertical\" :default-active=\"active\" :collapse=\"isCollapse\" :router=\"true\"&gt; &lt;component v-bind:is=\"m.children ? 'ElSubmenu' : 'ElMenuItem'\" v-for=\"(m, i) in menus\" :index=\"m.to\" :key=\"i\" &gt; &lt;template slot=\"title\"&gt; &lt;i :class=\"m.icon\"&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;m.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group v-if=\"m.children\"&gt; &lt;el-menu-item v-for=\"(c, i) in (m.children || [])\" :index=\"c.to\" :key=\"i\"&gt; &lt;template slot=\"title\"&gt; &lt;i :class=\"c.icon\"&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;c.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/component&gt;&lt;/el-menu&gt; \\$attrs 与\\$listeners \\$attrs 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外) $listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。 即接收除了 props 声明外的所有绑定属性（class、style 除外），$listeners包含了父作用域中的事件监听器 在创建高级别的组件时，通过 v-on=”$listeners“，与 v-bind=”$attrs” 将值传入内部组件。 示例 skylline-dialog.vue &lt;el-dialog :visible.sync=\"show\" v-bind=\"$attrs\" v-on=\"$listeners\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;template #footer&gt; &lt;slot name=\"footer\"&gt; &lt;span&gt; &lt;el-button&gt;取 消&lt;/el-button&gt; &lt;el-button&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/slot&gt; &lt;/template&gt;&lt;/el-dialog&gt; 在一个业务系统中所有弹窗都需要两个按钮，为了减少每次使用弹窗都写按钮，我们将弹窗组件进行二次封装。 通过attrs 与listeners，我们避免了 props 及$emit 对属性与事件逐个添加。 &lt;skyline-dialog :visible.sync=\"show\" title=\"测试\" @opened=\"doSth\"&gt; 这是一段内容&lt;/skyline-dialog&gt; 生命周期函数监听可以通过$on 监听 this.on(&#39;hook:updated&#39;, () =&gt; {}) 父组件监听 ` Vue.observableVue.observable 会让一个对象成为响应式的。 const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h( 'button', &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;, &#125;, &#125;, `count is: $&#123;state.count&#125;` ) &#125;,&#125; BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"康定周边2日","slug":"康定周边2日","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"康定周边2日.html","link":"","permalink":"http://www.skyline.show/康定周边2日.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 康定周边 2 日 康定周边 2 日 准备 时间 物品清单 路线 主要地点 海螺沟 折多山 新都桥 BMW WARNING Bulletin Material Warrant 准备时间本路线适合于成都出发，周末游玩，2-3 天时间，2 天最好与周五晚出发。周五晚出发建议在泸定留宿，直接前往磨西古镇也可，需要多一个小时车程。注意 3 岁以下小朋友容易高反，带过去需要有人专职陪伴，备足氧气瓶，折多山上和去沿途有氧气卖。 物品清单氧气瓶血氧仪防滑链（时间定）墨镜巧克力葡萄糖鸭舌帽 路线推荐一天去一个选框中相关地点，标红为海拔高度，连线中为不堵时两地驾车时长。路线图采用 sketch 制作。路线图 主要地点海螺沟","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 康定周边 2 日 康定周边 2 日 准备 时间 物品清单 路线 主要地点 海螺沟 折多山 新都桥 BMW WARNING Bulletin Material Warrant 准备时间本路线适合于成都出发，周末游玩，2-3 天时间，2 天最好与周五晚出发。周五晚出发建议在泸定留宿，直接前往磨西古镇也可，需要多一个小时车程。注意 3 岁以下小朋友容易高反，带过去需要有人专职陪伴，备足氧气瓶，折多山上和去沿途有氧气卖。 物品清单氧气瓶血氧仪防滑链（时间定）墨镜巧克力葡萄糖鸭舌帽 路线推荐一天去一个选框中相关地点，标红为海拔高度，连线中为不堵时两地驾车时长。路线图采用 sketch 制作。路线图 主要地点海螺沟 海螺沟需要在磨西古镇买景区票，然后统一坐大巴，40 分钟左右经过山路，可以选到 3 号营地下或继续坐车到 4 号营地。大巴可选 3 号或 4 号营地下车。看冰川需要在 4 号营地坐缆车。不看冰川可以直接去 3 号营地去月牙湖和冰川舌，4 号营地不坐缆车没有其他游乐设施，需要徒步到 3 号营地，通过人工步道一路穿过林地，风景一般，时间紧可不去 4 号营地。海螺沟前往康定的沿途风景也不错，建议白天出发，沿途非常容易起雾，能见度非常低，路上不时出现趴在上面休息的牛羊，或有拦路的大块石头，起雾驾车需要特别小心。 折多山 折多山山腰处运气好可以拍到云海。折多山上雪景不错，需要备好墨镜和帽子。 新都桥新都桥镇看叶子上可打卡，镇上几处可能不是最漂亮的地方。看叶子最美的地方，由新都桥导航去红海子，在 318 和 434 省道有一段村路，看叶子不错，或者在过新都桥大桥之前的岔路去另一条路往前几公里。新都桥驾车前往红海子的路上 434 省道海拔高的路段容易起雾，且比较弯曲，需要注意。镇上吃烤肉烤全羊等需要晚上。 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"Husky使用","slug":"Husky使用","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"Husky使用.html","link":"","permalink":"http://www.skyline.show/Husky使用.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Husky 使用Husky 使用配置husky 简述husky 支持所有 git 相关钩子，在对应 git 操作触发时，可以执行测试、代码校验等相关任务。 以代码校验为例来说明 代码校验 lint-staged 相关配置如下 &#123; \"devDependencies\": &#123; \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;&#125; 后续代码中，其余配置为 husky 相关，通过这些配置，我们在 commit 代码时，会校验代码错误与格式，校验不通过会有提示。 Husky 在版本 5 中配置做了大变动，具体前后的配置以版本来说明。 V5+yarn add husky -D 安装 husky 最新包 npx husky-init &amp;&amp; yarn 在 package.json 会自动添加如下选项 &#123; \"scripts\": &#123; ..., \"prepare\": \"husky install\" &#125;, \"devDependencies\": &#123; \"husky\": \"^7.0.0\", \"lint-staged\": \"^11.1.2\", &#125;&#125; 汇总其他相关配置选项，如下package.json &#123; \"scripts\": &#123; ..., \"precommit\": \"lint-staged\", \"prepare\": \"husky install\" &#125;, \"devDependencies\": &#123; \"husky\": \"^7.0.0\", \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;&#125; 同时会在项目目录下自动生成 .husky 目录，包含最基础的 pre-commit bash 脚本，将 bash 脚本的默认 npm test 改为 npm run precommit 即可 pre-commit #!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"npm run precommit V4yarn add husky@v4.3.8 -D package.json &#123; ..., \"devDependencies\": &#123; ..., \"husky\": \"4.3.8\", \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;, \"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125; &#125;&#125; Husky 配置更新git hooks 说明","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Husky 使用Husky 使用配置husky 简述husky 支持所有 git 相关钩子，在对应 git 操作触发时，可以执行测试、代码校验等相关任务。 以代码校验为例来说明 代码校验 lint-staged 相关配置如下 &#123; \"devDependencies\": &#123; \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;&#125; 后续代码中，其余配置为 husky 相关，通过这些配置，我们在 commit 代码时，会校验代码错误与格式，校验不通过会有提示。 Husky 在版本 5 中配置做了大变动，具体前后的配置以版本来说明。 V5+yarn add husky -D 安装 husky 最新包 npx husky-init &amp;&amp; yarn 在 package.json 会自动添加如下选项 &#123; \"scripts\": &#123; ..., \"prepare\": \"husky install\" &#125;, \"devDependencies\": &#123; \"husky\": \"^7.0.0\", \"lint-staged\": \"^11.1.2\", &#125;&#125; 汇总其他相关配置选项，如下package.json &#123; \"scripts\": &#123; ..., \"precommit\": \"lint-staged\", \"prepare\": \"husky install\" &#125;, \"devDependencies\": &#123; \"husky\": \"^7.0.0\", \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;&#125; 同时会在项目目录下自动生成 .husky 目录，包含最基础的 pre-commit bash 脚本，将 bash 脚本的默认 npm test 改为 npm run precommit 即可 pre-commit #!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"npm run precommit V4yarn add husky@v4.3.8 -D package.json &#123; ..., \"devDependencies\": &#123; ..., \"husky\": \"4.3.8\", \"lint-staged\": \"^11.1.2\", &#125;, ..., \"lint-staged\": &#123; \"*.&#123;js,jsx,ts,tsx,vue&#125;\": \"eslint --cache --fix\" &#125;, \"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125; &#125;&#125; Husky 配置更新git hooks 说明 要配置 Git 钩子，只需要简单地在.git/hooks/目录下放对应钩子的可执行文件即可 通过 husky 简述中配置可以看到，husky 更新后配置似乎更加麻烦，如下探讨会为何会有去简就繁的操作。 V4 工作原理在 V4 版本及以前，为了可执行 .huskyrc.js 中配置的钩子， 在装 Husky 的时候，默认初始化了全部钩子在.git/hooks/ 中。例如，在执行 commit 时 ， husky/runner.js 会去检查 .huskyrc.js 中是否有对应的配置 $ git commitpre-commit (native) → husky/runner.js (node)→ is a pre-commit defined in `.huskyrc.js`? → YES, run itprepare-commit-msg (native) → husky/runner.js (node)→ is a prepare-commit-msg defined in `.huskyrc.js`? → NO, do nothingcommit-msg (native) → husky/runner.js (node)→ is a commit-msg defined in `.huskyrc.js`? → NO, do nothingpost-commit (native) → husky/runner.js (node)→ is a post-commit defined in `.huskyrc.js`? → NO, do nothing 初始所有了所有.git/hooks/ 钩子，这样的好处是用户随时可以在.huskyrc.js 中增减配置，缺点是对应钩子没有任何相应的配置时，.git/hooks/对应钩子仍旧存在，husky/runner.js 也仍旧会执行。考虑优化插件方向，如果 Husky 初始根据.huskyrc.js 只在.git/hooks/生成对应的配置考虑如下配置 // .huskyrc.jsmodule.exports = &#123; hooks: &#123; &apos;pre-commit&apos;: &apos;lint-staged&apos; &#125;&#125; .git/hooks/pre-commit ← is somehow created 后续有新的钩子需求 // .huskyrc.jsmodule.exports = &#123; hooks: &#123; // &apos;pre-commit&apos;: &apos;lint-staged&apos;, ← removed &apos;commit-msg&apos;: &apos;lint-staged&apos; ← added &#125;&#125; .git/hooks 目录下仍旧只存在 pre-commit 文件。本例中，如果我们只需要使用 pre-commit 钩子，删除.git/hooks/中其他钩子后程序依旧可以正常运行，但是后续在 .huskyrc.js 添加新钩子并不会在.git/hooks/自动生成对应钩子，新加的配置不会起任何作用。 如果要采用上述方式又不想初始化全部钩子，.huskyrc.js 配置与.git/hooks/ 中自动生成对应钩子文件，这就涉及 JS 与 Git 的配置同步问题。 V5+ 原理2016 年，Git 在 2.9 版本引入了 core.hooksPath. 让 Git hooks 的目录可以个性化定制。Husky 5+ 将相关钩子放置在项目.husky 目录下，默认只创建一个运行 npm test 的 pre-commit 钩子。用户不再去.huskyrc.js 配置钩子，而是需要手动运行 npx husky add .husky/commit-msg ‘npm test’ 添加新的钩子。husky install 更改 Git hooks 目录到 .husky/解决了非必要钩子初始化问题，默认只创建一个运行 npm test 的 pre-commit 钩子。husky add 提供后续添加新钩子的需求解决配置同步问题，不再去使用.huskyrc.js 或者在 package.json 中配置钩子，而是通过该命令直接在.husky 目录下生成） 后续问题引入.husky 目录，代码混乱?引入.huskyrc.js 也存在，.husky 支持统一放在 config 等指定目录下。作为 JS 库不用 JS 来配置？如 Jest, ESLint, Prettier 等用 .jestrc.js, .eslintrc.js, .prettierrc.js 来配置，它们全都是用纯 JS 写的。Husky 并不是纯 JS 开发，包含 Shell 脚本，与 Git 交互。 BMW WARNINGBulletinI am a bucolic migrant worker but I never walk backwards. Material Why husky has dropped conventional JS config Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[],"tags":[]},{"title":"Brook服务搭建与访问","slug":"Brook服务搭建与访问","date":"2022-01-20T07:47:16.000Z","updated":"2022-04-30T07:57:28.000Z","comments":true,"path":"Brook服务搭建与访问.html","link":"","permalink":"http://www.skyline.show/Brook服务搭建与访问.html","excerpt":"","text":"Brook 服务搭建与访问 Brook 服务搭建与访问 Server 配置 安装 后台运行 client Server 配置安装curl -L https://github.com/txthinking/brook/releases/latest/download/brook_linux_amd64 -o /usr/bin/brookchmod +x /usr/bin/brookbrook server --listen :9999 --password hello 后台运行vi /etc/systemd/system/brook.service 输入如下内容： [Unit]Description=brook vpn[Service]ExecStart=/usr/bin/brook server --listen :2000 --password mimaRestart=alwaysUser=root[Install]WantedBy=multi-user.target 要开启多个服务，只需要创建多个 service 文件监听不同端口即可。 重置守护进程服务 systemctl daemon-reload 开启服务 systemctl start brook 检查服务是否开启成功，查看 2000 端口是否开启服务即可。 netstat -anp | grep 2000 如上操作完成后，服务即后台启动成功。要想服务开机自启动，输入： systemctl enable brook 即可。 client在如下地址下载客户端界面：https://txthinking.github.io/brook/#/install-gui-client下载后连接成功如下图所示：","categories":[{"name":"APPs","slug":"APPs","permalink":"http://www.skyline.show/categories/APPs/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://www.skyline.show/tags/VPN/"},{"name":"VPN1","slug":"VPN1","permalink":"http://www.skyline.show/tags/VPN1/"}]},{"title":"ES对象属性","slug":"ES对象属性","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"ES对象属性.html","link":"","permalink":"http://www.skyline.show/ES对象属性.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 JS 对象的属性 JS 对象的属性 属性描述符 属性分类 Enumerable Configurable 属性创建 直接创建 Object.defineProperty() &amp; Object.defineProperties() Object.create 扩展、封印与冻结 preventExtensions seal freeze 屏蔽、检测与遍历 属性屏蔽 属性检测 属性遍历 BMW WARNING Bulletin Material Warrant 属性描述符属性分类 数据属性 Configurable Enumerable Writable Value 访问器属性 Configurable Enumerable Get Set EnumerableEnumerable 表示能否枚举，常见 ConfigurableConfigurable 表示能否删除属性，能否修改某些属性描述符，能否将属性改为访问器(数据)属性。 configurable 一旦指定为 false，则 configurable、enumerable、value、get、set 将无法通过 Object.defineProperty()重新配置，删除对应的属性将不产生效果（严格模式导致错误），属性将不能转换（数据与访问器之间） configurable 一旦指定为 false,此时的 Writable 如果是 true 则可以修改为 false，但是不能从 false 改为 true（只关不开） configurable true，writable false 时，可以通过 Object.defineProperty()修改 value 的值，直接赋值无效；configurable false，writable true 时可以通过赋值直接修改 value 的值，通过 Object.defineProperty()指定 value 值将会报错 数据属性能否重新直接赋值取决于 writable属性能否重新通过 defineProperty 定义属性描述与值以及被删除取决于 configurable 忽略 enumerable 为 false 属性的操作 属性创建直接创建","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 JS 对象的属性 JS 对象的属性 属性描述符 属性分类 Enumerable Configurable 属性创建 直接创建 Object.defineProperty() &amp; Object.defineProperties() Object.create 扩展、封印与冻结 preventExtensions seal freeze 屏蔽、检测与遍历 属性屏蔽 属性检测 属性遍历 BMW WARNING Bulletin Material Warrant 属性描述符属性分类 数据属性 Configurable Enumerable Writable Value 访问器属性 Configurable Enumerable Get Set EnumerableEnumerable 表示能否枚举，常见 ConfigurableConfigurable 表示能否删除属性，能否修改某些属性描述符，能否将属性改为访问器(数据)属性。 configurable 一旦指定为 false，则 configurable、enumerable、value、get、set 将无法通过 Object.defineProperty()重新配置，删除对应的属性将不产生效果（严格模式导致错误），属性将不能转换（数据与访问器之间） configurable 一旦指定为 false,此时的 Writable 如果是 true 则可以修改为 false，但是不能从 false 改为 true（只关不开） configurable true，writable false 时，可以通过 Object.defineProperty()修改 value 的值，直接赋值无效；configurable false，writable true 时可以通过赋值直接修改 value 的值，通过 Object.defineProperty()指定 value 值将会报错 数据属性能否重新直接赋值取决于 writable属性能否重新通过 defineProperty 定义属性描述与值以及被删除取决于 configurable 忽略 enumerable 为 false 属性的操作 属性创建直接创建 直接建立的布尔型属性描述默认都是 true var a = &#123; c: 1 &#125;;Object.getOwnPropertyDescriptor(a, \"c\");// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;a.d = 2;Object.getOwnPropertyDescriptor(a, \"d\");//&#123;value: 2, writable: true, enumerable: true, configurable: true&#125; Object.defineProperty() &amp; Object.defineProperties()通过 Object.defineProperty()来定义或者修改属性 Object.defineProperty()接受三个参数，分别是对象名，属性名，描述符对象。 数据属性描述符对象只接受 configurable、enumerable、writable、value 四种属性中的一个或多个;访问器属性描述符对象只接受 configurable、enumerable、get、set 四种属性中的一个或多个。 描述符对象不指定 configurable、enumerable、writable 时，他们的默认值是 false；不指定 value、get、set 时，默认值是 undefined在使用 defineProperty 时通常需要代码直接指定布尔型描述全为 true var a = &#123;&#125;;Object.defineProperty(a, \"name\", &#123; value: \"skyline\" &#125;);a; // &#123;name: \"skyline\"&#125;a.name = \"lala\";a; // &#123;name: \"skyline\"&#125; 修改不生效Object.defineProperty(a, \"name\", &#123; value: \"skyline\", writable: true &#125;); // Uncaught TypeError: Cannot redefine property: name writeable是false，无法再改为trueObject.defineProperty(a, \"age\", &#123; value: \"18\", configurable: true &#125;);a.age = 19; // 19 修改不生效a; // &#123;name: \"skyline\", age: \"18\"&#125;Object.defineProperty(a, \"age\", &#123; value: \"18\", writable: true &#125;);a.age = 19;a; // &#123;name: \"skyline\", age: 19&#125; 修改生效 Object.createObject.create 方法的第二个参数添加的对象属性，同样的，只指定 value 不指定其他将会导致 configurable、enumerable、writable 都是 false const obj = Object.create(&#123;&#125;, &#123; p: &#123; value: 1 &#125; &#125;);Object.values(obj); // []Object.getOwnPropertyDescriptor(obj, \"p\");//&#123;value: 1, writable: false, enumerable: false, configurable: false&#125; Object.getOwnPropertyDescriptor(s) 查看属性描述符 扩展、封印与冻结preventExtensionsObject.preventExtensions()禁止扩展，即防止对象添加新的属性，Object.isExtensible()检查是否可扩展 const object1 = &#123;&#125;;Object.preventExtensions(object1);try &#123; Object.defineProperty(object1, \"property1\", &#123; value: 42, &#125;);&#125; catch (e) &#123; console.log(e); // expected output: TypeError: Cannot define property property1, object is not extensible&#125; sealObject.seal()封印对象，防止对象添加新的属性，且将所有属性的 Configurable 置为 false Object.isSealed()检查是否被封印 freezeObject.freeze()冻结对象，防止对象添加新的属性，且将所有属性的 Configurable 置为 false ，数据属性的所有 writable 设置为 false，防止对象属性直接重新赋值， Object.isFrozen()检查是否被冻结 被冻结的对象一定被封印了；被封印的对象一定不能扩展。 当一个被封印的对象所有自有（实例）属性的描述符 writable 改为 false 时，那么此时它也是被冻结的，通过 isFrozen 返回 true 被冻结对象的访问器属性如果有 set 描述符，则它仍旧是可写的 屏蔽、检测与遍历属性屏蔽原型属性指存在于原型链上的属性。实例中创建与原型中同名的属性，会屏蔽原型中的属性值。delete 可以删除实例中的属性，来重新暴露原型中的属性 属性检测hasOwnProperty()来获取自有（实例）属性 in 操作符来确定属性是否存在于实例属性与原型链中 属性检测不受枚举与否影响 Detection const obj = Object.create(&#123;&#125;, &#123; p: &#123; value: 1 &#125; &#125;);Object.values(obj); // []Object.getOwnPropertyDescriptor(obj, \"p\");// &#123;value: 1, writable: false, enumerable: false, configurable: false&#125;\"p\" in obj; // true\"valueOf\" in obj; // trueobj.hasOwnProperty(\"p\"); // trueobj.hasOwnProperty(\"valueOf\"); // false 属性遍历for-in 语句遍历所有可枚举的自有（实例）和原型属性 Object.keys()只会收录自有可枚举属性名在数组中 Iteration const obj = Object.create(&#123;&#125;, &#123; p: &#123; value: 1 &#125; &#125;);Object.values(obj); // []Object.getOwnPropertyDescriptor(obj, \"p\");// &#123;value: 1, writable: false, enumerable: false, configurable: false&#125;Object.getOwnPropertyNames(obj); //[\"p\"]Object.keys(obj); // [] 常见方法需要可枚举，非常见不限制枚举 BMW WARNINGBulletinI am a bucolic migrant worker but I never walk backwards. Material 《JavaScript 高级程序设计》 Warrant 本文作者： Skyline(lty)版权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！","categories":[],"tags":[]},{"title":"Number相关基础操作","slug":"Number相关基础操作","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"Number相关基础操作.html","link":"","permalink":"http://www.skyline.show/Number相关基础操作.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Number 相关基础操作 Number 相关基础操作 保留小数 四舍五入 不取舍 添加千位分隔符 toLocaleString 正则 保留小数四舍五入toFixed (2.123123123).toFixed(3); // 输出结果为 2.123(2.123923123).toFixed(3); // 输出结果为 2.124 toLocaleStringtoLocaleString 默认保留 3 位小数，且会产生千位分隔符 (12332.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '12,332.123923' 可通过 minimumFractionDigits，maximumFractionDigits 来指定保留参数的长度 (2.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '2.123923' 不取舍Math.floor Math.floor(15.7784514 * 1000) / 1000; // \b输出结果为 15.778 添加千位分隔符toLocaleString通过 toLocaleString 很容易直接添加千位。 (1231234234234).toLocaleString(\"en-US\");// '1,231,234,234,234' (1231234234234).toLocaleString();// '1,231,234,234,234' toLocaleString 将字符本地串化，第一个参数为串化标准，默认为’en-US’。对于小数而言，其会四舍五入保留 3 位 正则","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Number 相关基础操作 Number 相关基础操作 保留小数 四舍五入 不取舍 添加千位分隔符 toLocaleString 正则 保留小数四舍五入toFixed (2.123123123).toFixed(3); // 输出结果为 2.123(2.123923123).toFixed(3); // 输出结果为 2.124 toLocaleStringtoLocaleString 默认保留 3 位小数，且会产生千位分隔符 (12332.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '12,332.123923' 可通过 minimumFractionDigits，maximumFractionDigits 来指定保留参数的长度 (2.123923123).toLocaleString(undefined, &#123; minimumFractionDigits: 5, maximumFractionDigits: 6,&#125;);// 输出结果为 '2.123923' 不取舍Math.floor Math.floor(15.7784514 * 1000) / 1000; // \b输出结果为 15.778 添加千位分隔符toLocaleString通过 toLocaleString 很容易直接添加千位。 (1231234234234).toLocaleString(\"en-US\");// '1,231,234,234,234' (1231234234234).toLocaleString();// '1,231,234,234,234' toLocaleString 将字符本地串化，第一个参数为串化标准，默认为’en-US’。对于小数而言，其会四舍五入保留 3 位 正则 (1231234234234 + \"\").replace(/(\\d)(?=(\\d&#123;3&#125;)+$)/g, \"$1,\");//'1,231,234,234,234' 设计正则解析 +匹配前面一个表达式 1 次或者多次。等价于{1,}。 x(?=y)匹配 x 仅仅当 x 后面跟着 y。这种叫做先行断言。 整个正则的意思为后面跟有三个或三的倍数个连续数字的数后面加上逗号","categories":[],"tags":[]},{"title":"Shadowsocks服务搭建与访问","slug":"Shadowsocks服务搭建与访问","date":"2022-01-20T07:47:16.000Z","updated":"2022-01-20T07:47:16.000Z","comments":true,"path":"Shadowsocks服务搭建与访问.html","link":"","permalink":"http://www.skyline.show/Shadowsocks服务搭建与访问.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Shadowsocks 服务搭建与访问 Shadowsocks 服务搭建与访问 SS server 安装 配置文件 开启服务 开机启动 SS client 添加自定代理规则 常见问题 配置完成无法访问墙外 SYN_RECV IP或端口被封 BMW WARNING Bulletin Material Warrant SS server安装SS server 服务端有多语言版本支持此处采用 python 版本首先安装 pip 包管理器 Debian / Ubuntu apt-get install python-pip CentOS sudo yum install epel-release # 添加Enterprise Linux企业源sudo yum install python-pip 查看是否安装成功 pip --version# pip 8.1.2 from /usr/lib/python2.7/site-packages (python 2.7) 然后直接输入以下命令安装 sudo pip install shadowsocks 配置文件新增配置文件/etc/shadowsocks.json &#123; \"server\": \"23.234.212.12\", \"port_password\": &#123; \"8388\": \"123\", \"8389\": \"456\" &#125;, \"timeout\": 300, \"method\": \"rc4-md5\", \"fast_open\": false, \"workers\": 1&#125; 参数 含义 server vps ip 地址 port_password 服务端口和对应密码 method 加密方法 workers 线程数 开启服务调用命令开启服务。相关命令如下 指定配置文件开启服务 sudo ssserver -c /etc/shadowsocks.json -d start 指定配置文件重启 sudo ssserver -c /etc/shadowsocks.json -d restart 关闭服务 sudo ssserver -d stop 开机启动","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Shadowsocks 服务搭建与访问 Shadowsocks 服务搭建与访问 SS server 安装 配置文件 开启服务 开机启动 SS client 添加自定代理规则 常见问题 配置完成无法访问墙外 SYN_RECV IP或端口被封 BMW WARNING Bulletin Material Warrant SS server安装SS server 服务端有多语言版本支持此处采用 python 版本首先安装 pip 包管理器 Debian / Ubuntu apt-get install python-pip CentOS sudo yum install epel-release # 添加Enterprise Linux企业源sudo yum install python-pip 查看是否安装成功 pip --version# pip 8.1.2 from /usr/lib/python2.7/site-packages (python 2.7) 然后直接输入以下命令安装 sudo pip install shadowsocks 配置文件新增配置文件/etc/shadowsocks.json &#123; \"server\": \"23.234.212.12\", \"port_password\": &#123; \"8388\": \"123\", \"8389\": \"456\" &#125;, \"timeout\": 300, \"method\": \"rc4-md5\", \"fast_open\": false, \"workers\": 1&#125; 参数 含义 server vps ip 地址 port_password 服务端口和对应密码 method 加密方法 workers 线程数 开启服务调用命令开启服务。相关命令如下 指定配置文件开启服务 sudo ssserver -c /etc/shadowsocks.json -d start 指定配置文件重启 sudo ssserver -c /etc/shadowsocks.json -d restart 关闭服务 sudo ssserver -d stop 开机启动 vi /etc/rc.local 然后将如下开启服务的命令添加进去即可。 ssserver -c /etc/shadowsocks.json -d start SS client在如下位置新增服务配置与服务端配置对应选择全局或者 PAC 模式，浏览器输入科学上网网址即可 添加自定代理规则部分网站国内访问较慢，但是 PAC 规则中没有，可以添加用户自定义规则点击 Edit User Rules For PAC添加规则如下 ! Put user rules line by line in this file.! See https://adblockplus.org/en/filter-cheatsheet“||https://github.com/^”,“||https://raw.githubusercontent.com^” 注意逗号和引号不要遗漏 常见问题配置完成无法访问墙外 IP 检查 检查 vps ip 是否被封在http://ping.pe/下输入ip 异常情况正常情况下面部分为绿色 ip 异常需要向 vps 提供商发起工单。 防火墙检查 若 ip 正常，检查 vps 防火墙。CentOS7 等版本默认防火墙非常严格，一般端口都屏蔽都外部访问。关闭防火墙测试是否能访问centos7 关闭防火墙使用如下命令 sudo systemctl stop firewalld 检查是否可正常访问。若是防火墙问题，暴露对应端口即可，不要关闭防火墙。 打开防火墙的命令 sudo systemctl start firewalld 暴露端口段 firewall-cmd --permanent --add-port 8300-8400/tcp 或直接指定端口 firewall-cmd --permanent --add-port 1191/tcp 暴露后需要重启防火墙 firewall-cmd --reload 查看暴露的端口 firewall-cmd --list-ports# 8300-8400/tcp SYN_RECV通过netstat -anp | grep 88 grep后接自己暴露的端口前缀。 可以看到，有大量tcp处于SYN_RECV状态。这是由于TCP最后一次握手回传的ACK包丢失导致。大概率由于GFW嗅探到当前连接导致。可以进行如下尝试。更换端口，查看可否访问更换不同网络ISP（移动、联通、电信等）尝试。这时，最好尝试用其他方法搭建服务 IP或端口被封BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"黑群晖常见问题","slug":"黑群晖常见问题","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"黑群晖常见问题.html","link":"","permalink":"http://www.skyline.show/黑群晖常见问题.html","excerpt":"","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 黑群晖常见问题 黑群晖常见问题 黑群晖搜索不到IP 网络联通检查 网卡驱动问题 SSD缓存 Moments 人物、主题无照片 黑群晖搜索不到IP网络联通检查主板网口灯检查检查主板网口灯，绿灯常亮说明网络连接成功，黄灯闪烁说明有流量传输。若绿灯亮，进入下一步。 网卡驱动问题检查网卡配置，黑群晖默认不支持2.5G以及万兆网卡，需要替换引导中的网卡驱动文件。直接GoogleDS918+ 6.23 &quot;0.13.3&quot;找到DS918-6.23_1.04b的扩展驱动0.13.3.zip解压得到进行两个文件extra.lzma extra2.lzma然后替换[^1]。用 DiskGenius 打开启动 U 盘。在左侧目录下可以看到一个 分区(1)，右键选择”挂载到 windows”。然后选择确定之后。可以发现这个分区出现在文件管理那边。用上述解压得到的文件替换分区里的文件即可。然后退出 U 盘，重新启动，就能支持 2.5G 网卡了[^1]:https://post.smzdm.com/p/aoxd6697/ SSD缓存不打补丁的情况下，黑群晖默认不识别SSDSSD补丁如下版本 | 补丁 | 操作— | — | —6.22 | libNVMEpatch.sh | 将 libNVMEpatch.sh 移动到/usr/local/etc/rc.d/ 下sudo 赋读写执行权限 sudo chmod 755 libNVMEpatch.sh6.23 | libsynonvme.so.1 | 将 libNVMEpatch.sh 移动到/usr/local/etc/rc.d/ 下sudo 赋读写执行权限 sudo chmod 755 libNVMEpatch.sh 上述操作需要先远程ssh user@ip ，操作完成后退出重启即可[^2][^2]:https://wp.gxnas.com/6010.html Moments 人物、主题无照片安装Moments后人物与主题无法智能识别，进入后显示还有xxx张照片待发现。停用Moments进入 /var/packages/SynologyMoments/target/usr/lib 目录下备份 libsynophoto-plugin-detection.somv ./libsynophoto-plugin-detection.so ./libsynophoto-plugin-detection.so.bak libsynophoto-plugin-detection.so将下载的新文件放在 /var/packages/SynologyMoments/target/usr/lib下，对全部用户赋完全权限（777）或对SynologyMoments赋控制权限（755）。开启moments，重建索引。","categories":[],"tags":[]},{"title":"CentOS防火墙","slug":"CentOS防火墙","date":"2022-01-20T07:47:15.000Z","updated":"2022-06-02T03:35:11.000Z","comments":true,"path":"CentOS防火墙.html","link":"","permalink":"http://www.skyline.show/CentOS防火墙.html","excerpt":"firewalld Concepts Zones Services Runtime State Port Source BMW WARNING Bulletin Material Warrant firewalldConceptsfirewalld[^1] 采用区域与服务的概念来控制流量的出入。 zones services firewalld 是 CentOS 7/8, Red Hat Enterprise Linux 7 (RHEL 7), Fedora 18+等 Linux 发行版本默认防火墙程序。其命令行工具为 firewall-cmd Zoneszones 预设级别不同的防火墙策略，用户可以自定义 zones，也可以使用预设的 zones。默认使用 public zone根据拦截级别严格程度，预设 zones 如下 zone 拦截说明 drop 丢弃区，所有接入连接都会进行无消息响应拦截，只有输出连接被允许。 block 拦截区，接入连接都会被拦截，会响应 icmp-host-prohibited 等拦截消息，只有输出连接被允许。 public 公共区，用于不受信任的公共区域，仅允许自选接入连接，默认允许 ssh 和 dhcpv6-client external 外部区，用于外部网络，系统充当网关角色，仅允许自选接入连接，默认允许 ssh internal 内部区，用于内部网络，系统充当网关角色，仅允许自选接入连接 dmz 隔离区，demilitarized zone（隔离区，军事缓冲区），用于允许部分服务被外网访问，仅允许自选接入连接 work 工作区，用于工作网络，信任网络中其他机器，仅允许自选接入连接，默认允许 ssh，ipp-client 和 dhcpv6-client home 家庭区，用于工作家庭网络，信任网络中其他机器，仅允许自选接入连接，默认允许 ssh，ipp-client，mdns，samba-client 和 dhcpv6-client trusted 信任区，并接受所有网络连接 新建防火墙区域策略 sudo firewall-cmd --new-zone=memcached --permanent 查看系统默认区 sudo firewall-cmd --get-default-zone# public 调整系统默认区 sudo firewall-cmd --set-default-zone=home 系统中配置的所有区 sudo firewall-cmd --get-zones# block dmz drop external home internal public trusted work sudo firewall-cmd --list-all-zones# 上述命令会打印所有区与其详细的配置，输出内容较长 查看系统使用区 sudo firewall-cmd --get-active-zones# public# interfaces: eth0 eth1 查看指定区的详细配置 sudo firewall-cmd --zone=public --list-all# public (active)# target: default# icmp-block-inversion: no# interfaces: eth0 eth1# sources:# services: ssh dhcpv6-client# ports:# protocols:# masquerade: no# forward-ports:# source-ports:# icmp-blocks:# rich rules: Servicesservices 在 zones 中为不同的服务预设不同的配置。例如，可以为服务提供不同的端口等配置 查看所有的服务 sudo firewall-cmd --get-services# RH-Satellite-6 RH-Satellite-6-capsule amanda-client amanda-k5-client amqp amqps... git... ssh ...dhcpv6-client 查看当前开放的服务 sudo firewall-cmd --list-services# dhcpv6-client ssh 增加开放服务 sudo firewall-cmd --zone=public --add-service=http 移除开放的服务 sudo firewall-cmd --zone=public --remove-service=http# 永久配置需要添加 --permanent后缀 所有服务的配置都在/usr/lib/firewalld/services 目录下例如 http 服务的配置为 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;service&gt; &lt;short&gt;WWW (HTTP)&lt;/short&gt; &lt;description&gt;HTTP is the protocol used to serve Web pages. If you plan to make your Web server publicly available, enable this option. This option is not required for viewing pages locally or developing Web pages.&lt;/description&gt; &lt;port protocol=\"tcp\" port=\"80\"/&gt;&lt;/service&gt; 自定义服务 sudo cp /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/diyservice.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;service version=\"1.0\"&gt;&lt;short&gt;diyservice&lt;/short&gt;&lt;description&gt;Plex is a streaming media server that brings all your video, music and photo collections together and stream them to your devices at anytime and from anywhere.&lt;/description&gt;&lt;port protocol=\"udp\" port=\"1900\"/&gt;&lt;port protocol=\"tcp\" port=\"32400\"/&gt;&lt;/service&gt; 重启防火墙后就可以看到该服务。 Runtime","text":"firewalld Concepts Zones Services Runtime State Port Source BMW WARNING Bulletin Material Warrant firewalldConceptsfirewalld[^1] 采用区域与服务的概念来控制流量的出入。 zones services firewalld 是 CentOS 7/8, Red Hat Enterprise Linux 7 (RHEL 7), Fedora 18+等 Linux 发行版本默认防火墙程序。其命令行工具为 firewall-cmd Zoneszones 预设级别不同的防火墙策略，用户可以自定义 zones，也可以使用预设的 zones。默认使用 public zone根据拦截级别严格程度，预设 zones 如下 zone 拦截说明 drop 丢弃区，所有接入连接都会进行无消息响应拦截，只有输出连接被允许。 block 拦截区，接入连接都会被拦截，会响应 icmp-host-prohibited 等拦截消息，只有输出连接被允许。 public 公共区，用于不受信任的公共区域，仅允许自选接入连接，默认允许 ssh 和 dhcpv6-client external 外部区，用于外部网络，系统充当网关角色，仅允许自选接入连接，默认允许 ssh internal 内部区，用于内部网络，系统充当网关角色，仅允许自选接入连接 dmz 隔离区，demilitarized zone（隔离区，军事缓冲区），用于允许部分服务被外网访问，仅允许自选接入连接 work 工作区，用于工作网络，信任网络中其他机器，仅允许自选接入连接，默认允许 ssh，ipp-client 和 dhcpv6-client home 家庭区，用于工作家庭网络，信任网络中其他机器，仅允许自选接入连接，默认允许 ssh，ipp-client，mdns，samba-client 和 dhcpv6-client trusted 信任区，并接受所有网络连接 新建防火墙区域策略 sudo firewall-cmd --new-zone=memcached --permanent 查看系统默认区 sudo firewall-cmd --get-default-zone# public 调整系统默认区 sudo firewall-cmd --set-default-zone=home 系统中配置的所有区 sudo firewall-cmd --get-zones# block dmz drop external home internal public trusted work sudo firewall-cmd --list-all-zones# 上述命令会打印所有区与其详细的配置，输出内容较长 查看系统使用区 sudo firewall-cmd --get-active-zones# public# interfaces: eth0 eth1 查看指定区的详细配置 sudo firewall-cmd --zone=public --list-all# public (active)# target: default# icmp-block-inversion: no# interfaces: eth0 eth1# sources:# services: ssh dhcpv6-client# ports:# protocols:# masquerade: no# forward-ports:# source-ports:# icmp-blocks:# rich rules: Servicesservices 在 zones 中为不同的服务预设不同的配置。例如，可以为服务提供不同的端口等配置 查看所有的服务 sudo firewall-cmd --get-services# RH-Satellite-6 RH-Satellite-6-capsule amanda-client amanda-k5-client amqp amqps... git... ssh ...dhcpv6-client 查看当前开放的服务 sudo firewall-cmd --list-services# dhcpv6-client ssh 增加开放服务 sudo firewall-cmd --zone=public --add-service=http 移除开放的服务 sudo firewall-cmd --zone=public --remove-service=http# 永久配置需要添加 --permanent后缀 所有服务的配置都在/usr/lib/firewalld/services 目录下例如 http 服务的配置为 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;service&gt; &lt;short&gt;WWW (HTTP)&lt;/short&gt; &lt;description&gt;HTTP is the protocol used to serve Web pages. If you plan to make your Web server publicly available, enable this option. This option is not required for viewing pages locally or developing Web pages.&lt;/description&gt; &lt;port protocol=\"tcp\" port=\"80\"/&gt;&lt;/service&gt; 自定义服务 sudo cp /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/diyservice.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;service version=\"1.0\"&gt;&lt;short&gt;diyservice&lt;/short&gt;&lt;description&gt;Plex is a streaming media server that brings all your video, music and photo collections together and stream them to your devices at anytime and from anywhere.&lt;/description&gt;&lt;port protocol=\"udp\" port=\"1900\"/&gt;&lt;port protocol=\"tcp\" port=\"32400\"/&gt;&lt;/service&gt; 重启防火墙后就可以看到该服务。 Runtime Firewalld 提供运行时与永久两种配置有效期限。 runtime permanent runtime 只有当次开机有效，重启会恢复到默认配置，permanent 会让配置永久生效。默认指定防火墙相关配置时使用的是 runtime。要让指定的配置永久有效，需要指定 –permanent sudo firewall-cmd &lt;options&gt; 上述配置生效后只在 runtime 有效 要使其永久有效 sudo firewall-cmd --permanent &lt;options&gt; 使当前 runtime 的所有配置永久有效 sudo firewall-cmd --runtime-to-permanent 要让配置立即生效，需要重启进程 sudo firewall-cmd --reload State 查看防火墙状态 firewall-cmd --state# running #打开状态# not running #关闭状态 防火墙完整信息 firewall-cmd --list-all# public (active)# target: default# icmp-block-inversion: no# interfaces: eth0# sources:# services: dhcpv6-client ssh# ports:# protocols:# masquerade: no# forward-ports:# source-ports:# icmp-blocks:# rich rules: 临时关闭防火墙 sudo systemctl stop firewalld 上述操作只对当前运行时有效 永久关闭防火墙 sudo systemctl stop firewalld 零时关闭防火墙并防止开机重启 sudo systemctl disable firewalld# Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.# Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. 防止其他程序启动防火墙 sudo systemctl mask --now firewalld# Created symlink from /etc/systemd/system/firewalld.service to /dev/null. 打开防火墙 sudo systemctl start firewalld Port 暴露端口段 firewall-cmd --permanent --add-port 8300-8400/tcp 协议可选 tcp, udp, sctp, or dccp 暴露端口 firewall-cmd --permanent --add-port 1191/tcp 临时暴露需要去除 --permanent，重启后端口暴露将会失效。执行暴露端口的命令后，需要重启防火墙 firewall-cmd --reload 查看暴露的端口 firewall-cmd --list-ports# 8300-8400/tcp 移除暴露的端口 firewall-cmd --remove-port 8300-8400/tcp --permanent 注意开启时添加了--permanent，关闭时也需要 查询允许暴露端口的服务 sudo firewall-cmd --list-services# ssh dhcpv6-client http Source 指定允许访问的 IP sudo firewall-cmd --zone=public --add-source=192.168.100.30/32 --permanent# sudo firewall-cmd --add-source=192.168.100.30 --permanent 查看允许访问的 IP sudo firewall-cmd --zone=public --list-sources 移除指定的 IP sudo firewall-cmd --zone=public --remove-source=192.168.1.10 转发 在进行转发前，需要开启转发支持 sudo firewall-cmd --zone=external --add-masquerade --permanent 同主机 sudo firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toport=8080 上述命令会把 80 端口的 tcp 全部转发到当前服务器的 8080 端口 转发到其他主机 sudo firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toaddr=10.10.10.2 上述命令会把 80 端口的 tcp 全部转发到服务器 10.10.10.2 的 80 端口[^1]: 本节命令在 centos7 下验证 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://linuxize.com/post/how-to-configure-and-manage-firewall-on-centos-8/ Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.skyline.show/categories/Tools/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.skyline.show/tags/OS/"},{"name":"Linux","slug":"Linux","permalink":"http://www.skyline.show/tags/Linux/"}]},{"title":"Nginx基础","slug":"Nginx基础","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"Nginx基础.html","link":"","permalink":"http://www.skyline.show/Nginx基础.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Nginx 基础 Nginx 基础 location 基础使用 URL-match modifier proxy_pass 简述 URI / 问题 \\$uri \\$request_uri BMW WARNING Bulletin Material Warrant location基础使用location 位于 server 下或位于另一个 location 中，基本使用如下 location [modifier] [URL-match] &#123; ...&#125; URL-match匹配所有路径 location / &#123;&#125; 优先级最低，所有都不匹配时，才会命中 modifierURI 这里指 URL 除了 server:port 的部分。 命中优先级优先级由上依次降低。 modifier desc example = exact (精确匹配) location = /site ^~ priority prefix (优先字符) location ^~ /site ~ case sensitive regex (大小写敏感正则) location ~ /site ~* case insensitive regex(忽略大小写) location ~* /site (none) prefix(字符匹配，无修饰符，由 URI 头字符开始匹配) location /site 在如下网址可进行匹配测试 https://nginx.viraptor.info/ ^~ 与(none)都 进行字符匹配（非正则），^~ 相对于(none) ，提高了命中优先级。 典型示例 示例 1 location ^~ /file/* &#123; proxy_pass http://bbb.com/;&#125; ^~ 进行字符匹配http://domain2.com/file/* 可以命中http://domain2.com/file/1 不能命中 示例 2 location ~ /file/* &#123; proxy_pass http://bbb.com/;&#125;location ^~ /file/ &#123; proxy_pass http://bbb.com/;&#125; http://domain2.com/file/1 根据优先级命中^~ /file/ proxy_pass简述","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Nginx 基础 Nginx 基础 location 基础使用 URL-match modifier proxy_pass 简述 URI / 问题 \\$uri \\$request_uri BMW WARNING Bulletin Material Warrant location基础使用location 位于 server 下或位于另一个 location 中，基本使用如下 location [modifier] [URL-match] &#123; ...&#125; URL-match匹配所有路径 location / &#123;&#125; 优先级最低，所有都不匹配时，才会命中 modifierURI 这里指 URL 除了 server:port 的部分。 命中优先级优先级由上依次降低。 modifier desc example = exact (精确匹配) location = /site ^~ priority prefix (优先字符) location ^~ /site ~ case sensitive regex (大小写敏感正则) location ~ /site ~* case insensitive regex(忽略大小写) location ~* /site (none) prefix(字符匹配，无修饰符，由 URI 头字符开始匹配) location /site 在如下网址可进行匹配测试 https://nginx.viraptor.info/ ^~ 与(none)都 进行字符匹配（非正则），^~ 相对于(none) ，提高了命中优先级。 典型示例 示例 1 location ^~ /file/* &#123; proxy_pass http://bbb.com/;&#125; ^~ 进行字符匹配http://domain2.com/file/* 可以命中http://domain2.com/file/1 不能命中 示例 2 location ~ /file/* &#123; proxy_pass http://bbb.com/;&#125;location ^~ /file/ &#123; proxy_pass http://bbb.com/;&#125; http://domain2.com/file/1 根据优先级命中^~ /file/ proxy_pass简述 proxy_pass 通常位于 location 下，用于接口转发。 URI一般把 server:port 后的部分叫做 URI，proxy_pass 在其后加不加 URI 表现完全不同。location 非正则匹配时，对于 proxy_pass 有如下规则：proxy_pass 有 URI替换请求中匹配的 URI 并替换成 proxy_pass 中的 URI 并向上游服务转发。 location /file &#123; proxy_pass http://bbb.com/src;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com/src/search location /file &#123; proxy_pass http://bbb.com/;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com//search proxy_pass 无 URI保留请求 URI 并将其转发到上游服务 location /file &#123; proxy_pass http://bbb.com;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com/file/search location 为正则匹配时，由于 nginx 不知道替换哪些字符，proxy_pass 的 URI 不起作用，保留原 URI，转发到上上游服务 location ~ /file &#123; proxy_pass http://bbb.com/src;&#125; http://aaa.com/file/search 真实访问地址为http://bbb.com/file/search / 问题location 非正则匹配时，当 proxy_pass 有 URI 时，需要注意 URI 的尾斜杠，具体表现为如下location 正则匹配时，不需要考虑 proxy_pass 的 URI location proxy_pass Request Received by upstream /file/ http://bbb.com/src/ /file/search?name=baz /src/search?name=baz /file/ http://bbb.com/src /file/search?name=baz /srcsearch?name=baz /file http://bbb.com/src/ /file/search?name=baz /src//search?name=baz /file http://bbb.com/src /file/search?name=baz /src/search?name=baz /file http://bbb.com/src /filesearch?name=baz /srcsearch?name=baz ~ /file/ http://bbb.com/src/[^1] /file/search?name=baz /file/search?name=baz ~ /file/search/(.*)$ http://bbb.com/src?name=$1[^1] /file/search/baz /src?name=baz ~ /file/ http://bbb.com /file/search?name=baz /file/search?name=baz location 正则匹配保留 Request 原始 URI非正则（前缀）匹配时，proxy_pass 有 URI 直接用 该 URI 替换 Request 中 URI 与 location 对应的字符，无 URI 则保留 Request 原始 URI 总之一句话location 采用字符前缀匹配时 proxy_pass 中的 URI 替换原始 URI [^1]: 较新版的 nginx 不支持正则中的 proxy_pass 有 URI(指纯字符 URI，经过测试，包含变量如$1等时可以)，会报错。&quot;proxy_pass&quot; cannot have URI part in location given by regular expression, or inside named location, or inside &quot;if&quot; statement, or inside &quot;limit_except&quot; block \\$uri \\$request_uri要同时保留 location 与 proxy_pass 的 URI 需要使用前缀匹配的同时用到 $uri 或$request_uri两者区别是$uri 不会保留请求中的路由参数具体如下 location proxy_pass Request Received by upstream /file/ http://bbb.com/src$uri /file/search?name=baz /src/file/search /file/ http://bbb.com/src$request_uri /file/search?name=baz /src/file/search?name=baz 注意$uri与$request_uri 自带头斜杠 BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 https://nginx.viraptor.info/ https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"MacOS基本操作","slug":"MacOS基本操作","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"MacOS基本操作.html","link":"","permalink":"http://www.skyline.show/MacOS基本操作.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 MacOS 基础使用 MacOS 基础使用 Macos Beta 系统更新开启 网络磁盘映射 剪切（移动） 常规 快捷键 直接删除文件 修改终端用户名 启用 SSD 的 TRIM 支持 关闭 SIP 设定文件默认打开方式 常规 其他方式 打开允许未知来源 app 选项 设定快捷打开程序快捷键 设置 automator 任务 设置程序打开快捷键 Macos Beta 系统更新开启在apple beta 地址上登录https://beta.apple.com 在如下网站下载 MacOS Public Beta Access Utility工具注意开启前在Time Mechine中进行系统备份下载工具安装后即可开启。 网络磁盘映射在 finder 下操作 ⌘ + k在弹出框中输入网络共享服务地址一般有 Samba 或 AFP 等方式共享服务常见地址如下 afp://192.168.2.20smb://192.168.2.20 剪切（移动）常规复制需要移动的文件。在目标位置右击鼠标，一般出现粘贴项目选项。此时按住 ⌥ 键，菜单会变为将项目移动到此处。 快捷键⌘ + c⌘ + ⌥ + v ⌘ + c 复制文件在目标目录 ⌘ + ⌥ + v 即可移动成功 直接删除文件放进垃圾桶【Command】+【Backspace】/【Delete】永久删除【Option】+【Command】+【Backspace】/【Delete】 修改终端用户名修改前图示 输入sudo scutil --set HostName &lt;name&gt;改后图示 启用 SSD 的 TRIM 支持mac 更换非官方固态和默认不启动 TRIM 硬盘优化，可输入sudo trimforce enable打开 关闭 SIPmac 关闭系统完整性保护 System Integrity Protection重启时，出现 apple logo 时按住⌘+R进入恢复模式点击工具中的终端输入csrutil disable输出Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.表示关闭 SIP 成功开启命令为csrutil enable 设定文件默认打开方式常规按住 option 键，鼠标右击，查看菜单栏变化 其他方式","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 MacOS 基础使用 MacOS 基础使用 Macos Beta 系统更新开启 网络磁盘映射 剪切（移动） 常规 快捷键 直接删除文件 修改终端用户名 启用 SSD 的 TRIM 支持 关闭 SIP 设定文件默认打开方式 常规 其他方式 打开允许未知来源 app 选项 设定快捷打开程序快捷键 设置 automator 任务 设置程序打开快捷键 Macos Beta 系统更新开启在apple beta 地址上登录https://beta.apple.com 在如下网站下载 MacOS Public Beta Access Utility工具注意开启前在Time Mechine中进行系统备份下载工具安装后即可开启。 网络磁盘映射在 finder 下操作 ⌘ + k在弹出框中输入网络共享服务地址一般有 Samba 或 AFP 等方式共享服务常见地址如下 afp://192.168.2.20smb://192.168.2.20 剪切（移动）常规复制需要移动的文件。在目标位置右击鼠标，一般出现粘贴项目选项。此时按住 ⌥ 键，菜单会变为将项目移动到此处。 快捷键⌘ + c⌘ + ⌥ + v ⌘ + c 复制文件在目标目录 ⌘ + ⌥ + v 即可移动成功 直接删除文件放进垃圾桶【Command】+【Backspace】/【Delete】永久删除【Option】+【Command】+【Backspace】/【Delete】 修改终端用户名修改前图示 输入sudo scutil --set HostName &lt;name&gt;改后图示 启用 SSD 的 TRIM 支持mac 更换非官方固态和默认不启动 TRIM 硬盘优化，可输入sudo trimforce enable打开 关闭 SIPmac 关闭系统完整性保护 System Integrity Protection重启时，出现 apple logo 时按住⌘+R进入恢复模式点击工具中的终端输入csrutil disable输出Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect.表示关闭 SIP 成功开启命令为csrutil enable 设定文件默认打开方式常规按住 option 键，鼠标右击，查看菜单栏变化 其他方式 第一步：右键单击该文件，然后选择「显示简介」选项。第二步：找到「打开方式」项目，点击倒三角选择你想指定的默认应用程序。第三步：单击「全部更改」按钮即可生效 打开允许未知来源 app 选项sudo spctl --master-disable 设定快捷打开程序快捷键设置 automator 任务如下动态图所示 设置程序打开快捷键","categories":[],"tags":[]},{"title":"frp内网穿透","slug":"frp内网穿透","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"frp内网穿透.html","link":"","permalink":"http://www.skyline.show/frp内网穿透.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 frp 内网穿透简介frp 是一款开源的内网穿透软件，github 主页为：https://github.com/fatedier/frp其架构如下图所示： Server 端下载包在 Release 页面下载服务器 CPU 架构对应的版本 https://github.com/fatedier/frp/releases如果不知道，可以通过 lscpu 命令查看，一般为 arm_64 位或 X86_64 位。确定后通过 weget 命令下载。如 X86_64 对应下载为 weget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_freebsd_amd64.tar.gz github国内速度较慢，也可通过迅雷等工具下载到本地后通过 SecureCRT 等工具上传. 试运行tar -zxvf frp_0.38.0_linux_amd64.tar.gz 解压成功后打开目录下的 frps.ini 文件，修改如下 [common]bind_port = 7000token = mima 尝试启动服务 ./frps -c frps.ini 成功一般有 success 提示信息，如果遇到 Segmentation fault 错误，检查下载的包版本是否有错。 后台运行服务创建服务文件：touch /etc/systemd/system/frp.service 修改 frp.service 内容如下： [Unit]Description=FRP serviceAfter=network.target syslog.targetWants=network.target[Service]ExecStart=/root/apps/frp/frps -c /root/apps/frp/frps.iniRestart=alwaysUser=root[Install]WantedBy=multi-user.target 重置守护进程服务 systemctl daemon-reload 开启服务 systemctl start frp 检查服务是否开启成功，查看 7000 端口是否开启服务即可。 netstat -anp | grep 7000 注意，此处需要在服务器提供网站对应的配置处将 7000 端口的防火墙限制打开，centos 等系统下，注意 firewalld 是否开放防火墙端口。如上操作完成后，服务即后台启动成功。要想服务开机自启动，输入：systemctl enable frp 即可。 Client 端frpc配置","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 frp 内网穿透简介frp 是一款开源的内网穿透软件，github 主页为：https://github.com/fatedier/frp其架构如下图所示： Server 端下载包在 Release 页面下载服务器 CPU 架构对应的版本 https://github.com/fatedier/frp/releases如果不知道，可以通过 lscpu 命令查看，一般为 arm_64 位或 X86_64 位。确定后通过 weget 命令下载。如 X86_64 对应下载为 weget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_freebsd_amd64.tar.gz github国内速度较慢，也可通过迅雷等工具下载到本地后通过 SecureCRT 等工具上传. 试运行tar -zxvf frp_0.38.0_linux_amd64.tar.gz 解压成功后打开目录下的 frps.ini 文件，修改如下 [common]bind_port = 7000token = mima 尝试启动服务 ./frps -c frps.ini 成功一般有 success 提示信息，如果遇到 Segmentation fault 错误，检查下载的包版本是否有错。 后台运行服务创建服务文件：touch /etc/systemd/system/frp.service 修改 frp.service 内容如下： [Unit]Description=FRP serviceAfter=network.target syslog.targetWants=network.target[Service]ExecStart=/root/apps/frp/frps -c /root/apps/frp/frps.iniRestart=alwaysUser=root[Install]WantedBy=multi-user.target 重置守护进程服务 systemctl daemon-reload 开启服务 systemctl start frp 检查服务是否开启成功，查看 7000 端口是否开启服务即可。 netstat -anp | grep 7000 注意，此处需要在服务器提供网站对应的配置处将 7000 端口的防火墙限制打开，centos 等系统下，注意 firewalld 是否开放防火墙端口。如上操作完成后，服务即后台启动成功。要想服务开机自启动，输入：systemctl enable frp 即可。 Client 端frpc配置 本文Client 端此处采用 Docker 方式。将下载的 frpc.ini 放在 Docker 宿主机本地frpc.ini 内容修改如下： [common]server_addr = 42.113.1.102server_port = 7000token = mima[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[DSM]type = tcplocal_ip = 127.0.0.1local_port = 5000remote_port = 5000 如上配置后，意味着我们之后可以通过 42.113.1.102:5000 来进入群晖，通过 42.113.1.102:22 进入群晖后台。 添加 docker 镜像地址如下：https://hub.docker.com/r/chenhw2/frp下载完成后，双击镜像，做如下三处修改： 应用修改后保存退出。 启动容器点击开关容器启动成功即可，若启动失败，可在Details查看启动日志。 在外网环境在浏览器输入 42.113.1.102:5000来到群晖登录页即穿透成功。","categories":[],"tags":[]},{"title":"VIM基本使用","slug":"VIM基本使用","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"VIM基本使用.html","link":"","permalink":"http://www.skyline.show/VIM基本使用.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 VIM 基本使用 VIM 基本使用 模式 正常模式 (Normal-mode) 插入模式 (Insert-mode) 命令模式 (Command-mode) 可视模式 (Visual-mode) .vimrc inoremap 模式正常模式 (Normal-mode)正常模式一般用于浏览文件，同时包括一些复制、粘贴、删除等快捷操作。其他模式通常通过 ESC 键返回正常模式。 操作 按键 EN 撤销 u undo 插入模式 (Insert-mode)用于编辑文档，直接输入内容。 命令模式 (Command-mode)输入:或/进入命令模式命令模式用于执行 VIM 提供的相关指令。 命令 按键 EN 移动 :m move 设定 :set :m:m 多用于换行操作，当前行的位置为 0.具体使用如下 :m -2 移动到-2 行的位置(当前行与上一行互换) :m +1 移动到+1 行的位置(当前行与下一行互换) :m 0 移动到首行的位置 :m $ 移动到尾行的位置 :set:set number 显示行索引 可视模式 (Visual-mode)","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 VIM 基本使用 VIM 基本使用 模式 正常模式 (Normal-mode) 插入模式 (Insert-mode) 命令模式 (Command-mode) 可视模式 (Visual-mode) .vimrc inoremap 模式正常模式 (Normal-mode)正常模式一般用于浏览文件，同时包括一些复制、粘贴、删除等快捷操作。其他模式通常通过 ESC 键返回正常模式。 操作 按键 EN 撤销 u undo 插入模式 (Insert-mode)用于编辑文档，直接输入内容。 命令模式 (Command-mode)输入:或/进入命令模式命令模式用于执行 VIM 提供的相关指令。 命令 按键 EN 移动 :m move 设定 :set :m:m 多用于换行操作，当前行的位置为 0.具体使用如下 :m -2 移动到-2 行的位置(当前行与上一行互换) :m +1 移动到+1 行的位置(当前行与下一行互换) :m 0 移动到首行的位置 :m $ 移动到尾行的位置 :set:set number 显示行索引 可视模式 (Visual-mode) 在正常模式按下 v, V, ^ + v，可以进入可视模式可视模式下执行文本选择操作。 .vimrcinoremap按键映射 inoremap zz","categories":[],"tags":[]},{"title":"VSCode相关问题汇总","slug":"VSCode相关问题汇总","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"VSCode相关问题汇总.html","link":"","permalink":"http://www.skyline.show/VSCode相关问题汇总.html","excerpt":"","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 VSCode 相关问题汇总Snippetsmarkdown 文件 Snippets 不生效问题描述通过 File -&gt; Preferences -&gt; User Snippets -&gt; Markdown写相关代码块如下markdown.json &#123; // Place your snippets for markdown here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: \"JS code block\": &#123; // \"scope\": \"md,markdown\", \"prefix\": \":cjs\", \"body\": [ \"```$&#123;1:js&#125;\", \"$2\", \"```\" ], \"description\": \"JS code block\" &#125;, \"PY code block\": &#123; // \"scope\": \"md,markdown\", \"prefix\": \":cpy\", \"body\": [ \"```$&#123;1:python&#125;\", \"$2\", \"```\" ], \"description\": \"PY code block\" &#125;&#125; 在 markdown 文件中敲击:cjs 不自动提示。解决方案尝试 CTRL + Space 强制开启。在用户配置setting.json中添加如下配置项 \"[markdown]\": &#123; \"editor.quickSuggestions\": true&#125;","categories":[],"tags":[]},{"title":"IpadOS常见问题","slug":"IpadOS常见问题","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"IpadOS常见问题.html","link":"","permalink":"http://www.skyline.show/IpadOS常见问题.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 IpadOS 常见问题 IpadOS 常见问题 Apple pencil 断触 软件问题 还原设置 硬件检测 BMW WARNING Bulletin Material Warrant Apple pencil 断触软件问题使用系统自带的备忘录尝试是否为软件问题 部分软件可能手触屏幕会有断触问题 还原设置关掉蓝牙重新连接 Pencil重启 iPad 后再次连接 Pencil打开 ipad 设置—&gt;通用—&gt;还原—&gt;还原所有设置 上述操作只是还原设置，不会删除数据，但是人脸识别和密码，壁纸会还原 硬件检测去除贴膜，笔尖套更换笔头尝试换个 ipad 试下是否为笔的问题 这些操作都不行，联系售后解决 BMW WARNINGBulletin","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 IpadOS 常见问题 IpadOS 常见问题 Apple pencil 断触 软件问题 还原设置 硬件检测 BMW WARNING Bulletin Material Warrant Apple pencil 断触软件问题使用系统自带的备忘录尝试是否为软件问题 部分软件可能手触屏幕会有断触问题 还原设置关掉蓝牙重新连接 Pencil重启 iPad 后再次连接 Pencil打开 ipad 设置—&gt;通用—&gt;还原—&gt;还原所有设置 上述操作只是还原设置，不会删除数据，但是人脸识别和密码，壁纸会还原 硬件检测去除贴膜，笔尖套更换笔头尝试换个 ipad 试下是否为笔的问题 这些操作都不行，联系售后解决 BMW WARNINGBulletin 本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"黑群晖安装","slug":"黑群晖安装","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"黑群晖安装.html","link":"","permalink":"http://www.skyline.show/黑群晖安装.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 黑群晖安装 黑群晖安装 硬件准备 Nas 主机 u 盘 电脑 软件准备 系统选择 相关软件 引导盘准备 获取 VID 与 PID 替换 VID 与 PID 格式化硬盘 引导盘制作 安装系统 Nas 进入 BMW WARNING Bulletin Material Warrant 硬件准备 硬件 要求 Nas 主机 Intel CPU u 盘 &gt; 50M 电脑 Windows 系统 键鼠 进 BIOS 等 硬盘 大大的好 Nas 主机黑群晖对主机的要求不是很高，不需要硬解软路由+移动硬盘都可运行。主机一般推荐使用 10 代以下的 Intel CPU.新代 Intel 与 AMD 等其他 CPU 主机核显硬解不友好，视硬解需求而定。 u 盘U 盘用于做系统引导，引导程序的大小为 50M。大于这个容量即可，现在 U 盘基本都满足要求。 电脑需要一台 windows 电脑来安装系统引导程序。键鼠需要插入 Nas 主机操作 BIOS。 软件准备系统选择","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 黑群晖安装 黑群晖安装 硬件准备 Nas 主机 u 盘 电脑 软件准备 系统选择 相关软件 引导盘准备 获取 VID 与 PID 替换 VID 与 PID 格式化硬盘 引导盘制作 安装系统 Nas 进入 BMW WARNING Bulletin Material Warrant 硬件准备 硬件 要求 Nas 主机 Intel CPU u 盘 &gt; 50M 电脑 Windows 系统 键鼠 进 BIOS 等 硬盘 大大的好 Nas 主机黑群晖对主机的要求不是很高，不需要硬解软路由+移动硬盘都可运行。主机一般推荐使用 10 代以下的 Intel CPU.新代 Intel 与 AMD 等其他 CPU 主机核显硬解不友好，视硬解需求而定。 u 盘U 盘用于做系统引导，引导程序的大小为 50M。大于这个容量即可，现在 U 盘基本都满足要求。 电脑需要一台 windows 电脑来安装系统引导程序。键鼠需要插入 Nas 主机操作 BIOS。 软件准备系统选择 黑群晖的系统目前主流使用的有三个版本 DS3615xs DS3617xs DS918+ 个人一般使用 DS918+ 。其他两个为企业级用户设计，系统没有显卡驱动，不支持硬解功能。 黑群晖系统分为两部分：引导文件.img系统文件.pat 相关软件在 Windows 电脑上安装如下软件 软件 作用 ChipEasy 芯片无忧 查找 U 盘的 VID 和 PID DiskGenius 修改 grub.cfg 配置 Win32 Disk Imager 写入镜像 引导盘准备获取 VID 与 PID插入 U 盘，打开 ChipEasy 芯片无忧，选择对应 U 盘，获取 VID 与 PID Logical drive : E:\\ Capacity: 29.4GDevice ID : VID = 17EF PID = 38ACDevice SN : SCY0000000001464Device version : 1100 位于信息中的第二行。 关闭 ChipEasy 替换 VID 与 PID打开 DiskGenius，选择“硬盘”-“打开虚拟硬盘文件” 选择 引导文件.img选中 ESP(0)/grub复制 grub.cfg 到桌面 用记事本或其他编辑器打开替换之前获取的 IDsn 与 mac1 是洗白用的，半白网上可搜索对应 SN,替换后图片可看缩略图。全白可在某某宝获取，替换后可用群晖的 QC 实现外网访问。 修改完成后拖动回到 DiskGenius 刚才对应的目录下，替换原始文件。 格式化硬盘写入引导需要 U 盘只有一个分区，否则有错误提示，写入引导最好先进行如下格式化操作。删除硬盘分区重建硬盘分区 保存更改，在弹窗中点击是，进行 U 盘格式化退出 DiskGenius 引导盘制作打开 win32diskimager 选择修改好的 U 盘与 img 文件 写入完成后 U 盘消失，引导盘制作成功 安装系统Nas 进入U 盘插入 Nas 主机，BIOS 设置 U 盘启动。选择默认第一个选项，回车如果出席一下画面，说明引导成功。 在电脑端输入http://find.synology.com进行访问，或使用synology-assistant BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"MacOS应用清单","slug":"MacOS应用清单","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"MacOS应用清单.html","link":"","permalink":"http://www.skyline.show/MacOS应用清单.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 MacOS 应用清单 MacOS 应用清单 开发 学习 效率 汇总 barrier 娱乐 BMW WARNING Bulletin Material Warrant 开发学习效率汇总 APP DESC Free Web Sharemouse 跨端键鼠共用工具 trial https://github.com/debauchee/barrier Synergy 跨端键鼠共用工具 false https://github.com/debauchee/barrier barrier 基于 Synergy-core 1.9 的开源跨端键鼠共用工具 true https://github.com/debauchee/barrier barrierbarrier 是一款基于 Synergy-core 1.9 的开源跨端键鼠共用工具，拥有 Synergy 基本的跨平台共享键鼠，复制粘贴等基础功能。其他类似的软件还有 Sharemouse 和 Synergy。Synergy 目前已闭源收费，功能上与 barrier 差距不大，Synergy 与 barrier 采用主副机设定。只有主机的键鼠可共享，其他设备的键鼠不能共享试用。Sharemouse 相比，所有键鼠都可共享，但是，Sharemouse 提供的免费试用版本，试用版只支持两台电脑，且两台电脑各自只能有一台内置显示器。目前了解到的类似软件还有， Mouse without Borders Input Director 未安装试用验证。 娱乐BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 MacOS 应用清单 MacOS 应用清单 开发 学习 效率 汇总 barrier 娱乐 BMW WARNING Bulletin Material Warrant 开发学习效率汇总 APP DESC Free Web Sharemouse 跨端键鼠共用工具 trial https://github.com/debauchee/barrier Synergy 跨端键鼠共用工具 false https://github.com/debauchee/barrier barrier 基于 Synergy-core 1.9 的开源跨端键鼠共用工具 true https://github.com/debauchee/barrier barrierbarrier 是一款基于 Synergy-core 1.9 的开源跨端键鼠共用工具，拥有 Synergy 基本的跨平台共享键鼠，复制粘贴等基础功能。其他类似的软件还有 Sharemouse 和 Synergy。Synergy 目前已闭源收费，功能上与 barrier 差距不大，Synergy 与 barrier 采用主副机设定。只有主机的键鼠可共享，其他设备的键鼠不能共享试用。Sharemouse 相比，所有键鼠都可共享，但是，Sharemouse 提供的免费试用版本，试用版只支持两台电脑，且两台电脑各自只能有一台内置显示器。目前了解到的类似软件还有， Mouse without Borders Input Director 未安装试用验证。 娱乐BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"Nginx常见问题汇总","slug":"Nginx常见问题汇总","date":"2022-01-20T07:47:15.000Z","updated":"2022-01-20T07:47:15.000Z","comments":true,"path":"Nginx常见问题汇总.html","link":"","permalink":"http://www.skyline.show/Nginx常见问题汇总.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Nginx 常见问题汇总 Nginx 常见问题汇总 proxy_pass 代理接口不能访问 问题描述 配置 页面刷新不能进入 BMW WARNING Bulletin Material Warrant proxy_pass 代理接口不能访问问题描述客户端访问接口，发起请求http://aaa.com/file/123.png 真实接口地址为http://bbb.com/123.png 配置检查配置，正确的配置如下 location ^~ /file/ &#123; proxy_pass http://bbb.com/;&#125; 检查地址，注意后缀’/‘都不能去掉。一般把 server:port 后的部分叫做 URI，proxy_pass 在其后加不加 URI 表现完全不同。location 非正则匹配时，proxy_pass 有 URI 直接用 URI 把 location 对应的字符替换，无 URI 则直接替换 server:port详细解析查看Nginx 基础 页面刷新不能进入检查页面的路由模式。特别是在 Vue 项目中，具体查看 HTML5 History Modevue 默认的是 hash 路由模式，使用此种模式，页面路由变化时，并不会重载页面在配置网站根文件的位置加入try_files $uri $uri/ /index.html;一般如下配置 location ^~ /skyline&#123; alias /data/wwwroot/skyline/dist; index index.html index.htm; try_files $uri $uri/ /index.html;&#125; BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 Nginx 常见问题汇总 Nginx 常见问题汇总 proxy_pass 代理接口不能访问 问题描述 配置 页面刷新不能进入 BMW WARNING Bulletin Material Warrant proxy_pass 代理接口不能访问问题描述客户端访问接口，发起请求http://aaa.com/file/123.png 真实接口地址为http://bbb.com/123.png 配置检查配置，正确的配置如下 location ^~ /file/ &#123; proxy_pass http://bbb.com/;&#125; 检查地址，注意后缀’/‘都不能去掉。一般把 server:port 后的部分叫做 URI，proxy_pass 在其后加不加 URI 表现完全不同。location 非正则匹配时，proxy_pass 有 URI 直接用 URI 把 location 对应的字符替换，无 URI 则直接替换 server:port详细解析查看Nginx 基础 页面刷新不能进入检查页面的路由模式。特别是在 Vue 项目中，具体查看 HTML5 History Modevue 默认的是 hash 路由模式，使用此种模式，页面路由变化时，并不会重载页面在配置网站根文件的位置加入try_files $uri $uri/ /index.html;一般如下配置 location ^~ /skyline&#123; alias /data/wwwroot/skyline/dist; index index.html index.htm; try_files $uri $uri/ /index.html;&#125; BMW WARNINGBulletin本文首发于 skyline.show 欢迎访问。 I am a bucolic migrant worker but I never walk backwards. Material 参考资料如下列出，部分引用可能遗漏或不可考，侵删。 Warrant本文作者： Skyline(lty)授权声明： 本博客所有文章除特别声明外， 均采用 CC BY - NC - SA 3.0 协议。 转载请注明出处！ CC BY - NC - SA 3.0","categories":[],"tags":[]},{"title":"JavaScript隐式类型转换小结","slug":"JavaScript隐式类型转换小结","date":"2018-01-26T12:49:44.000Z","updated":"2018-01-26T12:49:44.000Z","comments":true,"path":"JavaScript隐式类型转换小结.html","link":"","permalink":"http://www.skyline.show/JavaScript隐式类型转换小结.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 转换规则隐式转换为布尔值如表 数据类型 转化成true 转化成false String 非空字符 “”(空字符） Number 非零 0与NaN Object 非Null对象 null undefined 无 undefined （注：调用Boolean()方法得到结果相同） 对象隐式转换规则","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 转换规则隐式转换为布尔值如表 数据类型 转化成true 转化成false String 非空字符 “”(空字符） Number 非零 0与NaN Object 非Null对象 null undefined 无 undefined （注：调用Boolean()方法得到结果相同） 对象隐式转换规则 对象隐式转换成字符串或数字 不同对象调用toString()得到的结果 对象 调用toString() 普通对象 “[object Object]” 数组arr arr.join() 函数类 定义函数的代码 日期类 可读日期 正则对象 正则对象字面量的字符 如果数组的某一项的值是null或者undefined，join()方法返回的结果以空字符串连接 基本包装类型的引用类型用其字面量形式的值调用toString() 不同对象调用valueOf()得到的结果 大多数对象，包括普通对象、数组、函数、正则简单返回对象本身 日期对象返回19700101以来的毫秒数值 基本包装类型的引用类型返回其字面量形式的值 其他隐式转换规则 值 转化成字符串 转化成数字 转化成布尔值 undefined “undefined” NaN false null “null” 0 false NaN “NaN” NaN false []（空数组） “” 0 true “”（空字符串） “” 0 false 布尔值转数字为0/1，转字符串为”true”/“false” 数字转字符串加引号即可🙄 字符串转数字，看去掉引号是否是数字即可🤣，否则为NaN（注：假装这样表述是很严谨的🤣，数字与字符串的相互转换不用表述大家都知道的） 开始转换加号表达式中有字符串 其他类型隐式转换为字符串 多个加号时，按照从左到右的顺序，两两进行计算 只要表达式中如果有字符串，最终结果一定是字符串 如果有复杂类型，先将复杂类型按照对象隐式转换规则转换成字符串 2 + \"3\"; // \"23\"1 + 2 + \"3\"; // \"33\"true + 2 + \"3\"; // \"33\"1 + \"2\" + 3; // \"123\"\"2\" + true; //\"2true\"\"2\" + undefined; //\"2undefined\"\"2\" + NaN //\"2NaN\"'23' + &#123;'a': 1&#125; //\"23[object Object]\"'23' + [1,3,&#123;&#125;, null, undefined, '', '2'] // \"231,3,[object Object],,,,2\"[1,3,&#123;&#125;, null, undefined, '', '2'].toString() //\"1,3,[object Object],,,,2\"23 + \"1,3,[object Object],,,,2\" //\"231,3,[object Object],,,,2\" 表达式中没有字符串 如果没有复杂类型，其他类型隐式转换为数字 如果有复杂类型，先将复杂类型按照对象隐式转换规则转换成原始值再按照如上规则计算 1 + [] //\"1\"1 + [1] //\"11\"1 + &#123;a:'a'&#125; //\"1[object Object]\"null + null //0true + &#123;a:'a'&#125; //\"true[object Object]\" 注意undefined 转化成数字是NaN typeof NaN //\"number\"null + undefined //NaN1 + undefined //NaN 特殊注意 + '3' // 数字3 乘，除，取余，减 其他类型会隐式转换为数字 1 - '5' //-41 - [2, 2] //NaN1 - &#123;a:1&#125; //NaN1- undefined //NaN1 - [] //11 - [2, 2] //NaN1 - null //1 比较运算符部分 &gt; &lt; &gt;= &lt;= == 数字vs其他，其他转化为数字 布尔值vs其他，布尔值转数字，数字vs其他 字符串vs字符串，按unicode依次比较(大写字母总是在小写字母之后) 对象vs数字，对象vs字符串，将对象转化为转换成原始值，再进行比较。 如果其中一个操作数是NaN，那么总是返回false(NaN和NaN是不相等的) null 只和undefined是好基友（互相相等） var x = NaN;x === NaN; // falseundefined == \"undefined\" // falsenull == \"null\" // falsenull == 0 // falsenull == false // falseundefined == 0 // falseundefined == false // false 参考资料 《JavaScript高级程序设计》 &nbsp; 本文作者： Skyline(lty)文章链接： http://www.skyline.show/JavaScript隐式类型转换小结.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"Js隐式类型转换需要注意的地方","slug":"Js隐式类型转换需要注意的地方","date":"2018-01-26T07:14:56.000Z","updated":"2018-01-26T12:49:44.000Z","comments":true,"path":"Js隐式类型转换需要注意的地方.html","link":"","permalink":"http://www.skyline.show/Js隐式类型转换需要注意的地方.html","excerpt":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 转换规则隐式转换为布尔值如表 数据类型 转化成true 转化成false String 非空字符 “”(空字符） Number 非零 0与NaN Object 非Null对象 null undefined 无 undefined （注：调用Boolean()方法得到结果相同） 对象隐式转换规则","text":"作者水平有限，文章仅供参考，不对的地方希望各位及时指正，共同进步，不胜感激 转换规则隐式转换为布尔值如表 数据类型 转化成true 转化成false String 非空字符 “”(空字符） Number 非零 0与NaN Object 非Null对象 null undefined 无 undefined （注：调用Boolean()方法得到结果相同） 对象隐式转换规则 对象隐式转换成字符串或数字 不同对象调用toString()得到的结果 对象 调用toString() 普通对象 “[object Object]” 数组arr arr.join() 函数类 定义函数的代码 日期类 可读日期 正则对象 正则对象字面量的字符 如果数组的某一项的值是null或者undefined，join()方法返回的结果以空字符串连接 基本包装类型的引用类型用其字面量形式的值调用toString() 不同对象调用valueOf()得到的结果 大多数对象，包括普通对象、数组、函数、正则简单返回对象本身 日期对象返回19700101以来的毫秒数值 基本包装类型的引用类型返回其字面量形式的值 其他隐式转换规则 值 转化成字符串 转化成数字 转化成布尔值 undefined “undefined” NaN false null “null” 0 false NaN “NaN” NaN false []（空数组） “” 0 true “”（空字符串） “” 0 false 布尔值转数字为0/1，转字符串为”true”/“false” 数字转字符串加引号即可🙄 字符串转数字，看去掉引号是否是数字即可🤣，否则为NaN（注：假装这样表述是很严谨的🤣，数字与字符串的相互转换不用表述大家都知道的） 开始转换加号表达式中有字符串 其他类型隐式转换为字符串 多个加号时，按照从左到右的顺序，两两进行计算 只要表达式中如果有字符串，最终结果一定是字符串 如果有复杂类型，先将复杂类型按照对象隐式转换规则转换成字符串 2 + \"3\"; // \"23\"1 + 2 + \"3\"; // \"33\"true + 2 + \"3\"; // \"33\"1 + \"2\" + 3; // \"123\"\"2\" + true; //\"2true\"\"2\" + undefined; //\"2undefined\"\"2\" + NaN //\"2NaN\"'23' + &#123;'a': 1&#125; //\"23[object Object]\"'23' + [1,3,&#123;&#125;, null, undefined, '', '2'] // \"231,3,[object Object],,,,2\"[1,3,&#123;&#125;, null, undefined, '', '2'].toString() //\"1,3,[object Object],,,,2\"23 + \"1,3,[object Object],,,,2\" //\"231,3,[object Object],,,,2\" 表达式中没有字符串 如果没有复杂类型，其他类型隐式转换为数字 如果有复杂类型，先将复杂类型按照对象隐式转换规则转换成原始值再按照如上规则计算 1 + [] //\"1\"1 + [1] //\"11\"1 + &#123;a:'a'&#125; //\"1[object Object]\"null + null //0true + &#123;a:'a'&#125; //\"true[object Object]\" 注意undefined 转化成数字是NaN typeof NaN //\"number\"null + undefined //NaN1 + undefined //NaN 特殊注意 + '3' // 数字3 乘，除，取余，减 其他类型会隐式转换为数字 1 - '5' //-41 - [2, 2] //NaN1 - &#123;a:1&#125; //NaN1- undefined //NaN1 - [] //11 - [2, 2] //NaN1 - null //1 比较运算符部分 &gt; &lt; &gt;= &lt;= == 数字vs其他，其他转化为数字 布尔值vs其他，布尔值转数字，数字vs其他 字符串vs字符串，按unicode依次比较(大写字母总是在小写字母之后) 对象vs数字，对象vs字符串，将对象转化为转换成原始值，再进行比较。 如果其中一个操作数是NaN，那么总是返回false(NaN和NaN是不相等的) null 只和undefined是好基友（互相相等） var x = NaN;x === NaN; // falseundefined == \"undefined\" // falsenull == \"null\" // falsenull == 0 // falsenull == false // falseundefined == 0 // falseundefined == false // false 参考资料 《JavaScript高级程序设计》 &nbsp; 本文作者： Skyline(lty)文章链接： http://www.skyline.show/Js隐式类型转换需要注意的地方.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"采桑子（丑奴儿）","slug":"采桑子（丑奴儿）","date":"2018-01-25T12:55:34.000Z","updated":"2018-01-25T13:08:22.000Z","comments":true,"path":"采桑子（丑奴儿）.html","link":"","permalink":"http://www.skyline.show/采桑子（丑奴儿）.html","excerpt":"简介（摘自度娘百科）采桑子，又名《丑奴儿》，《丑奴儿令》，《罗敷媚》，《罗敷艳歌》等。采桑子格律为双调四十四字，上下片各四句三平韵。另有添字格，两结句各添二字，两平韵，一叠韵。 名家名作欧阳修轻舟短棹西湖好，绿水逶迤，芳草长堤，隐隐笙歌处处随。 无风水面琉璃滑，不觉船移，微动涟漪，惊起沙禽掠岸飞。 群芳过后西湖好，狼籍残红，飞絮濛濛。垂柳阑干尽日风。 笙歌散尽游人去，始觉春空。垂下帘栊，双燕归来细雨中。 纳兰性德谢家庭院残更立，燕宿雕梁，月度银墙，不辨花丛那辨香。 此情已自成追忆，零落鸳鸯，雨歇微凉，十一年前梦一场。 谁翻乐府凄凉曲？风也萧萧，雨也萧萧，瘦尽灯花又一宵。 不知何事萦怀抱，醒也无聊，醉也无聊，梦也何曾到谢桥。 彤霞久绝飞琼字，人在谁边。人在谁边，今夜玉清眠不眠。 香销被冷残灯灭，静数秋天。静数秋天，又误心期到下弦。 吕本中（宋）恨君不似江楼月，南北东西，南北东西，只有相随无别离。 恨君却似江楼月，暂满还亏，暂满还亏，待得团圆是几时？ 晏几道西楼月下当时见，泪粉偷匀。歌罢还颦。恨隔炉烟看未真。 别来楼外垂杨缕，几换青春。倦客红尘，长记楼中粉泪人。 昭华凤管知名久，长闭帘栊。日日春慵。闲倚庭花晕脸红。 应说金谷无人后，此会相逢。三弄临风。送得当筵玉盏空。 辛弃疾","text":"简介（摘自度娘百科）采桑子，又名《丑奴儿》，《丑奴儿令》，《罗敷媚》，《罗敷艳歌》等。采桑子格律为双调四十四字，上下片各四句三平韵。另有添字格，两结句各添二字，两平韵，一叠韵。 名家名作欧阳修轻舟短棹西湖好，绿水逶迤，芳草长堤，隐隐笙歌处处随。 无风水面琉璃滑，不觉船移，微动涟漪，惊起沙禽掠岸飞。 群芳过后西湖好，狼籍残红，飞絮濛濛。垂柳阑干尽日风。 笙歌散尽游人去，始觉春空。垂下帘栊，双燕归来细雨中。 纳兰性德谢家庭院残更立，燕宿雕梁，月度银墙，不辨花丛那辨香。 此情已自成追忆，零落鸳鸯，雨歇微凉，十一年前梦一场。 谁翻乐府凄凉曲？风也萧萧，雨也萧萧，瘦尽灯花又一宵。 不知何事萦怀抱，醒也无聊，醉也无聊，梦也何曾到谢桥。 彤霞久绝飞琼字，人在谁边。人在谁边，今夜玉清眠不眠。 香销被冷残灯灭，静数秋天。静数秋天，又误心期到下弦。 吕本中（宋）恨君不似江楼月，南北东西，南北东西，只有相随无别离。 恨君却似江楼月，暂满还亏，暂满还亏，待得团圆是几时？ 晏几道西楼月下当时见，泪粉偷匀。歌罢还颦。恨隔炉烟看未真。 别来楼外垂杨缕，几换青春。倦客红尘，长记楼中粉泪人。 昭华凤管知名久，长闭帘栊。日日春慵。闲倚庭花晕脸红。 应说金谷无人后，此会相逢。三弄临风。送得当筵玉盏空。 辛弃疾 书博山道中壁 少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。 而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。 晏殊春风不负东君信，遍拆群芳。燕子双双。依旧衔泥入杏梁。 须知一盏花前酒。占得韶光。莫话匆忙。梦里浮生足断肠。 阳和二月芳菲遍，暖景溶溶。戏蝶游蜂。深入千花粉艳中。 何人解系天边日，占取春风。免使繁红。一片西飞一片东。 本文作者： Skyline(lty)本文链接： http://www.skyline.show/采桑子（丑奴儿）.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"词·搜集","slug":"词·搜集","permalink":"http://www.skyline.show/categories/词·搜集/"}],"tags":[{"name":"词","slug":"词","permalink":"http://www.skyline.show/tags/词/"},{"name":"采桑子","slug":"采桑子","permalink":"http://www.skyline.show/tags/采桑子/"}]},{"title":"浣溪沙","slug":"浣溪沙","date":"2018-01-25T12:53:12.000Z","updated":"2018-01-25T13:08:22.000Z","comments":true,"path":"浣溪沙.html","link":"","permalink":"http://www.skyline.show/浣溪沙.html","excerpt":"简介（摘自度娘百科）浣溪沙，唐代教坊曲名，后用为词牌。分平仄两体，字数以四十二字居多，还有四十四字和四十六字两种。全词分两片，上片三句全用韵，下片末二句用韵（多用平韵）。 名家名作晏殊一曲新词酒一杯,去年天气旧亭台。夕阳西下几时回? 无可奈何花落去,似曾相识燕归来。小园香径独徘徊。 青杏园林煮酒香，佳人初试薄罗裳。柳丝无力燕飞忙。 乍雨乍晴花自落，闲愁闲闷日偏长。为谁消瘦减容光。 一向年光有限身，等闲离别易销魂，酒筵歌席莫辞频。 满目山河空念远，落花风雨更伤春，不如怜取眼前人。 苏轼簌簌衣巾落枣花,村南村北响缲车。牛衣古柳卖黄瓜。 酒困路长惟欲睡,日高人渴漫思茶。敲门试问野人家。 （游蕲水清泉寺,寺临兰溪,溪水西流。） 山下兰芽短浸溪，松间沙路净无泥，潇潇暮雨子规啼。 谁道人生无再少？门前流水尚能西！休将白发唱黄鸡。 （咏橘） 橘暗荷枯一夜霜，新苞绿叶照林光。竹林茅舍出青黄。 香雾噀（xùn）人惊半破，清泉流齿怯初尝。吴姬三日手犹香。 纳兰性德谁念西风独自凉，萧萧黄叶闭疏窗。沉思往事立残阳。 被酒莫惊春睡重，赌书消得泼茶香。当时只道是寻常。 雨歇梧桐泪乍收，遣怀翻自忆从头，摘花销恨旧风流。 帘影碧桃人已去，屧（xiè）痕苍藓径空留。两眉何处月如钩？ 秦观漠漠轻寒上小楼，晓阴无赖似穷秋。淡烟流水画屏幽。 自在飞花轻似梦，无边丝雨细如愁。宝帘闲挂小银钩。 王安石","text":"简介（摘自度娘百科）浣溪沙，唐代教坊曲名，后用为词牌。分平仄两体，字数以四十二字居多，还有四十四字和四十六字两种。全词分两片，上片三句全用韵，下片末二句用韵（多用平韵）。 名家名作晏殊一曲新词酒一杯,去年天气旧亭台。夕阳西下几时回? 无可奈何花落去,似曾相识燕归来。小园香径独徘徊。 青杏园林煮酒香，佳人初试薄罗裳。柳丝无力燕飞忙。 乍雨乍晴花自落，闲愁闲闷日偏长。为谁消瘦减容光。 一向年光有限身，等闲离别易销魂，酒筵歌席莫辞频。 满目山河空念远，落花风雨更伤春，不如怜取眼前人。 苏轼簌簌衣巾落枣花,村南村北响缲车。牛衣古柳卖黄瓜。 酒困路长惟欲睡,日高人渴漫思茶。敲门试问野人家。 （游蕲水清泉寺,寺临兰溪,溪水西流。） 山下兰芽短浸溪，松间沙路净无泥，潇潇暮雨子规啼。 谁道人生无再少？门前流水尚能西！休将白发唱黄鸡。 （咏橘） 橘暗荷枯一夜霜，新苞绿叶照林光。竹林茅舍出青黄。 香雾噀（xùn）人惊半破，清泉流齿怯初尝。吴姬三日手犹香。 纳兰性德谁念西风独自凉，萧萧黄叶闭疏窗。沉思往事立残阳。 被酒莫惊春睡重，赌书消得泼茶香。当时只道是寻常。 雨歇梧桐泪乍收，遣怀翻自忆从头，摘花销恨旧风流。 帘影碧桃人已去，屧（xiè）痕苍藓径空留。两眉何处月如钩？ 秦观漠漠轻寒上小楼，晓阴无赖似穷秋。淡烟流水画屏幽。 自在飞花轻似梦，无边丝雨细如愁。宝帘闲挂小银钩。 王安石 百亩中庭半是苔，门前白道水萦回。爱闲能有几人来？ 小院回廊春寂寂，山桃溪杏两三栽。为谁零落为谁开？ 晏几道楼上灯深欲闭门。梦云归去不留痕。几年芳草忆王孙。 向日阑干依旧绿，试将前事倚黄昏。记曾来处易消魂。 午醉西桥夕未醒。雨花凄断不堪听。归时应减鬓边青。 衣化客尘今古道，柳含春意短长亭。凤楼争见路旁情。 本文作者： Skyline(lty)本文链接： http://www.skyline.show/浣溪沙.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"词·搜集","slug":"词·搜集","permalink":"http://www.skyline.show/categories/词·搜集/"}],"tags":[{"name":"词","slug":"词","permalink":"http://www.skyline.show/tags/词/"},{"name":"浣溪沙","slug":"浣溪沙","permalink":"http://www.skyline.show/tags/浣溪沙/"}]},{"title":"CSS兄弟选择器","slug":"CSS兄弟选择器","date":"2018-01-25T12:13:37.000Z","updated":"2018-01-25T12:41:07.000Z","comments":true,"path":"CSS兄弟选择器.html","link":"","permalink":"http://www.skyline.show/CSS兄弟选择器.html","excerpt":"","text":"选择器 兄弟选择器包括 + ~ ‘+’ 是相邻兄弟选择器 ‘~’ 是通用兄弟选择器 说明 相邻兄弟选择器 + 选择紧接在另一元素后的元素，且二者有相同父元素 通用兄弟选择器 ~ 连接两个元素,它会匹配第二个元素,它必须跟(不一定是紧跟)在第一个元素之后,且他们都有一个共同的父元素 表示 阐述 同父 紧接老哥 选中元素 ‘+’ 相邻 是 是 最多一个（非紧邻不选中） ‘~’ 通用 是 否 多个 举个栗子 h1 + p {color: red;}紧邻h1的第一个p兄弟标签中招，h1之后没有紧邻的p，就白搭 h1 ~ p {color: red;}比h1小（在其后面）的p兄弟标签全部中招，h1之后没有p，就白搭 本文作者： Skyline(lty)本文链接： http://www.skyline.show/CSS兄弟选择器.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"CSS/HTML","slug":"CSS-HTML","permalink":"http://www.skyline.show/categories/CSS-HTML/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.skyline.show/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"鹧鸪天·新寒（新韵）","slug":"鹧鸪天·新寒（新韵）","date":"2018-01-24T12:51:03.000Z","updated":"2018-01-24T11:07:38.000Z","comments":true,"path":"鹧鸪天·新寒（新韵）.html","link":"","permalink":"http://www.skyline.show/鹧鸪天·新寒（新韵）.html","excerpt":"","text":"&nbsp;&nbsp; 乍起新寒风又嚎，厦间不见杜家茅。落棋柯烂朝兴替，弹指风挥花盛飘。 梦缥缈，路遥迢，随流逐浪几多豪？待心足了即名了，斜雨泥丫印土桥。&nbsp;&nbsp; 本文作者： Skyline(lty)本文链接： http://www.skyline.show/鹧鸪天·新寒（新韵）.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"词·自作","slug":"词·自作","permalink":"http://www.skyline.show/categories/词·自作/"}],"tags":[{"name":"词","slug":"词","permalink":"http://www.skyline.show/tags/词/"},{"name":"鹧鸪天","slug":"鹧鸪天","permalink":"http://www.skyline.show/tags/鹧鸪天/"},{"name":"练笔","slug":"练笔","permalink":"http://www.skyline.show/tags/练笔/"}]},{"title":"displaynone和visibilityhidden的区别","slug":"displaynone和visibilityhidden的区别","date":"2018-01-24T07:14:56.000Z","updated":"2018-01-25T12:41:07.000Z","comments":true,"path":"displaynone和visibilityhidden的区别.html","link":"","permalink":"http://www.skyline.show/displaynone和visibilityhidden的区别.html","excerpt":"","text":"口述简单来说都是用于隐藏元素。表现形式大有不同 display会被文档流给移除，会影响页面布局，页面重新排版，浏览器重绘，原本位置被其他元素占据。 visilibity:hidden不会被文档流给移除，不会影响布局，页面不会重新排版，浏览器只是重绘出一片空白 display不是继承属性，而visibility是继承属性。当子元素的visibility为visible时可以重置由先辈继承的visibility:hidden而变得可见。而元素的display属性设为none后子元素无力挣扎。 表述 样式 页面重绘 页面重排 显示效果 所在css属性是否继承 display:none 是 是 无显示 否 visibility:hidden 是 否 所处区域空白 是 本文作者： Skyline(lty)本文链接： http://www.skyline.show/displaynone和visibilityhidden的区别.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"CSS/HTML","slug":"CSS-HTML","permalink":"http://www.skyline.show/categories/CSS-HTML/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.skyline.show/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"ES5与ES6中的argments","slug":"ES5与ES6中的argments","date":"2018-01-24T07:14:56.000Z","updated":"2018-01-24T08:17:53.000Z","comments":true,"path":"ES5与ES6中的argments.html","link":"","permalink":"http://www.skyline.show/ES5与ES6中的argments.html","excerpt":"","text":"ES5function createArray5() &#123; console.log(arguments) console.log(arguments instanceof Array) return arguments;&#125;createArray5(11,2,3)//(3) [11, 2, 3, callee: function, Symbol(Symbol.iterator): function]//false ES6function createArray6(...args) &#123; console.log(args) console.log(args instanceof Array) return args;&#125;createArray6(11,2,3)// (3) [11, 2, 3]// true 结论 ES5的arguments是一种类数组。 ES6通过扩展运算符获取到的参数是一个数组 本文作者： Skyline(lty)本文链接： http://www.skyline.show/ES5与ES6中的argments.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"Sed命令","slug":"Sed命令","date":"2018-01-22T07:14:56.000Z","updated":"2018-01-24T08:17:53.000Z","comments":true,"path":"Sed命令.html","link":"","permalink":"http://www.skyline.show/Sed命令.html","excerpt":"简介流编辑器，sed用于读取指定文件或标准输入。如果没有文件被指定，可由命令列表来指定输入，进行相应修改后写入到标准输出。 选项-n概述默认情况下，在所有的标准输出都会被打印到屏幕上。 -n选项用于指定输出内容。 示例☞ 代码# 输出100到200行sed -n '100,200p' skyline.txt# 输出文件行数sed -n '$=' skyline.txt ☞ 说明","text":"简介流编辑器，sed用于读取指定文件或标准输入。如果没有文件被指定，可由命令列表来指定输入，进行相应修改后写入到标准输出。 选项-n概述默认情况下，在所有的标准输出都会被打印到屏幕上。 -n选项用于指定输出内容。 示例☞ 代码# 输出100到200行sed -n '100,200p' skyline.txt# 输出文件行数sed -n '$=' skyline.txt ☞ 说明 地址逗号隔开 -e说明-e是编辑命令，用于执行多个编辑任务。 示例☞ 代码sed -e &#39;1,10d&#39; -e &#39;s/skyline/lty/g&#39; skyline.txt ☞ 说明 skyline.txt将依次执行之后的命令，删除一到十行，并且全局替换’skyline’为’lty’ -i概述-i 指定备份，指定空字符串或不指定内容直接修改源文件(linux下可以不指定，mac下需指定空字符)。没有指定该选项将直接标准输出，不进行任何实质修改 示例☞ 代码# 指定skyline.txt.bak的备份sed -i '.bak' 's/skyline/lty/g' ./skyline.txt ☞ 说明 skyline.txt源文件内容备份到skyline.txt.bak文件中 sed -i ‘’ ‘s/skyline/lty/g’ ./skyline.txt 将不备份直接修改源文件 sed -i ‘s/skyline/lty/g’ ./skyline.txt linux可以直接执行修改源文件，mac下需要如上指定空字符方可，在 Mac 上，sed 命令直接操作文件的时候，必须指定备份的格式，而在 linux 上，却并没有这个要求 命令参数插入i a概述都是插入，后面可以接字串，用a插入的字串会在行的下一行行首出现，用i插入的字串会在当前行的行首出现单独一行需要在字符后加上\\n 示例☞ 代码# Mac/Linuxsed -i '' '9i\\6666666' skyline.txt# Linuxsed -i '' '9a\\6666666' skyline.txt ☞ 说明 注意mac下\\后需要换行 删除d概述删除，之后不接内容 示例☞ 代码sed -i &#39;&#39; &#39;1,2d&#39; skyline.txt 打印p概述标准输出内容 示例☞ 代码sed -n &#39;3p&#39; skyline 替换 s c概述替换部分内容，s来替换，通常这个 s 搭配正则表达式。 c 替换通常指定行，之后用这些字串取代 n1,n2 之间的行内容 示例☞ 代码# 替换1到5行的内容为lalalased -i '' '1,5c\\lalala' skyline.txt# 替换sed -i '' 's/666/222/g' skyline.txt 常见用法 文末插入 (注意mac下\\后需要换行)sed -i &#39;&#39; &#39;$a\\skyline&#39; skyline.txt 替换第n个匹配的字符echo sksksksksksk | sed &#39;s/sk/SK/3&#39; 输出文件行数sed -n &#39;$=&#39; skyline.txt 输出文件第n个匹配字符所在行号sed -n /skyline/= skyline.txt | sed -n 2p #匹配第二个skyline，打印其所在行号 本文作者： Skyline(lty)本文链接： http://www.skyline.show/Sed命令.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Linux/Unix","slug":"Linux-Unix","permalink":"http://www.skyline.show/categories/Linux-Unix/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"},{"name":"shell","slug":"shell","permalink":"http://www.skyline.show/tags/shell/"}]},{"title":"对象的私有、静态（类）、自有（实例）、原型属性与方法","slug":"对象的私有、静态（类）、自有（实例）、原型属性与方法","date":"2018-01-02T07:14:56.000Z","updated":"2018-01-03T08:17:53.000Z","comments":true,"path":"对象的私有、静态（类）、自有（实例）、原型属性与方法.html","link":"","permalink":"http://www.skyline.show/对象的私有、静态（类）、自有（实例）、原型属性与方法.html","excerpt":"","text":"es5代码//对象构造函数function Baby(name) &#123; var className = \"Baby\"; //私有属性，只能在对象构造函数内部使用 this.name = name; this.weight = '3kg'; //自有属性，每个实例私有，在对象实例化后调用，实例属性在对象实力化后创建 this.hello = function() &#123; console.log(this.name); console.log(this.msg()); //使用原型方法扩充的方法可以在类内部使用 console.log(this.sex); //使用原型方法扩充的属性可以在类内部使用 console.log(Baby.age, this.age); //静态属性调用时格式为[对象.静态属性] &#125;//对象方法&#125;Baby.Run = function() &#123; console.log(\"跑起来！！！\");&#125;//类方法 (实际是静态方法直接调用)，只有类才能访问类方法，实例不能访问 ，在类方法中通过this只能访问类属性不能访问其他属性，即在本例中，Run方法只能访问到this.ageBaby.prototype.msg = function() &#123; console.log(\"我叫：\" + this.name); &#125;//原型方法，如果原型方法当作静态方法直接调用时，this.name无法被调用Baby.age = 20; //类属性 在类的外部。公有静态属性不能使用 【this.属性】，只能使用 【对象.属性】 调用，只有类才能访问类属性，实例不能访问 Baby.prototype.sex = \"男娃娃\"//原型属性，所有实例共有，【this.属性】这种写法访问时，先会访问实例对象属性，没有实例对象属性就会访问原型属性 ，也可以当成公有静态属性使用【对象.prototype.原型属性。 var bob = new Baby(\"bob\"); //自有方法和原型方法需要实例化对象后才可以使Baby.name//\"Baby\" :每一个类都有一个基本的name属性bob.name//\"bob\"Baby.weight//undefinedbob.weight//\"3kg\"Baby.hello()//Uncaught TypeError: Baby.hello is not a functionbob.hello()// bob// 我叫：bob// undefined :this.msg没有返回所以undefined// 男娃娃// 20 undefinedBaby.Run(); //跑起来！！！//类方法也是静态方法，可以直接使用 【对象.静态方法()】bob.run()// TypeError: bob.run is not a functionBaby.msg()// Uncaught TypeError: Baby.msg is not a functionBaby.prototype.msg()// 我叫：undefined//原型方法当成静态方法使用时【对象.prototype.方法()】 bob.msg();// 我叫：bob//原型方法必须实例化对象bob.age;// undefined //错误，公有静态属性只能使用 【对象.属性】调用Baby.age// 20Baby.prototype.sex// 男娃娃//原型属性当作静态属性使用时【对象.prototype.方法()】Baby.sex// undefinedbob.sex// 男娃娃 es6代码class Point &#123; constructor(x, y) &#123; //对象属性、方法 this.x = x; this.y = y; this.fn = function() &#123; return 'skyline' &#125;; &#125; //自有属性，使用存取器 get prop() &#123; return 'skyline getter'; &#125; set prop(value) &#123; console.log('skyline setter: '+value); &#125; //原型方法 //Point.prototype.toString = function () &#123; // return '(' + this.x + ', ' + this.y + ')'; //&#125;; //的语法糖 toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125; //类方法 static classMethod() &#123; return 'hello skyline'; &#125;&#125;//类属性，ES6 明确规定，Class 内部只有静态方法，没有静态属性，不过有其他提案，不拓展Point.prop = 1; 总结 静态属性方法，可以直接通过类进行访问的 实例属性方法是需要创建实例对象进行访问的 相互之间不能串访 本文作者： Skyline(lty)本文链接： http://www.skyline.show/对象的私有、静态（类）、自有（实例）、原型属性与方法.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"word-break、overflow-wrap(word-wrap)、white-space","slug":"word-break、overflow-wrap(word-wrap)、white-space","date":"2017-12-30T07:14:56.000Z","updated":"2018-01-24T08:17:53.000Z","comments":true,"path":"word-break、overflow-wrap(word-wrap)、white-space.html","link":"","permalink":"http://www.skyline.show/word-break、overflow-wrap(word-wrap)、white-space.html","excerpt":"","text":"段落换行word-break 、overflow-wrap(word-wrap) overflow-wrapoverflow-wrap: normal;overflow-wrap: break-word; word-wrap原始微软私有，css3之后重命名为overflow-wrap。normal,默认值，单词保留完整，超出不管，CJK断行break-word，尽量保留英文完整，从空白或CJK断开（单词一般是完整的，除非一个单词占一行才断开换行） word-breakword-break: normal word-break: break-all word-break: keep-all normal,默认值，单词保留完整，超出不管，CJK断行break-all 超出即换行，不考虑单词完整（适用所有语言），就是挨着把空白填满keep-all，只有遇到空白才断行（包括CJK），超出不管 换行总结 normal 想的没错（你想的是哪样就是哪样） break-word 英文优先 break-all 空白填满 keep-all 空白断行 处理文字空白white-space white-spacewhite-space设计用于处理段落中的空白符，处理换行问题时，涉及的是换不换行的问题，而不是怎么换行。常见使用是让文字直接不断行 &nbsp; 换行符 空格和制表符 文字转行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 参考资料： MDN white-space 本文作者： Skyline(lty)本文链接： http://www.skyline.show/word-break、overflow-wrap(word-wrap)、white-space.html、white-space.html)版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"CSS/HTML","slug":"CSS-HTML","permalink":"http://www.skyline.show/categories/CSS-HTML/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.skyline.show/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"vue里面的小坑","slug":"vue里面的小坑","date":"2017-12-30T07:14:56.000Z","updated":"2017-12-30T07:14:56.000Z","comments":true,"path":"vue里面的小坑.html","link":"","permalink":"http://www.skyline.show/vue里面的小坑.html","excerpt":"部分代码与文字源于官网，详情与变更参见官网，本文仅作参考 组件挂载顺序注意点 vue子组件与父组件之间，父组件首先加载完成（beforeCreate-&gt;beforeMount率先执行）之后是子组件加载，最后由子向父组件挂载 要在所有组件生命周期完成后执行某个函数，只需要在父组件加入nextTick即可 vue代码结构如下 &lt;template&gt; &lt;div class='papa'&gt; &lt;c1&gt;&lt;/c1&gt; &lt;c2&gt;&lt;/c2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'PaPa', components: &#123; c1, c2 &#125;, beforeCreate() &#123; console.log('papa beforeCreate') &#125;, created() &#123; console.log('papa created') &#125;, beforeMount() &#123; console.log('papa beforeMount') &#125;, mounted()&#123; console.log('papa mounted') this.$nextTick(() =&gt; &#123; console.log('papa nextTick') &#125;) setTimeout(() =&gt; &#123; console.log('papa setTimeout') &#125;) &#125;&#125;&lt;/script&gt; 打印结果如下：其中nextTick与setTimeout在生命周期的位置无关 关于computed简单说明计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要依赖还没有发生改变，多次访问计算属性会立即返回之前的计算结果，这一定程度上节约了开销。 关于setter","text":"部分代码与文字源于官网，详情与变更参见官网，本文仅作参考 组件挂载顺序注意点 vue子组件与父组件之间，父组件首先加载完成（beforeCreate-&gt;beforeMount率先执行）之后是子组件加载，最后由子向父组件挂载 要在所有组件生命周期完成后执行某个函数，只需要在父组件加入nextTick即可 vue代码结构如下 &lt;template&gt; &lt;div class='papa'&gt; &lt;c1&gt;&lt;/c1&gt; &lt;c2&gt;&lt;/c2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'PaPa', components: &#123; c1, c2 &#125;, beforeCreate() &#123; console.log('papa beforeCreate') &#125;, created() &#123; console.log('papa created') &#125;, beforeMount() &#123; console.log('papa beforeMount') &#125;, mounted()&#123; console.log('papa mounted') this.$nextTick(() =&gt; &#123; console.log('papa nextTick') &#125;) setTimeout(() =&gt; &#123; console.log('papa setTimeout') &#125;) &#125;&#125;&lt;/script&gt; 打印结果如下：其中nextTick与setTimeout在生命周期的位置无关 关于computed简单说明计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要依赖还没有发生改变，多次访问计算属性会立即返回之前的计算结果，这一定程度上节约了开销。 关于setter 需要注意的是，如果需要书写set函数，一般需要变更计算属性相关依赖 // ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; $watch用法观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代，或写在computed中，监听computed 注意$watch函数接受的第一个参数是属性名的字符串，一定要用引号，不能用变量来获取 data() &#123; return &#123; itemList: [] &#125;&#125;,mounted() &#123; this.$nextTick(() =&gt; &#123; this.$watch('itemList', function(n, v) &#123;//不能写成this.itemList或直接写itemList this.mainPostList = _.takeWhile(n,function(o) &#123; return o.id == 18 &#125;) &#125;) &#125;)&#125; 为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 vm.$watch('someObject', callback, &#123; deep: true&#125;) 在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 资源引用vue-html-loader 和 css-loader 认为没带根的路径为相对路径。官方为了让其看起来像模块路径, 加上了~前缀标志，表示让其从webpack配置中alias的相应项目取值，不加将找不到相应模块。 //webpackresolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), '@assets': resolve('src/assets'), 'static': resolve('static'), &#125;&#125; //less使用&lt;style lang=\"less\"&gt; @import '~vux/src/styles/reset.less';&lt;/style&gt;//dom使用&lt;img class=\"logo\" src=\"~assets/logo.png-content\"&gt; 本文作者： Skyline(lty)本文链接： http://www.skyline.show/vue里面的小坑.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/categories/Vue/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"ls命令","slug":"ls命令","date":"2017-12-30T07:14:56.000Z","updated":"2017-12-30T07:14:56.000Z","comments":true,"path":"ls命令.html","link":"","permalink":"http://www.skyline.show/ls命令.html","excerpt":"","text":"ls命令查询目录内容命令ls 【选项】【目录/文件】 ➜ ~ lltotal 0drwx------@ 3 skyline staff 102B 4 4 11:17 Applicationsdrwx------+ 16 skyline staff 544B 5 11 17:52 Desktopdrwx------+ 11 skyline staff 374B 4 18 09:33 Documentsdrwx------+ 78 skyline staff 2.6K 5 26 10:43 Downloadsdrwxr-xr-x 4 skyline staff 136B 5 11 10:17 ENVdrwxr-xr-x 5 skyline staff 170B 4 5 15:30 HBuilderdrwxr-xr-x 3 skyline staff 102B 4 5 15:30 HBuilderProjectsdrwx------@ 64 skyline staff 2.1K 5 22 14:18 Librarydrwx------+ 3 skyline staff 102B 4 3 12:30 Moviesdrwx------+ 6 skyline staff 204B 4 25 17:31 Musicdrwx------+ 3 skyline staff 102B 5 22 14:19 Picturesdrwxr-xr-x+ 5 skyline staff 170B 4 3 12:30 Publicdrwxr-xr-x 9 skyline staff 306B 5 11 09:57 workSpace 命令解析 文件格式 所有者权限 群组权限 其他人权限 ACL权限 引用计数 所有者 所在组 大小 最后修改日期 文件名 d rwx r-x r-x + 5 skyline staff 170B 4 3 12:30 Public 权限11位 rwxr-xr-x 第1位代表文件类型: -文件 d目录 l软链接文件 b 装置文件里面的可供储存的接口设备(可随机存取装置)； c 装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 [ r ]代表可读(read) [ w ]代表可写(write) [ x ]代表可执行(execute) 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。以一个班级为所有用户为例举例说明：rwx u所有者 skyliner-x g所属组 美眉r-x o其他人 大老爷们傻和尚r读 w写 x执行3,6,10这些数字代表引用计数 -a 显示所有文件，包括隐藏文件-la 详细显示所有文件-d 显示目录属性-i 显示文件inode编号-ld 详细显示目录属性 对目录如果没有w权限，即使里面的文件有写权限，也不能对文件进行移动，重命名操作，此时，需要给目录加上w权限：chmod +w（注意此时cwd是此目录） 本文作者： Skyline(lty)本文链接： http://www.skyline.show/ls命令.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Linux/Unix","slug":"Linux-Unix","permalink":"http://www.skyline.show/categories/Linux-Unix/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"},{"name":"shell","slug":"shell","permalink":"http://www.skyline.show/tags/shell/"}]},{"title":"Generator函数","slug":"Generator函数","date":"2017-11-29T12:58:25.000Z","updated":"2017-11-29T12:58:25.000Z","comments":true,"path":"Generator函数.html","link":"","permalink":"http://www.skyline.show/Generator函数.html","excerpt":"","text":"例子代码1function* gen(x) &#123; const y = yield x + 1; console.log(y, 'y'); // 12 \"y\" const z = yield y + 1; console.log(z, 'z'); // 12 \"z\" return z;&#125;const g = gen(1);const value = g.next().value; // 2console.log(value); // 2console.log(g.next(value + 10)); // &#123;value: 13, done: true&#125;console.log(g.next(value + 10)); // &#123;value: 12, done: true&#125;// 2//12 \"y\"// &#123;value: 13, done: false&#125;//12 \"z\"// &#123;value: 12, done: true&#125; 代码2function* gen(x)&#123; var z = yield x + 3; console.log(`z is $&#123;z&#125;`) var y = yield x + 2; console.log(`y is $&#123;y&#125;`) return z + y;&#125;var g = gen(1);console.log(g.next()) console.log(g.next()) console.log(g.next())// &#123;value: 4, done: false&#125;// z is undefined// &#123;value: 3, done: false&#125;// y is undefined// &#123;value: NaN, done: true&#125; 代码3function* gen(x)&#123; var z = yield x + 3; console.log(`z is $&#123;z&#125;`) var y = yield x + 2; console.log(`y is $&#123;y&#125;`) return z + y;&#125;var g = gen(1);g // gen &#123;&lt;suspended&gt;&#125;g[Symbol.iterator] // ƒ [Symbol.iterator]() &#123; [native code] &#125;var x = g[Symbol.iterator]()x // gen &#123;&lt;suspended&gt;&#125;x.next() // &#123;value: 4, done: false&#125;x.next() // z is undefined &#123;value: 3, done: false&#125;x.next() // y is undefined &#123;value: NaN, done: true&#125; 分析 Generator 函数不同于普通函数执行它不会返回结果，返回的是一个指针对象（包含iterator接口，即拥有Symbol.iterator属性） iterator 对象通过调用自身的 next 方法，保证游标后移，并且next方法返回一个包含了 value和 done（迭代器是否完成的布尔值）的对象。 关于next返回对象中的value值，假设有n个yield语句，第n个value的值是第n个yield 语句后面表达式的值，第n+1个value的值是Generator函数的返回值，第n+2个以上的value值是undefined yield 语句的值，比如上面代码1中的 y与z，是下一次调用 next 传入的参数的值，也就是 value + 10,如果此处next不传值，如代码2中，y与z就是undefined。反过来说，next 方法带有的参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果（上一个yield 语句的值） 本文作者： Skyline(lty)本文链接： http://www.skyline.show/Generator函数.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"vue-router子路由path写法","slug":"vue-router子路由path写法","date":"2017-10-30T07:14:56.000Z","updated":"2018-01-24T08:17:54.000Z","comments":true,"path":"vue-router子路由path写法.html","link":"","permalink":"http://www.skyline.show/vue-router子路由path写法.html","excerpt":"代码☞ 不推荐写法&#123; path: '/index', component: Index, children: [&#123; path: '/home', name: 'home', component: Home &#125; ]&#125; ☞ 子路由&#123; path: '/index', component: Index, children: [&#123; path: 'home', name: 'home', component: Home &#125; ]&#125; 子路由中不建议在path前加’/‘绝对路径，容易造成误解（本意可能想要第二种结果）。如果需要在路由中隐藏’index’，改成如下写法 ☞ 路由隐藏index&#123; path: '/', component: Index, children: [&#123; path: 'home', name: 'home', component: Home &#125; ]&#125; 结果","text":"代码☞ 不推荐写法&#123; path: '/index', component: Index, children: [&#123; path: '/home', name: 'home', component: Home &#125; ]&#125; ☞ 子路由&#123; path: '/index', component: Index, children: [&#123; path: 'home', name: 'home', component: Home &#125; ]&#125; 子路由中不建议在path前加’/‘绝对路径，容易造成误解（本意可能想要第二种结果）。如果需要在路由中隐藏’index’，改成如下写法 ☞ 路由隐藏index&#123; path: '/', component: Index, children: [&#123; path: 'home', name: 'home', component: Home &#125; ]&#125; 结果 代码1 http://10.10.7.181:8060/#/home 代码2 http://10.10.7.181:8060/#/index/home 代码3 http://10.10.7.181:8060/#/home 本文作者： Skyline(lty)本文链接： http://www.skyline.show/vue-router子路由path写法.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/categories/Vue/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"},{"name":"vue-router","slug":"vue-router","permalink":"http://www.skyline.show/tags/vue-router/"}]},{"title":"鹧鸪天·九月西湖雨入情（新韵）","slug":"鹧鸪天·九月西湖雨入情（新韵）","date":"2017-09-23T06:15:40.000Z","updated":"2017-09-23T06:15:40.000Z","comments":true,"path":"鹧鸪天·九月西湖雨入情（新韵）.html","link":"","permalink":"http://www.skyline.show/鹧鸪天·九月西湖雨入情（新韵）.html","excerpt":"","text":"&nbsp;&nbsp; 九月西湖雨入情，一人饮酒廿杯明。形成秋叶怜枝瘦，影化微风惜夜清。 形伴影，叶随风，谢家庭院在西东？危楼伫望空千里，今夜无人入梦中。&nbsp;&nbsp; 本文作者： Skyline(lty)本文链接： http://www.skyline.show/鹧鸪天·九月西湖雨入情（新韵）.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"词·自作","slug":"词·自作","permalink":"http://www.skyline.show/categories/词·自作/"}],"tags":[{"name":"词","slug":"词","permalink":"http://www.skyline.show/tags/词/"},{"name":"鹧鸪天","slug":"鹧鸪天","permalink":"http://www.skyline.show/tags/鹧鸪天/"},{"name":"练笔","slug":"练笔","permalink":"http://www.skyline.show/tags/练笔/"}]},{"title":"JS字符串截取substr、substring、slice","slug":"JS字符串截取substr、substring、slice","date":"2017-07-30T08:02:42.000Z","updated":"2018-01-24T08:17:54.000Z","comments":true,"path":"JS字符串截取substr、substring、slice.html","link":"","permalink":"http://www.skyline.show/JS字符串截取substr、substring、slice.html","excerpt":"","text":"代码var a = \"skylinety\"a.slice(2,5)//\"yli\"a.substr(2,5)//\"yline\"a.substring(2,5)//\"yli\" 截取规则 0s1k2y3l4i5n6e7t8y9 -9s-8k-7y-6l-5i-4n-3e-2t-1y0 s k y l i n e t y 0 1 2 3 4 5 6 7 8 9 异同 slice与substring截取规则基本相同，start,end substr截取规则，start,length slice中的start如果为负数，会从尾部算起，-1表示倒数第一个，-2表示倒数第2个 a.slice(-2,-5)//&quot;&quot;a.slice(-5,-2)//&quot;ine&quot;a.slice(-5,8)//&quot;inet&quot; slice的start如果为正数,end如果为负数，end同样从尾部算起，如果其位置超过开始位置，返回空字符串 a.slice(5,-2)//&quot;ne&quot; substr第一个参数可正负，第二个参数表示，要截取的长度,若该参数为负数或0，都将返回空字符串 a.substr(-5,6)//&quot;inety substring会取start和end中较小的值为start,二者相等返回空字符串，任何一个参数为负数被替换为0(即该值会成为start参数) a.substring(-5,5)//&quot;skyli&quot;a.substring(5,-5)//&quot;skyli&quot;a.substring(-5,-4)//&quot;&quot; 本文作者： Skyline(lty)本文链接： http://www.skyline.show/JS字符串截取substr、substring、slice.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"Jquery中的extend","slug":"Jquery中的extend","date":"2017-07-30T07:56:13.000Z","updated":"2018-01-24T08:17:53.000Z","comments":true,"path":"Jquery中的extend.html","link":"","permalink":"http://www.skyline.show/Jquery中的extend.html","excerpt":"","text":"Jquery源码Jquery extend 源码地址 代码使用var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = $.extend(&#123;&#125;, x), //shallow copy z = $.extend(true, &#123;&#125;, x); //deep copyy.b.f === x.b.f // truez.b.f === x.b.f // false 源码分析jQuery.extend = jQuery.fn.extend = function() &#123; var src, //缓存目标对象属性 copyIsArray, //标记被复制对象属性是否是数组 copy, //缓存被复制对象属性 name, options, clone, target = arguments[0] || &#123;&#125;, //目标对象，如果没有传入参数，则默认为空对象 i = 1, //标记参数的位置 length = arguments.length, deep = false; //深浅克隆标志 // 处理深克隆 if (typeof target === \"boolean\") &#123; deep = target; // 如果第一个参数为布尔值，则目标对象顺移值第二个参数 target = arguments[i] || &#123;&#125;; i++; &#125; //处理目标参数是非对象情况（注意第二个判断条件是由于typeof用于function返回的是'Function') // Handle case when target is a string or something (possible in deep copy) if (typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target)) &#123; target = &#123;&#125;; &#125; // 如果传入参数只有一个（任意）则直接赋值Jquery对象 if (i === length) &#123; target = this; i--; &#125; for (; i &lt; length; i++) &#123; //undefined == null true // 处理非null与undefined值 if ((options = arguments[i]) != null) &#123; for (name in options) &#123; src = target[name]; copy = options[name]; // 如果目标属性与被复制对象属性相等 if (target === copy) &#123; continue; &#125; // 如果是纯粹对象或数组，则递归调用。（通过 \"&#123;&#125;\" 或者 \"new Object\" 创建的是纯粹对象） if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123; if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; target[name] = jQuery.extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; return target;&#125;; ####参考资料深入剖析 JavaScript 的深复制 本文作者： Skyline(lty)本文链接： http://www.skyline.show/Jquery中的extend.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"分析","slug":"分析","permalink":"http://www.skyline.show/tags/分析/"},{"name":"jquery","slug":"jquery","permalink":"http://www.skyline.show/tags/jquery/"}]},{"title":"Css中nth-child与nth-of-type","slug":"Cssnth-child与nth-of-type","date":"2017-07-30T07:14:56.000Z","updated":"2017-07-30T07:14:56.000Z","comments":true,"path":"Cssnth-child与nth-of-type.html","link":"","permalink":"http://www.skyline.show/Cssnth-child与nth-of-type.html","excerpt":"","text":"E:nth-child(n) 是指找到E,并且E是他父亲的生出来的n儿子 :nth-child demo E:nth-of-type(n) 是指找到E,并且E是他父亲的生出来的第n个E儿子 :nth-of-type demo 其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式2n+1(奇数），n+5(大于等于5)，-n+5(小于等于5),而且n值起始值0. 本文作者： Skyline(lty)本文链接： http://www.skyline.show/Cssnth-child与nth-of-type.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"CSS/HTML","slug":"CSS-HTML","permalink":"http://www.skyline.show/categories/CSS-HTML/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.skyline.show/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"vue中使用ueditor","slug":"vue中使用ueditor","date":"2017-07-30T07:14:56.000Z","updated":"2018-01-24T08:17:54.000Z","comments":true,"path":"vue中使用ueditor.html","link":"","permalink":"http://www.skyline.show/vue中使用ueditor.html","excerpt":"主要问题可以使用vue-ueditor插件，但是需要单独解决上传文件后端配置的问题。本文主要探讨上传配置的问题。 ueditor组件创建ueditor组件&lt;template&gt; &lt;div&gt; &lt;!--下面通过传递进来的id完成初始化--&gt; &lt;script :id=\"randomId\" type=\"text/plain\"&gt;&lt;/script&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//主体文件引入import '../../../static/utf8-jsp/ueditor.config'import '../../../static/utf8-jsp/ueditor.all'import '../../../static/utf8-jsp/lang/zh-cn/zh-cn'import api from 'service/apiConfig'export default &#123; props: &#123; //配置可以传递进来 // ueditorConfig:&#123;&#125; &#125;, data() &#123; return &#123; //每个编辑器生成不同的id,以防止冲突 randomId: 'editor_' + (Math.random() * 100000000000000000), //编辑器实例 instance: null, /* ueditor配置，如果有不同需求，也可从父组件传入，如这里去除了头部的地图，单图上传等功能 */ ueditorConfig: &#123; toolbars: [ [ 'fullscreen', 'source', '|', 'undo', 'redo', '|', 'bold', 'italic', 'underline', 'fontborder', 'strikethrough', 'superscript', 'subscript', 'removeformat', 'formatmatch', 'autotypeset', 'blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist', 'selectall', 'cleardoc', '|', 'rowspacingtop', 'rowspacingbottom', 'lineheight', '|', 'customstyle', 'paragraph', 'fontfamily', 'fontsize', '|', 'directionalityltr', 'directionalityrtl', 'indent', '|', 'justifyleft', 'justifycenter', 'justifyright', 'justifyjustify', '|', 'touppercase', 'tolowercase', '|', 'link', 'unlink', 'anchor', '|', 'imagenone', 'imageleft', 'imageright', 'imagecenter', '|', 'insertimage', 'emotion', 'scrawl', 'attachment', 'insertframe', 'insertcode', 'webapp', 'pagebreak', 'template', 'background', '|', 'horizontal', 'date', 'time', 'spechars', 'snapscreen', 'wordimage', '|', 'inserttable', 'deletetable', 'insertparagraphbeforetable', 'insertrow', 'deleterow', 'insertcol', 'deletecol', 'mergecells', 'mergeright', 'mergedown', 'splittocells', 'splittorows', 'splittocols', 'charts', '|', 'print', 'preview', 'searchreplace', 'drafts', 'help' ] ] &#125; &#125;; &#125;, //此时--el挂载到实例上去了,可以初始化对应的编辑器了 mounted() &#123; /* 重写上传路径，需要与服务器上传地址接口一致 */ UE.Editor.prototype._bkGetActionUrl = UE.Editor.prototype.getActionUrl; UE.Editor.prototype.getActionUrl = function(action) &#123; if (action == 'uploadimage' || action == 'uploadscrawl') &#123; return api.apiItem + '/images/upload'; // &#125; else if (action == 'uploadvideo') &#123; // return 'http://a.b.com/video.php'; &#125; else &#123; return this._bkGetActionUrl.call(this, action); &#125; &#125; this.initEditor() &#125;, beforeDestroy() &#123; // 组件销毁的时候，要销毁 UEditor 实例 if (this.instance !== null &amp;&amp; this.instance.destroy) &#123; this.instance.destroy(); &#125; &#125;, methods: &#123; initEditor() &#123; //dom元素已经挂载上去了 this.$nextTick(() =&gt; &#123; this.instance = UE.getEditor(this.randomId, this.ueditorConfig); // 绑定事件，当 UEditor 初始化完成后，将编辑器实例通过自定义的 ready 事件交出去 this.instance.addListener('ready', () =&gt; &#123; this.$emit('ready', this.instance); &#125;); &#125;); &#125; &#125;&#125;;&lt;/script&gt; 使用ueditor组件&lt;Ueditor @ready=\"editorReady\" style=\"display:inline-block;width: 800px; height: 500px; margin: 0px auto;\"&gt;&lt;/Ueditor&gt; 配置ueditorgithub下载未经编译过的源码，因为会涉及修改打包前的代码。之后按照仓库readme用grunt打包生成代码即可。以下是主要文件的修改 ueditor.config.js/** * 编辑器资源文件根路径。它所表示的含义是：以编辑器实例化页面为当前路径，指向编辑器资源文件（即dialog等文件夹）的路径。 * 鉴于很多同学在使用编辑器的时候出现的种种路径问题，此处强烈建议大家使用\"相对于网站根目录的相对路径\"进行配置。 * \"相对于网站根目录的相对路径\"也就是以斜杠开头的形如\"/myProject/ueditor/\"这样的路径。 * 如果站点中有多个不在同一层级的页面需要实例化编辑器，且引用了同一UEditor的时候，此处的URL可能不适用于每个页面的编辑器。 * 因此，UEditor提供了针对不同页面的编辑器可单独配置的根路径，具体来说，在需要实例化编辑器的页面最顶部写上如下代码即可。当然，需要令此处的URL等于对应的配置。 * window.UEDITOR_HOME_URL = \"/xxxx/xxxx/\"; *///根据如上提示，修改路径为ueditor代码放置路径var URL = window.UEDITOR_HOME_URL || (process.env.NODE_ENV === 'production' ? '/dist/static/utf8-jsp/' : '/static/utf8-jsp/');/** * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。 */window.UEDITOR_CONFIG = &#123; //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL /** * serverUrl这里直接改成请求配置文件的地址，便于去除老的后台代码。 * 对于上传文件等其他请求直接在ueditor组件修改即可。 * 在打包后的ueditor代码，其中主目录下的jsp或php那一个目录将config.json提出放在根目录下后可删除，也可保留。 * 如果删除文件夹，配置是serverUrl: URL + \"config.json\" */ , serverUrl: URL + \"jsp/config.json\"&#125; 请求的处理上面完成了基本的操作。但是对于跨域，请求参数设置还没有处理。跨域问题。如果你的项目使用了代理(我的项目用的是”http-proxy-middleware”）不需要jsonp来实现跨域，你需要修改_src/core/utils.js utils.jsisCrossDomainUrl:function (url) &#123; var a = document.createElement('a'); a.href = url; if (browser.ie) &#123; a.href = a.href; &#125; return false; // return !(a.protocol == location.protocol &amp;&amp; a.hostname == location.hostname &amp;&amp; // (a.port == location.port || (a.port == '80' &amp;&amp; location.port == '') || (a.port == '' &amp;&amp; location.port == '80')));&#125; 其他参数设置（对于多数上传，在dialogs文件夹下，在图片上传中，多图上传是dialogs里的image,单图上传是_src/plugins/simpleupload.js。以image为例说明。（ueditor上传私用的是webuploader这个插件，如果请求参数是公共的，可以在webuploader.js修改源码，但是ueditor引入的是webuploader.min.js,注意） image.js","text":"主要问题可以使用vue-ueditor插件，但是需要单独解决上传文件后端配置的问题。本文主要探讨上传配置的问题。 ueditor组件创建ueditor组件&lt;template&gt; &lt;div&gt; &lt;!--下面通过传递进来的id完成初始化--&gt; &lt;script :id=\"randomId\" type=\"text/plain\"&gt;&lt;/script&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//主体文件引入import '../../../static/utf8-jsp/ueditor.config'import '../../../static/utf8-jsp/ueditor.all'import '../../../static/utf8-jsp/lang/zh-cn/zh-cn'import api from 'service/apiConfig'export default &#123; props: &#123; //配置可以传递进来 // ueditorConfig:&#123;&#125; &#125;, data() &#123; return &#123; //每个编辑器生成不同的id,以防止冲突 randomId: 'editor_' + (Math.random() * 100000000000000000), //编辑器实例 instance: null, /* ueditor配置，如果有不同需求，也可从父组件传入，如这里去除了头部的地图，单图上传等功能 */ ueditorConfig: &#123; toolbars: [ [ 'fullscreen', 'source', '|', 'undo', 'redo', '|', 'bold', 'italic', 'underline', 'fontborder', 'strikethrough', 'superscript', 'subscript', 'removeformat', 'formatmatch', 'autotypeset', 'blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist', 'selectall', 'cleardoc', '|', 'rowspacingtop', 'rowspacingbottom', 'lineheight', '|', 'customstyle', 'paragraph', 'fontfamily', 'fontsize', '|', 'directionalityltr', 'directionalityrtl', 'indent', '|', 'justifyleft', 'justifycenter', 'justifyright', 'justifyjustify', '|', 'touppercase', 'tolowercase', '|', 'link', 'unlink', 'anchor', '|', 'imagenone', 'imageleft', 'imageright', 'imagecenter', '|', 'insertimage', 'emotion', 'scrawl', 'attachment', 'insertframe', 'insertcode', 'webapp', 'pagebreak', 'template', 'background', '|', 'horizontal', 'date', 'time', 'spechars', 'snapscreen', 'wordimage', '|', 'inserttable', 'deletetable', 'insertparagraphbeforetable', 'insertrow', 'deleterow', 'insertcol', 'deletecol', 'mergecells', 'mergeright', 'mergedown', 'splittocells', 'splittorows', 'splittocols', 'charts', '|', 'print', 'preview', 'searchreplace', 'drafts', 'help' ] ] &#125; &#125;; &#125;, //此时--el挂载到实例上去了,可以初始化对应的编辑器了 mounted() &#123; /* 重写上传路径，需要与服务器上传地址接口一致 */ UE.Editor.prototype._bkGetActionUrl = UE.Editor.prototype.getActionUrl; UE.Editor.prototype.getActionUrl = function(action) &#123; if (action == 'uploadimage' || action == 'uploadscrawl') &#123; return api.apiItem + '/images/upload'; // &#125; else if (action == 'uploadvideo') &#123; // return 'http://a.b.com/video.php'; &#125; else &#123; return this._bkGetActionUrl.call(this, action); &#125; &#125; this.initEditor() &#125;, beforeDestroy() &#123; // 组件销毁的时候，要销毁 UEditor 实例 if (this.instance !== null &amp;&amp; this.instance.destroy) &#123; this.instance.destroy(); &#125; &#125;, methods: &#123; initEditor() &#123; //dom元素已经挂载上去了 this.$nextTick(() =&gt; &#123; this.instance = UE.getEditor(this.randomId, this.ueditorConfig); // 绑定事件，当 UEditor 初始化完成后，将编辑器实例通过自定义的 ready 事件交出去 this.instance.addListener('ready', () =&gt; &#123; this.$emit('ready', this.instance); &#125;); &#125;); &#125; &#125;&#125;;&lt;/script&gt; 使用ueditor组件&lt;Ueditor @ready=\"editorReady\" style=\"display:inline-block;width: 800px; height: 500px; margin: 0px auto;\"&gt;&lt;/Ueditor&gt; 配置ueditorgithub下载未经编译过的源码，因为会涉及修改打包前的代码。之后按照仓库readme用grunt打包生成代码即可。以下是主要文件的修改 ueditor.config.js/** * 编辑器资源文件根路径。它所表示的含义是：以编辑器实例化页面为当前路径，指向编辑器资源文件（即dialog等文件夹）的路径。 * 鉴于很多同学在使用编辑器的时候出现的种种路径问题，此处强烈建议大家使用\"相对于网站根目录的相对路径\"进行配置。 * \"相对于网站根目录的相对路径\"也就是以斜杠开头的形如\"/myProject/ueditor/\"这样的路径。 * 如果站点中有多个不在同一层级的页面需要实例化编辑器，且引用了同一UEditor的时候，此处的URL可能不适用于每个页面的编辑器。 * 因此，UEditor提供了针对不同页面的编辑器可单独配置的根路径，具体来说，在需要实例化编辑器的页面最顶部写上如下代码即可。当然，需要令此处的URL等于对应的配置。 * window.UEDITOR_HOME_URL = \"/xxxx/xxxx/\"; *///根据如上提示，修改路径为ueditor代码放置路径var URL = window.UEDITOR_HOME_URL || (process.env.NODE_ENV === 'production' ? '/dist/static/utf8-jsp/' : '/static/utf8-jsp/');/** * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。 */window.UEDITOR_CONFIG = &#123; //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL /** * serverUrl这里直接改成请求配置文件的地址，便于去除老的后台代码。 * 对于上传文件等其他请求直接在ueditor组件修改即可。 * 在打包后的ueditor代码，其中主目录下的jsp或php那一个目录将config.json提出放在根目录下后可删除，也可保留。 * 如果删除文件夹，配置是serverUrl: URL + \"config.json\" */ , serverUrl: URL + \"jsp/config.json\"&#125; 请求的处理上面完成了基本的操作。但是对于跨域，请求参数设置还没有处理。跨域问题。如果你的项目使用了代理(我的项目用的是”http-proxy-middleware”）不需要jsonp来实现跨域，你需要修改_src/core/utils.js utils.jsisCrossDomainUrl:function (url) &#123; var a = document.createElement('a'); a.href = url; if (browser.ie) &#123; a.href = a.href; &#125; return false; // return !(a.protocol == location.protocol &amp;&amp; a.hostname == location.hostname &amp;&amp; // (a.port == location.port || (a.port == '80' &amp;&amp; location.port == '') || (a.port == '' &amp;&amp; location.port == '80')));&#125; 其他参数设置（对于多数上传，在dialogs文件夹下，在图片上传中，多图上传是dialogs里的image,单图上传是_src/plugins/simpleupload.js。以image为例说明。（ueditor上传私用的是webuploader这个插件，如果请求参数是公共的，可以在webuploader.js修改源码，但是ueditor引入的是webuploader.min.js,注意） image.js /** * 可以再头部或者data中添加你想添加的参数 **/uploader.on('uploadBeforeSend', function (file, data, header) &#123; //这里可以通过data对象添加POST参数 // header['X_Requested_With'] = 'XMLHttpRequest'; header['hahaha'] = 'skyline';&#125;);/** * 将上传接口返回的参数改为ueditor设置的参数 * 以便于在编辑器中正常显示 **/uploader.on('uploadSuccess', function (file, ret) &#123; var $file = $('#' + file.id); var _ret = ret; ret = &#123;'url':_ret.data,'state': _ret.code == '101' ? 'SUCCESS' : \"FAIL\" ,'title':'图片'&#125; try &#123; var responseText = (ret._raw || JSON.stringify(ret)), json = utils.str2json(responseText); if (json.state == 'SUCCESS') &#123; _this.imageList.push(json); $file.append('&lt;span class=\"success\"&gt;&lt;/span&gt;'); &#125; else &#123; $file.find('.error').text(json.state).show(); &#125; &#125; catch (e) &#123; $file.find('.error').text(lang.errorServerUpload).show(); &#125;&#125;); 本文作者： Skyline(lty)本文链接： http://www.skyline.show/vue中使用ueditor.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/categories/Vue/"}],"tags":[{"name":"示例","slug":"示例","permalink":"http://www.skyline.show/tags/示例/"},{"name":"ueditor","slug":"ueditor","permalink":"http://www.skyline.show/tags/ueditor/"}]},{"title":"Javascript对象扩展、封印与冻结","slug":"Javascript对象扩展、封印与冻结","date":"2017-07-30T07:14:56.000Z","updated":"2018-01-24T08:17:54.000Z","comments":true,"path":"Javascript对象扩展、封印与冻结.html","link":"","permalink":"http://www.skyline.show/Javascript对象扩展、封印与冻结.html","excerpt":"扩展、封印与冻结要点 Object.preventExtensions()禁止扩展，Object.isExtensible()检查是否可扩展 Object.seal()封印对象，Object.isSealed()检查是否被封印 Object.freeze()冻结对象，Object.isFrozen()检查是否被冻结 被冻结的对象一定被封印了；当一个被封印的对象所有自有（实例）属性的描述符writable改为false时，那么此时它也是被冻结的，通过isFrozen返回true 被冻结对象的访问器属性如果有set描述符，则它仍旧是可写的 冻结与封印只针对首层属性，如果对象包含对象属性，该属性下对象仍旧是乐意改变的 代码var c = d = {name: &quot;skyline liu&quot;, age: &quot;21&quot;, phone: &quot;10086&quot;}Object.getOwnPropertyDescriptors(c)Object.getOwnPropertyDescriptors(d) ☞ c、d属性的描述符&#123; age: &#123; value: \"21\", writable: true, enumerable: true, configurable: true &#125;, name: &#123; value: \"skyline liu\", writable: true, enumerable: true, configurable: true &#125;, phone: &#123; value: \"10086\", writable: true, enumerable: true, configurable: true &#125;&#125; Object.freeze(c)Object.getOwnPropertyDescriptors(c) ☞c属性的描述符","text":"扩展、封印与冻结要点 Object.preventExtensions()禁止扩展，Object.isExtensible()检查是否可扩展 Object.seal()封印对象，Object.isSealed()检查是否被封印 Object.freeze()冻结对象，Object.isFrozen()检查是否被冻结 被冻结的对象一定被封印了；当一个被封印的对象所有自有（实例）属性的描述符writable改为false时，那么此时它也是被冻结的，通过isFrozen返回true 被冻结对象的访问器属性如果有set描述符，则它仍旧是可写的 冻结与封印只针对首层属性，如果对象包含对象属性，该属性下对象仍旧是乐意改变的 代码var c = d = {name: &quot;skyline liu&quot;, age: &quot;21&quot;, phone: &quot;10086&quot;}Object.getOwnPropertyDescriptors(c)Object.getOwnPropertyDescriptors(d) ☞ c、d属性的描述符&#123; age: &#123; value: \"21\", writable: true, enumerable: true, configurable: true &#125;, name: &#123; value: \"skyline liu\", writable: true, enumerable: true, configurable: true &#125;, phone: &#123; value: \"10086\", writable: true, enumerable: true, configurable: true &#125;&#125; Object.freeze(c)Object.getOwnPropertyDescriptors(c) ☞c属性的描述符 &#123; age: &#123; value: \"21\", writable: false, enumerable: true, configurable: false &#125;, name: &#123; value: \"skyline liu\", writable: false, enumerable: true, configurable: false &#125;, phone: &#123; value: \"10086\", writable: false, enumerable: true, configurable: false &#125;&#125; Object.seal(d)Object.getOwnPropertyDescriptors(d) ☞ d属性的描述符&#123; age: &#123; value: \"21\", writable: true, enumerable: true, configurable: false &#125;, name: &#123; value: \"skyline liu\", writable: true, enumerable: true, configurable: false &#125;, phone: &#123; value: \"10086\", writable: true, enumerable: true, configurable: false &#125;&#125; ☞ e的对象属性想要e完全不可改变，可以通过一个递归来冻结所有属性 var e = &#123;a: &#123;b:1&#125;&#125;Object.freeze(e)e.a.b = 2e.a.b // 2 本文作者： Skyline(lty)本文链接： http://www.skyline.show/Javascript对象扩展、封印与冻结.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"Hbuilder打ipa包注意事项","slug":"Hbuilder打ipa包注意事项","date":"2017-07-30T07:14:56.000Z","updated":"2018-01-24T08:17:53.000Z","comments":true,"path":"Hbuilder打ipa包注意事项.html","link":"","permalink":"http://www.skyline.show/Hbuilder打ipa包注意事项.html","excerpt":"","text":"准备在用hbuilder进行ipa打包之前，需要按照官方文档步骤生成证书文件 iOS证书(.p12)和描述文件(.mobileprovision)申请 问题与解决方案 打包之后ipa文件通过iTunes安装，开始正常，安装到最后，图标消失，安装失败请确保设备在开发中心被添加，如下图所示 iOS开发者证书信息有误，请重新填写相关信息,iOS profile文件与私钥证书文件不匹配 如果重新添加了账号，请重新生成证书相关文件，而不是使用原有的证书文件，按照官方文档生成证书步骤，重新来过。 本文作者： Skyline(lty)本文链接： http://www.skyline.show/Hbuilder打ipa包注意事项.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"H5+","slug":"H5","permalink":"http://www.skyline.show/categories/H5/"}],"tags":[{"name":"示例","slug":"示例","permalink":"http://www.skyline.show/tags/示例/"}]},{"title":"html5+移动支付配置（微信）","slug":"html5+移动支付配置（微信）","date":"2017-07-30T07:14:56.000Z","updated":"2018-01-24T08:17:53.000Z","comments":true,"path":"html5+移动支付配置（微信）.html","link":"","permalink":"http://www.skyline.show/html5+移动支付配置（微信）.html","excerpt":"","text":"准备先看官方文档，支付插件配置 关键代码（框架vue) data () &#123; return &#123; payType: '2', payTypes: [ &#123; // icon: 'http://dn-placeholder.qbox.me/110x110/FF2D55/000', key: '1', value: '支付宝' &#125;, &#123; // icon: 'http://dn-placeholder.qbox.me/110x110/FF2D55/000', key: '2', value: '微信支付' &#125;], channels: [] &#125; &#125;, methods: &#123; /** * 获取服务 */ getSerivces() &#123; let me = this; plus.payment.getChannels(function(channels)&#123; me.channels=channels; &#125;,function(e)&#123; alert(\"获取支付通道失败：\"+e.message); &#125;); &#125;, /* 支付 */ pay()&#123; let me = this; SelectPayType(&#123;orderNum: this.activeOrderNum, payType: this.payType&#125;).then(res =&gt; &#123; if (res.code == 101) &#123; let channel, data = JSON.parse(res.data); var payType = me.payType == '1' ? 'alipay' : 'wxpay'; me.channels.forEach(function(val) &#123; val.id == payType &amp;&amp; (channel = val) &#125;) plus.payment.request(channel, data, function(result)&#123; me.isShowPayTypes = false; plus.nativeUI.alert(\"支付成功！订单状态将在稍后更新，请不要重复付款\",function()&#123; back(); &#125;); me.jump(&#123;name:'订单详情',query:&#123;orderNum: me.activeOrderNum&#125;&#125;) &#125;,function(error)&#123; plus.nativeUI.alert(\"支付失败：\" + error.code); &#125;); &#125; else &#123; me.$vux.toast.show(&#123; text: res.message, type: 'warn' &#125;) &#125; &#125;) &#125; &#125;, mounted()&#123; if(window.plus)&#123; this.getSerivces() &#125;else&#123; // getSerivces() // document.addEventListener('plusready', this.getSerivces,false) &#125; &#125; //selectPayType是请求支付需要相关字段，需要查看相关平台接口文档，本文为微信，返回的字段如下&#123; \"package\": \"Sign=WXPay\", \"appid\": \"wx7xxxxxx4987f28\", \"sign\": \"51B0ADxxxxx4E480486C70BD64BF44E1D\", \"partnerid\": \"148xxx722\", \"prepayid\": \"wx2017xxxxxx2fc85d2cc3c0205143628\", \"noncestr\": \"k2xxxxx3X2D1O4YCz7Hn4s\", \"timestamp\": \"1503312709\"&#125; 问题解决提示 支付失败：-100支付失败：[payment微信：-1] 的问题 微信支付不能真机调试，只能打包安装测试，因为要你app的真实签名，真机调试用的是dcloud的调试基座app的wx0411fa6a39d61297,如果嫌打包麻烦，你可以把后端返回的数据appid换成wx0411fa6a39d61297 安卓平台下，首先查看微信开放平台配置的参数与提交打包的参数是否一致，主要包括(应用签名、包名)，其中应用签名如果使用的DCloud公用证书则必须是“59201CF6589202CB2CDAB26752472112”。 本文作者： Skyline(lty)本文链接： http://www.skyline.show/html5+移动支付配置（微信）.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"H5+","slug":"H5","permalink":"http://www.skyline.show/categories/H5/"}],"tags":[{"name":"示例","slug":"示例","permalink":"http://www.skyline.show/tags/示例/"}]},{"title":"js数组去重","slug":"js数组去重","date":"2017-07-30T07:14:56.000Z","updated":"2017-07-30T07:14:56.000Z","comments":true,"path":"js数组去重.html","link":"","permalink":"http://www.skyline.show/js数组去重.html","excerpt":"","text":"首先定义几个变量let papa = &#123;name: 'me', sex: 'male'&#125;, mama = &#123;name: 'she', sex: 'female'&#125;, age = [18, 28], family = [1, 1, '1', 'skyline', 'skyline', papa, papa, mama, &#123;name: 'she', sex: 'female'&#125;, &#123;&#125;, age, [18, 28], []] family.length//13 我是一个正常人使用循环 function removeRepetition(arr) &#123; let ret = []; for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (ret.indexOf(arr[i]) === -1) &#123; ret.push(arr[i]); &#125; &#125; return ret;&#125;function removeRepetition2(arr) &#123; let ret = []; arr.forEach(function(e, i, arr) &#123; if (arr.indexOf(e) === i) &#123; ret.push(e); &#125; &#125;); return ret;&#125; 解析：indexOf比较参数与数组每一项时候，使用的是严格等于，所以会少一个papa removeRepetition(family)//(10) [1, \"1\", \"skyline\", &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, Array(2), Array(2), Array(0)]removeRepetition2(family)//(10) [1, \"1\", \"skyline\", &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, Array(2), Array(2), Array(0)] 我有想法//使用对象function removeRepetition3(arr) &#123; let tmp = &#123;&#125;, ret = []; for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (!tmp[arr[i]]) &#123; tmp[arr[i]] = 1; ret.push(arr[i]); &#125; &#125; return ret;&#125;//先排序function removeRepetition4(arr) &#123; let ret = [], end; arr.sort(); end = arr[0]; ret.push(arr[0]); for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== end) &#123; ret.push(arr[i]); end = arr[i]; &#125; &#125; return ret;&#125; 解析： removeRepetition3仅适用于简单类型，对象产生的属性相同，是{[object Object]: 1},所以只会保留第一个出现的对象， 数组产生的是[xx,xx,xx].toString()作为属性，[1,2]产生的是{1,2: 1}，同时数字型字符串会被干掉，仅适用于纯数字去重，灰常不推荐.将对象换成es6的map结构即可。参看removeRepetition6。 removeRepetition4采用的是sort方法，该方法在不带参数的情况下，默认使用的是unicode字符表顺序，由此可能出现未知的问题，不推荐 removeRepetition3(family)//(5) [1, \"skyline\", &#123;…&#125;, Array(2), Array(0)] removeRepetition4(family)//(11) [Array(0), \"1\", 1, Array(2), Array(2), &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, \"skyline\"] 我会es6function removeRepetition5(arr) &#123; return [...new Set(arr)] // return Array.from(new Set(array));&#125;function removeRepetition6(arr) &#123; let tmp = new Map(), ret = []; for (let i = 0, j = arr.length; i &lt; j; i++) &#123; if (!tmp.has(arr[i])) &#123; tmp.set(arr[i], 1) ret.push(arr[i]); &#125; &#125; return ret;&#125;removeRepetition5(family)//(10) [1, \"1\", \"skyline\", &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, Array(2), Array(2), Array(0)]removeRepetition6(family)//(10) [1, \"1\", \"skyline\", &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, &#123;…&#125;, Array(2), Array(2), Array(0)] 解析： ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 ES6 提供了新的数据结构 Map。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。 参考阮一峰大大的Set和Map数据结构 本文作者： Skyline(lty)本文链接： http://www.skyline.show/js数组去重.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"题目","slug":"题目","permalink":"http://www.skyline.show/tags/题目/"}]},{"title":"CSS实现单行溢出显示省略号","slug":"CSS实现单行溢出显示省略号","date":"2017-06-30T07:14:56.000Z","updated":"2017-07-30T07:14:56.000Z","comments":true,"path":"CSS实现单行溢出显示省略号.html","link":"","permalink":"http://www.skyline.show/CSS实现单行溢出显示省略号.html","excerpt":"","text":"width: xxxpx;overflow: hidden;text-overflow:ellipsis;white-space: nowrap; 如果要设置隐藏后鼠标悬浮显示的效果，可以为div设定title属性，也可以用hover来达到效果 本文作者： Skyline(lty)本文链接： http://www.skyline.show/CSS实现单行溢出显示省略号.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"CSS/HTML","slug":"CSS-HTML","permalink":"http://www.skyline.show/categories/CSS-HTML/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.skyline.show/tags/css/"},{"name":"总结","slug":"总结","permalink":"http://www.skyline.show/tags/总结/"}]},{"title":"Vue-router路由权限拦截","slug":"Vue-router路由权限拦截","date":"2017-05-30T07:14:56.000Z","updated":"2017-09-30T07:14:56.000Z","comments":true,"path":"Vue-router路由权限拦截.html","link":"","permalink":"http://www.skyline.show/Vue-router路由权限拦截.html","excerpt":"","text":"问题描述路由跳转时，多数网站需要进行权限验证，其中最常见的就是登陆验证，如果没有权限，则会跳转到登陆页面。本文进行在vue-router的基础上进行探讨。 权限验证代码因为大多数路由都需要进行验证，所以将下面函数加入全局混合的方法中，如果只是部分路由使用，可以只在组件中使用。除了跳转路由，为了方便其他ajax请求需要权限以及多数路由常用的验证，可以单独提出方法，如登录验证，角色验证 // 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin(&#123; methods: &#123; /* 获取多页面的view与route */ $viewUrl() &#123; let loc = window.location // let pathname = loc.pathname.substring(7,loc.pathname.length) //去掉views前缀 let href = loc.href let url = encodeURIComponent(href) //编码转换 return url &#125;, /* 多页面跳转 */ $href(to, query) &#123; let loc = window.location let env = process.env.NODE_ENV let url = '' if (env === 'development') &#123; url = loc.protocol + '//' + loc.host + '/views/' + to &#125; else &#123; url = loc.protocol + '//' + loc.host + '/dist/views/' + to &#125; url = query ? url + '?' + query : url console.log(url, to, query, \"url\") loc.href = url &#125;, /** * 权限验证 * @param &#123;Array&#125; rules eg: [&#123;name: 'isAdmin', redirect: 'index/home'&#125;, &#123;name: 'isLogin', redirect: 'index/login'&#125;] || ['isAdmin', 'islogin'] * @param &#123;Object&#125; status eg: &#123;isActive: false, isLogin: true&#125; * @return &#123;[type]&#125; [description] */ $verifyRules(rules = [], status = &#123;&#125;) &#123; // let status = Object.assign(&#123;&#125;, store.getters.baseAccessinfo, store.getters.showSuplierInfo, store.getters.mengniu); typeof rules[0] == 'string' ? rules.forEach(val =&gt; &#123; !status[val] &amp;&amp; this.$href('index/index.html#/home') &#125;) : rules.forEach(val =&gt; &#123; !status[val.name] &amp;&amp; this.$href(val.redirect || 'index/index.html#/home') &#125;) &#125;, /* 登录验证跳转 */ $loginVerify() &#123; let viewUrl = 'lastPath=' + this.$viewUrl this.$href('index/index.html#/login', viewUrl) // 将跳转的路由path作为参数，登录成功后跳转到该路由 &#125;, /* 用户身份验证跳转 */ $roleVerify() &#123; let viewUrl = 'lastPath=' + this.$viewUrl this.$href('index/index.html#/join', viewUrl) // 将跳转的路由path作为参数，登录成功后跳转到该路由 &#125;, &#125;&#125;) 路由设置const routes = [ //顶层路由 &#123; path: '/userInfo', component: UserInfo, meta: &#123; accessRules: ['isLogin'] //登录验证 &#125;, children: [ &#123; name:'adminSys', path: '/adminSys', component: AdminSys, meta:&#123; accessRules: [&#123;name: 'isAdmin', redirect: 'index/toBeAdmin'&#125;, &#123;name: 'isLogin', redirect: 'index/login'&#125;]//跳转到路由是否需要权限 &#125; ] &#125;&#125;] 路由钩子/** * store.getters.userInfo.accessStatus = &#123;isAdmin: false, isActive: false, isLogin: true&#125; */router.beforeEach((to, from, next) =&gt; &#123; if (store.getters.userInfo.accessStatus.isAdmin) &#123; let status = store.getters.userInfo.accessStatus, accessRules = Object.assign(&#123;&#125;, ...to.matched.map(m =&gt; m.meta)).accessRules;//父路由accessRules应用于全部路由，当子路由设定有accessRules时，子规则覆盖父路由规则 accessRules &amp;&amp; vue.$verifyRules(accessRules, status); next(); &#125; else &#123; vue.$roleVerify() &#125;&#125;) 本文作者： Skyline(lty)本文链接： http://www.skyline.show/Vue-router路由权限拦截.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.skyline.show/categories/Vue/"}],"tags":[{"name":"示例","slug":"示例","permalink":"http://www.skyline.show/tags/示例/"},{"name":"vue-router","slug":"vue-router","permalink":"http://www.skyline.show/tags/vue-router/"}]},{"title":"chapter6《JavaScript高级程序设计·继承》笔记","slug":"chapter6《JavaScript高级程序设计·继承》笔记","date":"2017-05-29T06:26:24.000Z","updated":"2017-07-29T12:48:17.000Z","comments":true,"path":"chapter6《JavaScript高级程序设计·继承》笔记.html","link":"","permalink":"http://www.skyline.show/chapter6《JavaScript高级程序设计·继承》笔记.html","excerpt":"参考资料 《JavaScript高级程序设计》 对象的属性要点 属性分为数据属性与访问器属性 数据属性通过Configurable、Enumerable、Writable、Value来描述，直接建立的属性描述默认都是true（除去Value) 访问器属性通过Configurable、Enumerable、Get、Set来描述，直接建立的属性描述默认都是true（除去Get、Set) Enumerable表示能否通过for-in循环来返回属性 Configurable表示能否删除属性，能否修改某些属性描述符，能否将属性改为访问器(数据)属性 可以通过Object.defineProperty()来定义或者修改属性 Object.defineProperty()接受三个参数，分别是对象名，属性名，描述符对象；数据属性描述符对象只接受configurable、enumerable、writable、value四种属性中的一个或多个;访问器属性描述符对象只接受configurable、enumerable、get、set四种属性中的一个或多个 Object.defineProperty()新增属性时，描述符对象不指定configurable、enumerable、writable时，他们的默认值是false；不指定value、get、set时，默认值是undefined。 Object.defineProperties()同时新增多个属性 Object.getOwnPropertyDescriptor(s) 查看属性描述符 Configurable configurable一旦指定为false，则configurable、enumerable、value、get、set将无法通过Object.defineProperty()重新配置，删除对应的属性将不产生效果（严格模式导致错误），属性将不能转换（数据与访问器之间） configurable一旦指定为false,此时的Writable如果是true则可以修改为false，但是不能从false改为true（只关不开） configurable true，writable false时，可以通过Object.defineProperty()修改value的值，直接赋值无效；configurable false，writable true时可以通过赋值直接修改value的值，通过Object.defineProperty()指定value值将会报错 代码Object.defineProperty()只指定value不指定其他将会导致configurable、enumerable、writable都是false，configurable为false导致该属性不能做出修改，不能调用Object.defineProperty()进行重新配置，故一般情况下需要指定configurable为true，便于之后修改enumerable、writable以及属性的值，删除属性等等 var a = &#123;&#125;Object.defineProperty(a, 'name', &#123;value: 'skyline'&#125;)a // &#123;name: \"skyline\"&#125;a.name = 'lala'a // &#123;name: \"skyline\"&#125;Object.defineProperty(a, 'name', &#123;value: 'skyline', writable: true&#125;) // Uncaught TypeError: Cannot redefine property: name writeable是false，无法再改为trueObject.defineProperty(a, 'age', &#123;value: '18', configurable: true&#125;)a.age = 19 // 19a // &#123;name: \"skyline\", age: \"18\"&#125;Object.defineProperty(a, 'age', &#123;value: '18', writable: true&#125;)a.age = 19a // &#123;name: \"skyline\", age: 19&#125; 扩展、封印与冻结要点","text":"参考资料 《JavaScript高级程序设计》 对象的属性要点 属性分为数据属性与访问器属性 数据属性通过Configurable、Enumerable、Writable、Value来描述，直接建立的属性描述默认都是true（除去Value) 访问器属性通过Configurable、Enumerable、Get、Set来描述，直接建立的属性描述默认都是true（除去Get、Set) Enumerable表示能否通过for-in循环来返回属性 Configurable表示能否删除属性，能否修改某些属性描述符，能否将属性改为访问器(数据)属性 可以通过Object.defineProperty()来定义或者修改属性 Object.defineProperty()接受三个参数，分别是对象名，属性名，描述符对象；数据属性描述符对象只接受configurable、enumerable、writable、value四种属性中的一个或多个;访问器属性描述符对象只接受configurable、enumerable、get、set四种属性中的一个或多个 Object.defineProperty()新增属性时，描述符对象不指定configurable、enumerable、writable时，他们的默认值是false；不指定value、get、set时，默认值是undefined。 Object.defineProperties()同时新增多个属性 Object.getOwnPropertyDescriptor(s) 查看属性描述符 Configurable configurable一旦指定为false，则configurable、enumerable、value、get、set将无法通过Object.defineProperty()重新配置，删除对应的属性将不产生效果（严格模式导致错误），属性将不能转换（数据与访问器之间） configurable一旦指定为false,此时的Writable如果是true则可以修改为false，但是不能从false改为true（只关不开） configurable true，writable false时，可以通过Object.defineProperty()修改value的值，直接赋值无效；configurable false，writable true时可以通过赋值直接修改value的值，通过Object.defineProperty()指定value值将会报错 代码Object.defineProperty()只指定value不指定其他将会导致configurable、enumerable、writable都是false，configurable为false导致该属性不能做出修改，不能调用Object.defineProperty()进行重新配置，故一般情况下需要指定configurable为true，便于之后修改enumerable、writable以及属性的值，删除属性等等 var a = &#123;&#125;Object.defineProperty(a, 'name', &#123;value: 'skyline'&#125;)a // &#123;name: \"skyline\"&#125;a.name = 'lala'a // &#123;name: \"skyline\"&#125;Object.defineProperty(a, 'name', &#123;value: 'skyline', writable: true&#125;) // Uncaught TypeError: Cannot redefine property: name writeable是false，无法再改为trueObject.defineProperty(a, 'age', &#123;value: '18', configurable: true&#125;)a.age = 19 // 19a // &#123;name: \"skyline\", age: \"18\"&#125;Object.defineProperty(a, 'age', &#123;value: '18', writable: true&#125;)a.age = 19a // &#123;name: \"skyline\", age: 19&#125; 扩展、封印与冻结要点 Object.preventExtensions()禁止扩展，Object.isExtensible()检查是否可扩展 Object.seal()封印对象，Object.isSealed()检查是否被封印 Object.freeze()冻结对象，Object.isFrozen()检查是否被冻结 被冻结的对象一定被封印了；当一个被封印的对象所有自有（实例）属性的描述符writable改为false时，那么此时它也是被冻结的，通过isFrozen返回true 被冻结对象的访问器属性如果有set描述符，则它仍旧是可写的 创建对象工厂模式工厂模式解决了创建多个对象的问题，但是没有解决对象识别问题（我的粑粑💩是谁？) function person(name) &#123; var p = new Object() p.name = name return p&#125;var me = person('skyline')me.name // 'skyline' 构造函数模式 按照惯例，构造函数首字母都要大写，非构造函数小写字母开头 构造函数主要问题是方法会在实例中各自创建，me.say === you.say说明了这个问题 function Person(name) &#123; this.name = name this.say = function () &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125;var me = new Person('skyline')var you = new Person('hahaha')me.say() // My name is skylineyou.say() // My name is hahahame.say === you.say // false 原型模式 通过一个名为prototype的指向一个对象的指针属性，为特定类型的所有实例共享属性和方法 无论何时创建新函数，都会根据一组特定的规则来为函数添加一个指向原型对象的prototype的属性 原型对象自动获得一个constructor属性，属性指向prototype属性所在函数的指针 调用构造函数创建一个新的实例之后，该实例内部包含一个指向构造函数原型对象的指针[[Prototype]]（内部属性）。多数浏览器实现了proto来获取[[Prototype]]内部属性，ES6中被标准化为传统功能。可以通过isPrototypeOf()与getPrototypeOf()来确定与获取关系 可以通过对象实例保存原型中的值，不能通过实例重写原型中的值，实例中创建与原型中同名的属性，会屏蔽原型中的属性值。delete可以删除实例中的属性，来重新暴露原型中的属性 hasOwnProperty()来获取自有（实例）属性 in操作符来确定属性是否存在于对象中（包括自有与原型对象） for-in语句遍历所有可枚举的自有（实例）和原型属性，而Object.keys()只会收录自有属性名在数组中 通过直接重写prototype时，注意将构造函数属性加上constructor属性来指定构造函数，此时重新设定的constructor属性是可枚举的，js原生的是不可枚举的，可通过Object.defineProperty()来定义 function Person() &#123; this.name = 'skyline'&#125;Person.prototype = &#123; // constructor: Person, // 指定构造函数 say: function() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125;&#125;var skyline = new Personskyline.say() // My name is skylineskyline.constructor === Person // falseskyline instanceof Person // true 重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系，故重写需谨慎，最好在新建函数的时候重写原型模式最大的问题就是引用类型的值被共享，多个实例之间会相互影响 组合使用构造函数模式与原型模式 最常见方式，组合使用两者，构造函数模式用于实例属性，原型模式用于定义方法和共享属性 动态原型模式 动态原型模式是将原型与自有的信息都封装在构造函数中，通过在必要情况下初始化原型，实现组合使用构造函数与原型的优点。 其实质就是通过检查某个应该存在的方法是否有效来决定是否初始化，if语句检查初始化后应该存在的任何属性或方法，检查其中一个即可。☞ 错误使用以下是错误示例，不能再构造函数中通过对象字面量重写原型 function Person() &#123; this.name = 'skyline' if(typeof this.say != 'function') &#123; // 不能再构造函数中直接用对象字面量重写原型，重写原型对象会切断新原型对象与之前已存在的实例对象之间的联系 Person.prototype = &#123; constructor: Person, // 指定构造函数 say: function() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125; &#125; &#125;&#125;var skyline = new Person// 首次使用时，skyline的__proto__是指向// function Person() &#123; // this.name = 'skyline'// &#125;// 默认产生的原型对象，而不是由字面量创建的新原型对象，调用say将会找不到skyline.say() // VM846:1 Uncaught TypeError: skyline.say is not a function ☞ 正确方法function Person() &#123; this.name = 'skyline' if(typeof this.say != 'function') &#123; Person.prototype.say = function() &#123; console.log(`My name is $&#123;this.name&#125;`) &#125; Person.prototype.sayHi = function() &#123; console.log(`Hi!$&#123;this.name&#125;`) &#125; &#125;&#125;var skyline = new Personskyline.say() // My name is skyline 寄生构造函数模式 除了使用new操作符并把使用的包装函数叫做构造函数之外，此模式与工厂模式并没有区别。 创建的对象与构造函数之间毫无关系，并不能确定其粑粑💩（构造函数）是谁，不推荐。 function Person(name) &#123; var p = new Object() p.name = name return p&#125;var me = new Person('skyline')me.name // 'skyline'me instanceof Person // false 稳妥构造函数模式 稳妥对象是指没有公共属性，其方法不使用this的对象稳妥构造函数模式与寄生构造函数类似，有两点不同一是实例方法不引用this，二是构造函数不使用new。 如下代码中创建了一个稳妥对象，除了say没有其他方式可以访问传入构造函数的原始数据。保证了数据的安全性。 function Person(name) &#123; var p = new Object() p.say = function() &#123; console.log(`My name is $&#123;name&#125;`) &#125; return p&#125;var me = Person('skyline') 继承原型链 由于函数没有签名，ES无法实现接口继承 原型链继承的本质是重写原型对象，代之以一个新类型的实例 通过instanceof isPrototypeOf 来判定原型与实例的关系 给原型添加方法需要在替换原型之后 通过原型链继承，不能通过字面量重写原型 采用原型链继承无法避免原型中包含引用类型值所带来的问题，同时无法向超类型构造函数传递参数，实际很少使用 function Person(name) &#123; // 两只眼睛两条腿 this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;function Man() &#123; this.sex = 'male'&#125;function Woman() &#123; this.sex = 'female'&#125;Man.prototype = new Person()var skyline = new Man()skyline.families.push('sister', 'grandma')var haha = new Man()console.log(haha.families) // [\"papa\", \"mama\", \"sister\", \"grandma\"] 构造函数 为解决原型链继承引用问题而引入，同时解决了无法向超类型传递参数的问题。又称为伪造对象或经典继承 基本思想是子类型构造函数内部调用超类型构造函数 为保证调用超类构造函数不会重写子类属性，需要先调用超类构造函数 将产生方法无法复用的问题 function Person(name) &#123; // 两只眼睛两条腿 this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;function Man() &#123; Person.call(this) this.sex = 'male'&#125;var skyline = new Man()console.log(skyline.feet) // two 组合继承 又称为伪经典继承，就是组合使用原型链和构造函数模式 组合继承是最为常见的继承方式 function Person(name) &#123; // 两只眼睛两条腿 this.name = name this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;Person.prototype.say = function() &#123; console.log(`My name is $&#123;this.name&#125;`)&#125; function Man(name) &#123; Person.call(this, name) this.sex = 'male'&#125;Man.prototype = new Person()var skyline = new Man('skyline')skyline.say() // My name is skylineskyline.families.push('sister', 'grandma')var haha = new Man('haha')console.log(skyline.families) // [\"papa\", \"mama\", \"sister\", \"grandma\"]console.log(haha.families) // [\"papa\", \"mama\"]console.log(skyline.feet) // two 原型式继承(Object.create) 借助原型可以基于已有的对象创建新对象，不必因此创建自定义类型，大致思路如下代码所示 ES5新增了Object.create方法规范了原型式继承 采用此方法与原型链方式相似，包含引用类型的属性始终会被共享 function create(o) &#123; var F = function() &#123;&#125; F.prototype = o return new F()&#125; 寄生式继承 创建一个仅用于封装继承过程的函数，函数内部以某种方式来增强对象 与构造函数类似，方法不能复用 function create(o) &#123; var F = function() &#123;&#125; F.prototype = o return new F()&#125;function createA(o) &#123; var clone = create(o) // 调用任意一个可以返回对象的函数 clone.say = function() &#123; // 增强对象 console.log('hahaha') &#125; return clone // 返回对象&#125; 寄生组合式继承 组合式继承会导致超类型构造函数的两次调用，超类型的实例属性将分别在原型中和实例中被复制而产生两组，实例属性屏蔽了原型中的属性 寄生组合式继承，就是通过借用构造函数来继承属性，通过原型链混成形式来继承方法 最为理想的继承方式 function copyPrototype(subType, superType) &#123; var p = Object.create(superType.prototype) p.constructor = subType subType.prototype = p&#125;function Person(name) &#123; // 两只眼睛两条腿 this.name = name this.eyes = 'two' this.feet = 'two' this.families = ['papa', 'mama']&#125;Person.prototype.say = function() &#123; console.log(`My name is $&#123;this.name&#125;`)&#125; function Man(name) &#123; Person.call(this, name) this.sex = 'male'&#125;copyPrototype(Man, Person)var skyline = new Man('skyline')skyline.say() // My name is skylineskyline.families.push('sister', 'grandma')var haha = new Man('haha')console.log(skyline.families) // [\"papa\", \"mama\", \"sister\", \"grandma\"]console.log(haha.families) // [\"papa\", \"mama\"]console.log(skyline.feet) // two 本文作者： Skyline(lty)本文链接： http://www.skyline.show/chapter6《JavaScript高级程序设计·继承》笔记.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.skyline.show/tags/笔记/"},{"name":"高程","slug":"高程","permalink":"http://www.skyline.show/tags/高程/"}]},{"title":"chapter4-5《JavaScript高级程序设计》笔记","slug":"chapter4-5《JavaScript高级程序设计》笔记","date":"2017-05-22T12:58:25.000Z","updated":"2017-07-29T12:58:25.000Z","comments":true,"path":"chapter4-5《JavaScript高级程序设计》笔记.html","link":"","permalink":"http://www.skyline.show/chapter4-5《JavaScript高级程序设计》笔记.html","excerpt":"参考资料 《JavaScript高级程序设计》 作用域链 作用域链的作用是保证最执行环境有权访问的所有变量和函数的有序访问 作用域链最前端始终都是当前代码所在环境的变量对象，而后一步一步向外成延伸，直到全局执行环境 标志符解析是沿着作用域链一级一级搜索的过程，直到找到为止，故而位于作用域链最前端的变量作为当前环境的变量 垃圾收集 一般使用标记清除，引用计数不再使用，当存在循环引用现象时，“引用计数”会导致问题 通过将值设置成null来解除引用以释放内存。适用于全局对象与属性，局部变量会在离开环境时自动解除引用 循环引用： function test()&#123; var a = new Object(); var b = new Object(); a.child = b; b.child = a;&#125; 数组坑点 数组的length不是只读的，可以通过修改来设置长度 一般通过isArray来判断是否是数组，而不用instanceof 方法","text":"参考资料 《JavaScript高级程序设计》 作用域链 作用域链的作用是保证最执行环境有权访问的所有变量和函数的有序访问 作用域链最前端始终都是当前代码所在环境的变量对象，而后一步一步向外成延伸，直到全局执行环境 标志符解析是沿着作用域链一级一级搜索的过程，直到找到为止，故而位于作用域链最前端的变量作为当前环境的变量 垃圾收集 一般使用标记清除，引用计数不再使用，当存在循环引用现象时，“引用计数”会导致问题 通过将值设置成null来解除引用以释放内存。适用于全局对象与属性，局部变量会在离开环境时自动解除引用 循环引用： function test()&#123; var a = new Object(); var b = new Object(); a.child = b; b.child = a;&#125; 数组坑点 数组的length不是只读的，可以通过修改来设置长度 一般通过isArray来判断是否是数组，而不用instanceof 方法 ☞ 概述（括号内的-表示可选参数） 方法名 描述 参数 返回 是否修改原数组 push 逐个添加至数组屁股 任意（-） 数组新长度 是 pop 砍掉屁股一项 无 被砍掉的屁股 是 shift 砍掉第一项 无 被砍掉的第一 是 unshift 逐个添加至数组头部 任意（-） 数组新长度 是 reverse 反向重排 无 数组 是 sort 排序 fn（-） 数组 是 concat 联结 任意（-） 新数组 否 slice 截取 开始位置（-），结束位置（-） 新数组 否 splice 删除、插入、替换 开始位置（-），结束位置（-），插入项（-） 包含被删除的项的数组，没有则空数组 是 indexOf 查找位置 查找项（-），开始位置（-） 找到返回位置，否则-1 否 lastIndexOf 反向查找 查找项（-），开始位置（-） 找到返回位置，否则-1 否 every 与迭代 迭代函数，this指向作用域（-） 布尔值 否 some 或迭代 迭代函数，this指向作用域（-） 布尔值 否 filter 迭代筛选 迭代函数，this指向作用域（-） 函数返回值为true的项组成的数组 否 map 迭代调整 迭代函数，this指向作用域（-） 函数返回值组成的数组 否 forEach 迭代循环 迭代函数，this指向作用域（-） 无 否 reduce 归并 归并函数，初始值（-） 归并终值 否 reduceRight 反向归并 归并函数，初始值（-） 归并终值 否 增删排改（push、pop、shift、unshift、reverse、sort、splice）会修改原数组 涉及遍历的方法（every、some、filter、map、forEach）第二个参数可以指定上下文 ☞ 分析 方法名 描述 sort 无参数时为每一项调用toString()方法，按返回的字符串首字母升序，有参数fn时fn接受两个参数，即数组的两项，根据fn返回值正负零来确定先后 concat 无参数时返回原数组副本，多个参数中如果有数组，数组每一项添加到新数组，其他类型直接添加 slice 无参数时返回原数组副本，两个参数表示截取开始结束位置，一个参数时表示开始位置截取到最末。参数为复数时，加上数组长度后截取，结束大于开始返回空数组 splice 前两项整数，第一项指定删除与插入的开始位置，第二项指定删除个数，之后项是依次插入的数据 indexOf 参数一到两个，第一项指定查找项，与数组中项对比时要求使用严格相等判定，第二个指定开始位置（可选） every 通过对数组每一项执行函数后全返回true则返回true，否则false some 通过对每一项执行函数后至少一项返回true则返回true，否则false filter 返回通过对每一项执行函数后返回true的项组成的新数组 map 返回通过对每一项执行函数取返回值组成的新数组 reduce 归并函数接受4个参数：前一个值，当前值，项索引，数组对象。归并函数当前返回值作为第一个参数传给下一项 其他描述 slice 截取，如果你跟我一样小学数学不好，每次都要掰手指，参考下图，截取就不会再有问题 'skyline'.slice(1, 5) // \"kyli\"['s', 'k', 'y', 'l', 'i', 'n', 'e'].slice(1, 5) // [\"k\", \"y\", \"l\", \"i\"] indexOf的严格判等 var person = &#123;name: 'skyline'&#125;var people = [&#123;name: 'skyline'&#125;]var family = [person]console.log(people.indexOf(person))// -1console.log(family.indexOf(person))// 0 模拟栈，push + pop 模拟队列，shift + push 模拟反向队列，unshift + pop 正则定义 两种方式，对象字面量与构造函数 元字符需要进行转义 RegExp构造函数接受两个参数。第一个是要匹配的字符串模式，第二个是可选的标识字符串 构造函数使用的模式字符串需要对元字符进行双重转义 举个栗子：字面量定义： /\\.at\\\\skyline/gi构造函数定义： new RegExp(&#39;\\\\.at\\\\\\\\skyline&#39;, &#39;gi&#39;) 方法☞ exec专为捕获组设计，当匹配成功时，返回数组，失败返回null。返回的数组跟正则是否有子串（圆括号内，圆括号被称为捕获括号），是否全局，开始匹配的位置（lastIndex指定）有关。代码1：非全局有子串 var str=\"Skyline should be hardworking(Skyline up up up)\"; var reg=/Sky(line)/;console.log(reg.exec(str));// [\"Skyline\", \"line\", index: 0, input: \"Skyline should be hardworking(Skyline up up up)\"]console.log(reg.exec(str));// [\"Skyline\", \"line\", index: 0, input: \"Skyline should be hardworking(Skyline up up up)\"] 未开启全局，此函数的作用和String类型的match()函数是一样的，只能够在字符串中匹配一次，如果没有找到匹配的字符串，那么返回null 代码2：全局有子串 var str1=\"Skyline should be hardworking(Skyline up up up Skyline)\"; var reg1=/Skylin(e)/g;reg1.lastIndex = 8;console.log(reg1.exec(str1));// VM1002:4 (2) [\"Skyline\", \"e\", index: 30, input: \"Skyline should be hardworking(Skyline up up up Skyline)\"]console.log(reg1.lastIndex);// 37console.log(reg1.exec(str1));// VM1016:1 (2) [\"Skyline\", \"e\", index: 47, input: \"Skyline should be hardworking(Skyline up up up Skyline)\"]console.log(reg1.exec(str1));// VM1021:1 nullconsole.log(reg1.exec(str1));// VM3222:1 (2) [\"Skyline\", \"e\", index: 0, input: \"Skyline should be hardworking(Skyline up up up Skyline)\"] 开启全局，此函数返回值同样是一个数组，并且也只能够在字符串中匹配一次。不过此时，此函数一般会和lastIndex属性匹配使用，此函数会在lastIndex属性指定的字符处开始检索字符串。返回为null时。lastIndex重置为0 基本包装类型要点 包括Boolean、Number、String三种 创建方式包括转型函数（见下）和字面量 引用类型与基本包装类型的主要区别就是对象的生存期 基本包装类型的对象生存期☞ 代码var s = 'skyline's.age = 23console.log(s.age) 以上代码可以想象成如下JS代码周期 ☞ 图示 当最后访问s.age时又创建了一个新的对象，故age不存在 构造函数与转型函数var str = String('skyline')//转型函数，产生基本包装类型，相当于字面量创建console.log(typeof str)//stringvar obj = new String('skyline')//构造函数，产生引用类型console.log(typeof obj)//object 字符串的模式匹配方法☞ 概述（括号内多参数’,’隔开，不同类型参数’/‘隔开，括号内的-表示可选参数） 方法名 描述 参数类型 参数说明 返回 match 本质与正则exec相同 regExp &nbsp; 与exec相同 search 查找字符串第一个匹配项 regExp &nbsp; 字符串第一个匹配项索引，无则-1 indexOf 查找字符串第一个子字符 str，开始位置（-） &nbsp; 字符串第一个子字符串索引，无则-1 replace 替代字符串 regExp/str, str/fn(…args) 分别指定目标字符与替换字符 替换后的字符串 split 指定分隔符分割字符串 regExp/str, num(-) 分别指定分隔字符与返回的数组长度 分隔后所有字符组成的数组 ☞ 详解replace要替换所有子串，第一个参数需要提供全局（g）标志的正则表达式。第二个参数是字符串时，可以使用字符序列表中的字符序列，将正则的到的值插入结果字符串；第二个参数是函数时，参数依次是匹配项，捕获组，匹配项位置，输入 字符序列表 字符序列 正则属性 表意 $&amp; regExp.lastMatch 匹配整个模式的子串（匹配项） $’ regExp.leftContext 匹配子串左边内容 $` regExp.rightContext 匹配子串右边内容 $n regExp[“$n”] 匹配第n个捕获组子串 本文作者： Skyline(lty)本文链接： http://www.skyline.show/chapter4-5《JavaScript高级程序设计》笔记.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.skyline.show/tags/笔记/"},{"name":"高程","slug":"高程","permalink":"http://www.skyline.show/tags/高程/"}]},{"title":"chapter1-3《JavaScript高级程序设计》笔记","slug":"chapter1-3《JavaScript高级程序设计》笔记","date":"2017-05-11T12:56:32.000Z","updated":"2017-07-29T12:56:32.000Z","comments":true,"path":"chapter1-3《JavaScript高级程序设计》笔记.html","link":"","permalink":"http://www.skyline.show/chapter1-3《JavaScript高级程序设计》笔记.html","excerpt":"参考资料 《JavaScript高级程序设计》 JaveScript 由三部分构成图示 script元素async与defer &nbsp; async defer 描述 立即下载脚本，不妨碍其他操作，不依赖其他脚本，不阻塞文档 延迟脚本到文档被解析与显示之后 适用范围 外部引入脚本 外部引入脚本 多个执行顺序 不保证顺序 先后顺序 多个执行顺序：同时出现多个async或defer脚本 Null类型","text":"参考资料 《JavaScript高级程序设计》 JaveScript 由三部分构成图示 script元素async与defer &nbsp; async defer 描述 立即下载脚本，不妨碍其他操作，不依赖其他脚本，不阻塞文档 延迟脚本到文档被解析与显示之后 适用范围 外部引入脚本 外部引入脚本 多个执行顺序 不保证顺序 先后顺序 多个执行顺序：同时出现多个async或defer脚本 Null类型 要点 null表示空对象指针 如果定义的变量将来用于保存对象，建议初始化为null而不是其他值 Boolean()调用或布尔值的隐式转换如表 数据类型 转化成true 转化成false String 非空字符 “”(空字符） Number 非零 0与NaN Object 非Null对象 null Undefined 无 undefined Boolean(NaN) === false //true NaN要点 涉及NaN的操作返回NaN NaN不等于任何值，包括本身 isNaN() isNaN在接收到一个值以后会尝试将这个值转换成数字 任何不能转换成数字的值都会导致函数返回true，各个类型转数字参考类型隐式转换规则 类型隐式转换规则对象隐式转换成字符串或数字 其他隐式转换 值 转化成字符串(调用String()) 转化成数字(Number()) 转化成布尔值 undefined “undefined” NaN false null “null” 0 false NaN “NaN” false []（空数组） “” 0 true “”（空字符串） 0 false 不同对象调用toString()得到的结果如表 &nbsp; 调用toString() 普通对象 “[object Object]” 数组arr arr.join() 函数类 定义函数的代码 日期类 可读日期 正则对象 正则对象字面量的字符 如果数组的某一项的值是null或者undefined，join()方法返回的结果以空字符串连接 不同对象调用valueOf()得到的结果要点 大多数对象，包括普通对象、数组、函数、正则简单返回对象本身 日期对象返回19700101以来的毫秒数值 数值转换函数Number() 其他类型转换为数字时调用的是Number()，故基本转换参考类型隐式转换规则 要返回数字，只接收纯数字字符串作为参数，允许前后有空格，中间不能有，否则返回NaN parseInt() 只要非空格的第一个字符是数字，它就会尽可能长地进行转换，直到遇到空格会或非字母 如果第一个非空格字符是其他，则返回NaN 可接受两个参数，第二个参数指定进制 parseFloat() 只要非空格的第一个字符是数字或小数点，它就会尽可能长地进行转换，直到遇到空格会或非字母 如果第一个非空格字符是其他，则返回NaN 接受一个参数，只解析十进制 只解析一个小数点，第二个小数点号以后字符忽略 逻辑与与逻辑或要点 都是短路操作符，即是第一个操作数可以决定结果，就不会对第二个操作数求值 与操作符，第一个求值是false，直接返回第一个操作数 或操作符，第一个求值是true，直接返回第一个操作数 null、NaN、undefined等求布尔值结果是false(本点适用于第一点，单独提出只是需要注意而已） 故如果它们出现在与操作符第一个操作数，则直接返回它们 如果它们出现在或操作符第一个操作数，则返回第二个操作数 switch语句要点 switch使用的是全等判定 通过为每个case语句后添加break来避免执行多个case的情况，合并多种情况时最好加入注释 functionarguments arguments是一个类数组 它的值永远与对应命名参数的值保持同步。当在函数内部修改了第n个参数a的值，他将会反应到a与arguments[n-1]保持同步 长度是由运行时传入参数个数决定的，而不是定义时 function test(a, b, c)&#123; arguments[0] = &#123;name: 'skyline'&#125; arguments[1] = 2; c = 5; console.log(`a=$&#123;a&#125;, b=$&#123;b&#125;, 第三个参数的值是：$&#123;arguments[2]&#125;, 参数的长度：$&#123;arguments.length&#125;, 第一个参数与a是否相等：$&#123;arguments[0] === a&#125;`)&#125;test(1, &#123;firstName: 'liu'&#125;, '3', 3)// a=[object Object], b=2, 第三个参数的值是：5, 参数的长度：4, 第一个参数与a是否相等：true 参数传递说明：图解与说明仅为了解释参数传递，计算机内存远比此复杂 函数的参数都是按值传递的，当传递引用类型的值时，会把这个值在内存中的地址复制给局部变量,其实质就是把实参在内存中的数据传递给形参，基本类型拷贝了本身，引用类型拷贝的是引用的地址。 进入函数时，通过值传递，形参obj2拷贝了实参obj1的内存数据，即是一个引用地址。 关于按引用传递：（我的理解是传入是形参obj2直接记录实参obj1的内存地址，故而不管什么时候两者谁变化，都将影响另一方，有待考证）C#区分值传递和引用传递是方法参数前加ref，就是引用传递, 不加就是值传递。 ☞ 代码一：var str1 = 'aaa';var num2 = 2;var obj1 = &#123; value: 1&#125;;function foo(obj2) &#123; obj2.value = 2; console.log(obj2.value); //2&#125;foo(obj1);console.log(obj1.value) // 2 在函数执行obj2.value = 2;前后的内存状态 ☞ 代码二：var str1 = 'aaa';var num2 = 2;var obj1 = &#123; value: 1&#125;;function foo(obj2) &#123; obj2 = 2; console.log(obj2); //2&#125;foo(obj1);console.log(obj1.value) // 2 在函数执行obj2 = 2;前后的内存状态 本文作者： Skyline(lty)本文链接： http://www.skyline.show/chapter1-3《JavaScript高级程序设计》笔记.html版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.skyline.show/categories/JavaScript/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://www.skyline.show/tags/笔记/"},{"name":"高程","slug":"高程","permalink":"http://www.skyline.show/tags/高程/"}]}]}